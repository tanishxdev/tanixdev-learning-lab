# 15.8 Error Boundaries

---

# 1. Why Error Boundaries?

### The core problem

In React, if a component throws an error **during rendering**, **in lifecycle**, or **inside child components**, the entire React tree can break.

Example:

* One component fails → whole UI disappears
* White screen of death
* No way to isolate UI failures
* No fallback UI for errors
* No error recovery mechanism

React apps often crash because:

* API returns unexpected data
* Developer mistakes create undefined states
* Third-party components fail
* Code splitting loads corrupted bundles
* Edge-case user input triggers exceptions

To prevent full UI crashes, React introduced **Error Boundaries**.

---

# 2. What is an Error Boundary?

An Error Boundary is a **React component that catches JavaScript errors** in its children during:

* Rendering
* Lifecycle methods
* Constructors

When an error occurs:

* The boundary catches it
* Shows fallback UI
* Prevents the entire app from crashing
* Allows logging/reporting

Important:

**Error Boundaries must be class components.**
Hooks cannot create error boundaries.

Why?
Because error capturing requires component lifecycle control.

React provides two special lifecycle methods:

```jsx
static getDerivedStateFromError(error)
componentDidCatch(error, info)
```

These detect and handle errors gracefully.

---

# 3. When to use Error Boundaries?

Use them when a section of UI might fail independently.

Common use cases:

* Third-party components
* Embedded widgets
* Charts or graphs
* Code-split components (lazy loaded)
* User-generated content
* Form sections with complex logic
* External script integrations
* API-dependent visualization components

Do NOT use Error Boundaries for:

* Event handlers
* Asynchronous code (setTimeout, promises)
* Server-side rendering errors
* Syntax errors

Error Boundaries only catch **render-phase errors**.

---

# 4. Analogy

Imagine a building with multiple electrical circuits:

* If one room’s circuit blows
* The entire building shouldn’t lose power
* Only that room goes dark, and backup lighting appears

Error Boundaries isolate failures:

* Room = child component
* Circuit = error
* Backup lighting = fallback UI

Rest of the building stays functional.

---

# 5. How it works internally

1. React renders component tree
2. If a child throws during render:
   – React stops rendering that branch
   – Moves up tree until it finds an Error Boundary
3. Boundary sets internal state indicating an error
4. React re-renders boundary with fallback UI
5. Error details are available for logging
6. Rest of the UI remains unaffected

React never retries failed rendering unless state changes.

---

# 6. Developer Mindset Thinking

Ask:

1. Could this component fail due to external data?
2. Is this part of UI too complex or unpredictable?
3. Do I want to isolate error impact?
4. Should I show user-friendly error messages?
5. Should errors be logged to a monitoring system?

If YES → wrap with an Error Boundary.

If failure must propagate → don’t wrap.

---

# 7. Simple Code Example

Basic error boundary.

## File: ErrorBoundary.jsx

```jsx
import React from "react";

export default class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Error caught:", error);
    console.error("Component stack:", info.componentStack);
  }

  render() {
    if (this.state.hasError) {
      return <h3>Something went wrong.</h3>;
    }
    return this.props.children;
  }
}
```

## File: ProblematicComponent.jsx

```jsx
export default function ProblematicComponent() {
  throw new Error("Component crashed");
}
```

## File: App.jsx

```jsx
import ErrorBoundary from "./ErrorBoundary";
import ProblematicComponent from "./ProblematicComponent";

export default function App() {
  return (
    <ErrorBoundary>
      <ProblematicComponent />
    </ErrorBoundary>
  );
}
```

---

# 8. Dry Run of the Example

1. App renders
2. ErrorBoundary renders children
3. ProblematicComponent throws error
4. React stops rendering that branch
5. React finds ErrorBoundary
6. Calls getDerivedStateFromError → sets hasError = true
7. componentDidCatch logs error
8. React re-renders ErrorBoundary with fallback UI
9. Final UI shows "Something went wrong" instead of crashing

Rest of the app continues normally.

---

# 9. Example 2: Error Boundary with fallback component

## File: FallbackUI.jsx

```jsx
export default function FallbackUI() {
  return <p>Unable to load this section.</p>;
}
```

## Updated ErrorBoundary:

```jsx
render() {
  if (this.state.hasError) {
    return this.props.fallback || <h3>Error occurred</h3>;
  }
  return this.props.children;
}
```

Usage:

```jsx
<ErrorBoundary fallback={<FallbackUI />}>
  <Chart />
</ErrorBoundary>
```

---

# 10. Common Mistakes

1. Expecting Error Boundaries to catch async errors
   setTimeout errors are not caught.

2. Wrapping too much UI in one boundary
   Leads to large fallback screens.

3. Using functional components as boundaries
   Not supported.

4. Confusing Suspense fallback with Error fallback
   Suspense handles loading, not errors.

5. Catching errors inside event handlers
   Event handlers must use try/catch manually.

---

# 11. When NOT to Use Error Boundaries

* For simple components that never fail
* For catching async or network errors
* For validation or user mistakes
* For replacing try/catch logic
* For preventing app-level crashes caused by fatal errors

Error Boundaries only protect the UI.

---

# 12. Best Practices

1. Use many small Error Boundaries instead of one large one
2. Keep fallback UI simple but helpful
3. Log errors to services like Sentry
4. Wrap risky parts: charts, lazy components, data visualizations
5. Allow retry functionality inside fallback UI
6. Don’t mask critical failures that must be fixed

---

# 13. Compare: Error Boundary vs Suspense

| Feature         | Error Boundary     | Suspense        |
| --------------- | ------------------ | --------------- |
| Handles Errors  | Yes                | No              |
| Handles Loading | No                 | Yes             |
| Works With      | Sync render errors | Async resources |
| Created By      | Class component    | Any component   |
| Used For        | Crashes            | Async waiting   |
| Supports SSR    | Yes                | Yes             |
| Can recover     | Yes                | N/A             |

Suspense = loading management
Error Boundary = error isolation

---

# 14. Follow-up questions

1. Why do Error Boundaries need to be class components?
2. What kind of errors cannot be caught by Error Boundaries?
3. How does getDerivedStateFromError differ from componentDidCatch?
4. Why should boundaries be placed around risky components?
5. Why isn't Suspense enough to handle errors?
6. How does React resume rendering after an error is caught?
7. Why don’t Error Boundaries catch event handler errors?
8. How do Error Boundaries prevent the entire app from crashing?
9. What is the benefit of using multiple small boundaries?
10. How would you implement a retry button inside a fallback UI?
