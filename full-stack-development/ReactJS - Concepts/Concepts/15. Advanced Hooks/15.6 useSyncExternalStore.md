# 15.6 useSyncExternalStore

---

# 1. Why useSyncExternalStore?

### The core problem

React normally manages state **inside components** or through **context**.
But many real projects use **external state sources**, such as:

* Redux
* Zustand
* Jotai
* Local event emitters
* Browser APIs:
  – localStorage
  – Session storage
  – BroadcastChannel
  – IndexedDB listeners
* WebSockets
* Custom stores built with classes

Before React 18, developers used:

* `useEffect`
* `useState`
* Custom subscriptions

These approaches caused issues:

1. **Stale state** (React not knowing when external state changes)
2. **Double rendering** in Strict Mode
3. **Hydration mismatches** in SSR
4. **Inconsistent subscription behavior**
5. **Unnecessary re-renders**
6. Hard to write store libraries that integrate with React

React needed a **standard, reliable, SSR-safe** way to subscribe to external stores.

`useSyncExternalStore` solves this by giving a predictable, consistent, subscription system.

---

# 2. What is useSyncExternalStore?

`useSyncExternalStore` is a React hook that lets a component **safely subscribe to an external store** and re-render when the store changes.

Signature:

```jsx
const value = useSyncExternalStore(
  subscribe, 
  getSnapshot, 
  getServerSnapshot
);
```

Where:

* `subscribe`
  Registers a callback to run when store updates

* `getSnapshot`
  Returns the latest store value for client

* `getServerSnapshot`
  Returns store value for SSR hydration

This is how modern libraries like Redux and Zustand officially integrate with React.

---

# 3. When to use useSyncExternalStore?

Use it when:

* You need a component to subscribe to **external state**
* You are building your own store (Redux-like or Zustand-like)
* External value changes outside React’s lifecycle
* You want stable behavior in concurrent features
* SSR consistency matters
* You want to avoid stale reads

Do NOT use it when:

* State is local → useState
* State is shared but small → useContext
* You are not building a store system
* Derived values that don’t need subscriptions

This hook is mainly used by **state management libraries** and **advanced systems**.

---

# 4. Analogy

Think of an external store as a **newspaper publisher**:

* The publisher updates news (external store)
* Readers subscribe to the newspaper (React components)
* useSyncExternalStore ensures:
  – Readers get the latest version
  – No duplicate deliveries
  – No missed editions
  – No outdated copies

React becomes a reliable subscriber to the store.

---

# 5. How it works internally

Steps:

1. Component renders
2. React calls `getSnapshot()` to read current store value
3. React calls `subscribe(callback)`
4. When store updates:
   – callback runs
   – component re-renders
5. On every render
   React checks if snapshot changed
   If yes → updates UI
6. Works consistently across:
   – Strict Mode
   – Concurrent Rendering
   – SSR hydration

The key improvement:

React avoids tearing.
Tearing = component reading inconsistent external state during concurrent rendering.

useSyncExternalStore completely fixes this.

---

# 6. Developer Mindset Thinking

Ask:

1. Is this data outside React?
2. Does React need to re-render when external state updates?
3. Does this store have multiple subscribers?
4. Should concurrency not break state reading?
5. Am I designing a state management system?

If YES → useSyncExternalStore.

If building normal UI → do not use it.

---

# 7. Simple Code Example

A minimal external store built manually.

## File: store.js

```jsx
let count = 0;
const listeners = new Set();

export const store = {
  getSnapshot: () => count,
  subscribe: (callback) => {
    listeners.add(callback);
    return () => listeners.delete(callback);
  },
  increment: () => {
    count++;
    listeners.forEach((cb) => cb());
  }
};
```

## File: Counter.jsx

```jsx
import { useSyncExternalStore } from "react";
import { store } from "./store";

export default function Counter() {
  const count = useSyncExternalStore(
    store.subscribe,
    store.getSnapshot
  );

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={store.increment}>Increment</button>
    </div>
  );
}
```

---

# 8. Dry Run of the Example

1. Component mounts
2. Calls getSnapshot → returns 0
3. React subscribes to store
4. User clicks increment
   – store updates internal count
   – notifies listeners
5. useSyncExternalStore callback fires
6. Component re-renders with count = 1
7. Concurrency safe: always consistent snapshot

No need for setState in component.

---

# 9. Example 2: Subscribing to browser events

Example: window size store.

## File: windowStore.js

```jsx
let width = window.innerWidth;
const listeners = new Set();

function handleResize() {
  width = window.innerWidth;
  listeners.forEach((cb) => cb());
}

window.addEventListener("resize", handleResize);

export const windowStore = {
  getSnapshot: () => width,
  subscribe: (cb) => {
    listeners.add(cb);
    return () => listeners.delete(cb);
  }
};
```

## Component:

```jsx
const width = useSyncExternalStore(
  windowStore.subscribe,
  windowStore.getSnapshot
);
```

UI always shows correct width, even under concurrency.

---

# 10. Common Mistakes

1. Recreating subscribe or getSnapshot inside component
   → functions must be stable

2. Using it for simple shared state
   → overkill

3. Mixing store logic inside components
   → store must stay external

4. Returning new objects from getSnapshot
   → triggers re-render every time

5. Forgetting unsubscribe
   → memory leaks

---

# 11. When NOT to Use useSyncExternalStore

* Normal local state
* Any state that does not need subscriptions
* Props-based communication
* Derived values from existing state
* Server state (React Query is better)
* Redux or Zustand users → already wrapped internally

This hook is mainly for **store creators**, not consumers.

---

# 12. Best Practices

1. Keep subscribe and getSnapshot stable
2. Store must manage its own data, not React
3. Use this hook only for external sources
4. Use memoization for derived values
5. Never mutate objects inside getSnapshot
6. Keep listeners in a Set for efficiency

---

# 13. Compare: useSyncExternalStore vs useEffect + subscribe

| Feature                  | Old method (useEffect) | useSyncExternalStore |
| ------------------------ | ---------------------- | -------------------- |
| SSR safe                 | No                     | Yes                  |
| Concurrency safe         | No                     | Yes                  |
| Avoids tearing           | No                     | Yes                  |
| Correct re-render timing | No                     | Yes                  |
| Standardized             | No                     | Yes                  |
| Recommended by React     | No                     | Yes                  |

---

# 14. Follow-up questions

1. Why was useSyncExternalStore introduced in React 18?
2. What problem does it solve in Zustand/Redux integrations?
3. What is tearing and how does this hook prevent it?
4. Why must subscribe and getSnapshot be stable functions?
5. When should a developer implement their own store vs using Redux/Zustand?
6. How does React know when to re-render a component using this hook?
7. Why does getSnapshot need to return the same reference when value unchanged?
8. What happens if subscribe does not unsubscribe properly?
9. Why is useEffect not reliable for subscribing to external stores?
10. How does this hook improve SSR hydration stability?
