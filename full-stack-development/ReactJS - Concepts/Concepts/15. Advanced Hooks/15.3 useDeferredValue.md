# 15.3 useDeferredValue

---

# 1. Why useDeferredValue?

### The core problem

Many UI updates depend on **derived values** that are expensive to compute.

Examples:

* Filtering a huge list based on input
* Sorting heavy data
* Generating large tables
* Running expensive calculations when a value changes

If you directly use the input value in such calculations:

* Every keystroke triggers heavy computation
* UI freezes
* Typing becomes slow
* Browser becomes unresponsive
* React wastes time recalculating expensive results on each change

### Real-world example where the UI lags

A search input updates on each keystroke:

```
User types → "a" → filter heavy list  
User types → "ap" → filter again  
User types → "app" → filter again  
```

Result:

* Input lags
* Filtering slows everything
* UI feels unresponsive

You do NOT want to block the urgent update (typing),
but you also need the filtered result eventually.

**useDeferredValue solves this by slowing down only the derived value, not the user input.**

---

# 2. What is useDeferredValue?

`useDeferredValue` creates a **deferred (delayed) version** of a state value.

Meaning:

* The immediate value updates instantly
* The deferred value updates later, when React has time
* Heavy UI work happens using the deferred value
* UI stays responsive even during expensive calculations

Signature:

```jsx
const deferredValue = useDeferredValue(value);
```

`value` = real-time urgent state
`deferredValue` = non-urgent, delayed version

---

# 3. When to use useDeferredValue?

Use it when:

* User input is fast
* Derived UI update is slow
* UI calculations should not block interaction
* You want smooth real-time typing
* Heavy rendering depends on the input value
* You need a simple alternative to useTransition

Examples:

* Live search
* Sorting tables
* Re-rendering huge lists
* Generating visualizations (charts, graphs)
* Pagination calculation

Do NOT use it when:

* Update must happen instantly
* Operation is lightweight
* You need explicit control over priority (useTransition is better)

---

# 4. Analogy

Imagine you write on a whiteboard and someone behind you is updating a giant scoreboard.

* You write instantly (urgent update)
* Scoreboard updates when helper gets time (deferred update)

Your writing is never slowed down by the heavy scoreboard update.

Similarly:

* `value` updates immediately
* `deferredValue` updates later

---

# 5. How it works internally

React marks the deferred value as **transition-priority update**.

Flow:

```
User types → "ap"  
setQuery("ap") updates immediately  
React schedules deferredValue update  
React waits for idle time  
Heavy UI work runs  
UI never blocks  
```

It is similar to `useTransition`, but simpler because:

* You do not wrap anything
* React manages scheduling automatically

---

# 6. Developer Mindset Thinking

Ask:

1. Is the original value used in expensive rendering?
2. Should the UI remain responsive while heavy work runs?
3. Should the derived logic update at a slower pace?
4. Should input update instantly, but results update later?

If yes → useDeferredValue.

If not → useState or useEffect is enough.

---

# 7. Simple Code Example

Filter large data without slowing typing.

## File: DeferredSearch.jsx

```jsx
import { useState, useDeferredValue } from "react";

export default function DeferredSearch() {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);

  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);

  // heavy filtering uses deferredQuery
  const filteredList = items.filter((item) =>
    item.toLowerCase().includes(deferredQuery.toLowerCase())
  );

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />

      <p>Current input: {query}</p>
      <p>Deferred input: {deferredQuery}</p>

      <ul>
        {filteredList.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

# 8. Dry Run of the Example

Step-by-step:

1. User types `a`
   `query` becomes `"a"` immediately
   `deferredQuery` still old value `""`

2. UI renders instantly with `query="a"`
   Filtering still uses deferred value `" "` → no heavy work yet

3. After React gets time:
   `deferredQuery` becomes `"a"`
   Heavy filtering runs

4. User types fast: `"ap"` → `"app"`
   Input stays smooth
   Heavy filtering only runs when React is free

This prevents lag while typing.

---

# 9. Example 2: Deferring expensive calculations

```jsx
const deferredValue = useDeferredValue(input);
const expensiveData = heavyComputation(deferredValue);
```

Input remains responsive.

---

# 10. Common Mistakes

1. Using deferredValue for logic that must be immediate
2. Expecting deferredValue to update instantly
3. Using it for non-expensive UI updates
4. Forgetting that deferredValue may lag
5. Using it when you need explicit control (useTransition is better)

---

# 11. When NOT to Use useDeferredValue

* For synchronous UI updates
* For small lists or cheap calculations
* For user-triggered actions that require instant reaction
* For API triggers
* For animations (useLayoutEffect or useEffect)

It is specifically for heavy derived UI updates.

---

# 12. Best Practices

1. Use only for slow calculations
2. Show UI that deferred value might lag (optional)
3. Keep original value separate from deferred value
4. Use memoization when filtering or sorting
5. Combine with useMemo for best results

---

# 13. Compare: useTransition vs useDeferredValue

| Feature           | useTransition | useDeferredValue |
| ----------------- | ------------- | ---------------- |
| Priority control  | Explicit      | Automatic        |
| How used          | Wrap update   | Wrap value       |
| Best for          | State updates | Derived UI       |
| Control           | High          | Medium           |
| Implementation    | Manual        | Simple           |
| Pending indicator | Yes           | No               |

UseTransition is manual; useDeferredValue is automatic.

---

# 14. Follow-up questions

1. What problem does useDeferredValue solve?
2. How does deferredValue differ from normal state?
3. Why does typing lag without deferred updates?
4. When should useTransition be preferred over useDeferredValue?
5. What happens if the derived logic is not expensive?
6. Why does deferredValue update later?
7. How does React decide when to update deferredValue?
8. Can deferredValue be used for API calls?
9. What is the difference between value and deferredValue?
10. How does useDeferredValue help with virtualized lists?

---# 15.4 useId

---

# 1. Why useId?

### The core problem

In React, we often need **unique, stable, predictable IDs** for:

* Linking labels to inputs (accessibility)
* Associating form fields
* Generating keys for server-rendered components
* Managing ARIA attributes
* Avoiding hydration mismatches in SSR
* Identifying elements for screen readers
* Creating unique IDs without conflicts

Problems happen when:

* You generate IDs manually (`Math.random()`, UUID) → unstable
* IDs change on every render → breaks accessibility
* Client and server render different IDs → hydration warning
* ID collisions in large components
* Form fields lose their associations after Re-render

React needed a built-in solution to generate **stable IDs that stay the same across renders, across SSR/CSR, and avoid duplication**.

`useId` solves this.

---

# 2. What is useId?

`useId` is a hook that generates a **unique, stable, deterministic ID**.

Key features:

* Stays the same across re-renders
* Does NOT reset on each render
* Works perfectly with SSR (server-side rendering)
* Guaranteed unique within the React tree
* Prevents hydration mismatches
* Good for building component libraries

Basic usage:

```jsx
const id = useId();
```

It outputs:

```
:id-123
:id-456
```

React manages uniqueness automatically.

---

# 3. When to use useId?

Use it when you need:

* Unique IDs for input + label
* Unique ARIA associations
* Stable identifiers for accessibility
* IDs in a reusable component library
* IDs that remain the same between client and server
* Avoiding ID collisions when components repeat

Do NOT use it for:

* Keys in lists
* Business logic IDs
* Database IDs
* State management

The hook is purely for **DOM identity**, not data identity.

---

# 4. Analogy

Imagine every student in school gets:

* A roll number (unique, stable, predictable)

React gives your component a “roll number” using `useId` so that:

* Teachers (screen readers) know which student belongs to which desk (label-input binding)
* School branches (SSR & CSR) never assign conflicting numbers
* The roll number does not change daily (stable across renders)

---

# 5. How it works internally

React assigns a unique prefix during rendering.

Rendering steps:

```
Render component
Generate internal ID seed
Append counter
Return stable ID
```

The ID:

* Is deterministic
* Does not depend on state
* Does not change even if component re-renders
* Does not break even with concurrent rendering

React ensures that SSR and CSR generate the exact same ID.

---

# 6. Developer Mindset Thinking

Ask:

1. Does this ID need to survive re-renders?
2. Does this ID need to work for both server and client rendering?
3. Am I building a reusable component?
4. Will this ID be used for labeling or ARIA?
5. Could manual ID generation cause collisions?

If yes → useId.

If not → normal variables or UUIDs are fine.

---

# 7. Simple Code Example

Linking input with label for accessibility.

## File: FormInput.jsx

```jsx
import { useId } from "react";

export default function FormInput() {
  const id = useId();

  return (
    <div>
      <label htmlFor={id}>Username</label>
      <input id={id} type="text" placeholder="Enter name" />
    </div>
  );
}
```

This guarantees:

* Label correctly binds to input
* ID is unique
* No mismatch between renders
* Perfect accessibility support

---

# 8. Dry Run of the Example

1. Component renders
2. `useId()` generates something like `"id-abc123"`
3. React renders:

```
<label htmlFor="id-abc123">
<input id="id-abc123">
```

4. If component re-renders:

* ID stays EXACT same
* No shifting, no new values
* No accessibility break
* No mismatch between label and input

5. Works exactly same on server and client.

---

# 9. Example 2: Multiple fields inside a custom component

```jsx
export default function CustomCheckbox() {
  const id = useId();

  return (
    <div>
      <input type="checkbox" id={id} />
      <label htmlFor={id}>Accept Terms</label>
    </div>
  );
}
```

If you render this component 20 times, each gets its own ID.

---

# 10. Example 3: Prefixing for more control

```jsx
const id = useId();
const emailId = `${id}-email`;
const passwordId = `${id}-password`;
```

Output:

```
id-xyz-email
id-xyz-password
```

Useful for complex forms.

---

# 11. Common Mistakes

1. Using useId for list keys
   → Keys are about reconciliation, not DOM identity

2. Expecting ID to be numeric or sequential
   React IDs are opaque and internal

3. Generating IDs inside loops
   Always call `useId` once per component

4. Using it for storing business data
   It is not meant for application logic

5. Using useId conditionally
   Hooks must not be conditional

---

# 12. When NOT to Use useId

* Creating MongoDB-style IDs
* Tracking entities in state
* Generating list keys
* Storing objects uniquely
* Anything unrelated to DOM identity

For keys → use item.id
For reusable component DOM ID → useId

---

# 13. Best Practices

1. Use for label-input linking
2. Use for ARIA attributes
3. Prefix IDs when components need multiple fields
4. Use inside reusable UI library components
5. Never use for list keys
6. Do not expose useId-generated IDs in APIs

---

# 14. Compare: useId vs UUID vs Keys

| Feature                   | useId | UUID | List Keys               |
| ------------------------- | ----- | ---- | ----------------------- |
| Stable across renders     | Yes   | No   | Yes (if item.id stable) |
| SSR compatible            | Yes   | No   | N/A                     |
| Good for labeling         | Yes   | Yes  | No                      |
| For list reconciliation   | No    | No   | Yes                     |
| Intended for DOM identity | Yes   | No   | No                      |

---

# 15. Follow-up questions

1. Why does React need a built-in ID generator?
2. How does useId prevent hydration mismatches?
3. Why can’t we use UUID for input-label linking?
4. Why should useId not be used for list keys?
5. When is prefixing an ID necessary?
6. What makes useId stable across re-renders?
7. Why does ARIA need deterministic IDs?
8. Why shouldn’t IDs be generated conditionally inside components?
9. How does useId behave in concurrent rendering?
10. Why is useId important for component libraries?

---