# **20.5 Mocking API Requests**

A complete, production-grade explanation of **how to mock API requests** in Jest + React Testing Library, how to test components that fetch data, how to mock Axios or fetch, how to simulate network delays, how to test error states, and how React Query integrates with mocked APIs.

This chapter focuses on **building reliable, isolated, deterministic tests** without hitting real servers.

---

# 1. Why Mock API Requests?

Real API calls should **never** happen during tests.

Problems with real network calls:

* slow
* unpredictable
* external dependencies
* unstable test runs
* require server availability
* difficult to simulate errors
* not deterministic

Mocking API requests ensures:

* instant responses
* full control over returned data
* reproducible tests
* easy error simulation
* isolation from backend

Mocking is a core skill for professional React testing.

---

# 2. What Does “Mocking” Mean?

Mocking means **replacing the real API request with a fake implementation** during tests.

Example:

Instead of hitting:

```
GET https://api.example.com/user
```

Your test injects:

```
return { id: 1, name: "Test User" }
```

You test your **UI behavior**, not the real backend.

---

# 3. Common Tools for Mocking APIs

### 1. jest.mock

Used to replace modules like axios.

### 2. jest.fn

Used to create fake functions that return custom values.

### 3. Mock Service Worker (MSW)

Used for integration-like tests simulating actual HTTP layer.

### 4. Manual mock implementations

Custom mocks for fetch or axios.

This chapter focuses on Jest mocks + axios, since this is the most common pattern.

---

# 4. Mocking Axios (Most Used in React Projects)

A typical setup:

```js
import axios from "axios";

jest.mock("axios");
```

This replaces all axios methods with mock functions.

Now you can simulate:

* success
* errors
* delays
* empty responses

---

# 5. Basic Example: Mocking a GET Request

Component:

```jsx
function User() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    axios.get("/user").then(r => setUser(r.data));
  }, []);

  return <div>{user ? user.name : "Loading..."}</div>;
}
```

Test:

```jsx
test("loads and displays user", async () => {
  axios.get.mockResolvedValue({ data: { name: "Tanish" } });

  render(<User />);

  expect(screen.getByText("Loading...")).toBeInTheDocument();

  expect(await screen.findByText("Tanish")).toBeInTheDocument();
});
```

Key points:

* `mockResolvedValue` simulates a successful response.
* `findByText` waits for async update.

---

# 6. Mocking API Errors

Simulating backend failure:

```js
axios.get.mockRejectedValue(new Error("Network error"));
```

Component must handle errors:

```jsx
function User() {
  const [error, setError] = useState(null);

  useEffect(() => {
    axios.get("/user")
      .then(r => setUser(r.data))
      .catch(err => setError(err.message));
  }, []);

  if (error) return <p>{error}</p>;
  return <p>Loading...</p>;
}
```

Test:

```jsx
test("shows error message", async () => {
  axios.get.mockRejectedValue(new Error("Network error"));

  render(<User />);

  expect(await screen.findByText("Network error")).toBeInTheDocument();
});
```

Your UI should behave correctly under failure.

---

# 7. Mocking Multiple API Calls

```js
axios.get
  .mockResolvedValueOnce({ data: { id: 1 } })
  .mockResolvedValueOnce({ data: { id: 2 } });
```

Each call gets a different response.

Useful when:

* component loads multiple data sources
* pagination
* dependent queries

---

# 8. Mocking POST Requests (Mutations)

Component:

```jsx
function AddItem() {
  const [msg, setMsg] = useState("");

  const handleAdd = () => {
    axios.post("/items", { name: "New" }).then(() => {
      setMsg("Added");
    });
  };

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <p>{msg}</p>
    </>
  );
}
```

Test:

```jsx
test("adds item successfully", async () => {
  axios.post.mockResolvedValue({ data: {} });

  render(<AddItem />);

  await userEvent.click(screen.getByRole("button", { name: "Add" }));

  expect(await screen.findByText("Added")).toBeInTheDocument();
});
```

Simple but essential.

---

# 9. Mocking API Delay

Jest supports fake timers:

```js
jest.useFakeTimers();
```

Component:

```jsx
function Loader() {
  const [data, setData] = useState(null);

  useEffect(() => {
    setTimeout(() => setData("Done"), 500);
  }, []);
});
```

Test:

```jsx
test("handles delayed response", async () => {
  jest.useFakeTimers();

  render(<Loader />);

  expect(screen.getByText("Loading...")).toBeInTheDocument();

  jest.advanceTimersByTime(500);

  expect(await screen.findByText("Done")).toBeInTheDocument();
});
```

You control the timing precisely.

---

# 10. Mocking Fetch (if not using Axios)

Mock global fetch:

```js
global.fetch = jest.fn();
```

Successful response:

```js
fetch.mockResolvedValue({
  json: () => Promise.resolve({ name: "Tanish" }),
});
```

Error:

```js
fetch.mockRejectedValue(new Error("API failed"));
```

Tests work the same way—control the returned data.

---

# 11. Testing Components Using React Query

React Query requires QueryClientProvider in tests.

Setup:

```jsx
function renderWithQuery(component) {
  return render(
    <QueryClientProvider client={new QueryClient()}>
      {component}
    </QueryClientProvider>
  );
}
```

Mock API:

```js
axios.get.mockResolvedValue({ data: { name: "Tanish" } });
```

Component:

```jsx
function User() {
  const { data } = useQuery({
    queryKey: ["user"],
    queryFn: () => axios.get("/user").then(r => r.data)
  });
  return <p>{data.name}</p>;
}
```

Test:

```jsx
test("react query loads user", async () => {
  axios.get.mockResolvedValue({ data: { name: "Tanish" } });

  renderWithQuery(<User />);

  expect(await screen.findByText("Tanish")).toBeInTheDocument();
});
```

React Query automatically updates the UI when the mock resolves.

---

# 12. Using MSW (Mock Service Worker)

MSW mocks the actual HTTP layer.

Example handler:

```js
rest.get("/user", (req, res, ctx) => {
  return res(ctx.json({ name: "Tanish" }));
});
```

MSW is ideal for:

* integration tests
* testing whole flows
* reproducing server behavior

But axios.mock is simpler for unit component tests.

---

# 13. Common Anti-Patterns

Avoid these mistakes:

1. Mocking implementation details instead of responses
2. Using real network calls in tests
3. Waiting with setTimeout instead of findBy…
4. Forgetting to return `res.data` in axios mocks
5. Mocking too much (only mock API, not internal functions)
6. Not resetting mocks between tests

Reset mocks with:

```js
beforeEach(() => jest.clearAllMocks());
```

---

# 14. Full Production Example: Testing List Fetching

Component:

```jsx
function Products() {
  const [items, setItems] = useState([]);

  useEffect(() => {
    axios.get("/products").then(r => setItems(r.data));
  }, []);

  return (
    <ul>
      {items.map(p => <li key={p}>{p}</li>)}
    </ul>
  );
}
```

Test:

```jsx
test("loads product list", async () => {
  axios.get.mockResolvedValue({ data: ["A", "B", "C"] });

  render(<Products />);

  expect(await screen.findByText("A")).toBeInTheDocument();
  expect(screen.getByText("B")).toBeInTheDocument();
  expect(screen.getByText("C")).toBeInTheDocument();
});
```

You verify visible behavior only.

---

# 15. Follow-up Questions

1. Are you mocking axios or fetch consistently across tests?
2. Does your component correctly show loading, success, and error states?
3. Are you using mockResolvedValue vs mockRejectedValue appropriately?
4. Do your tests remain deterministic even when simulating delays?
5. Should some tests use MSW instead for more realistic flows?
6. Does your React Query setup use a proper QueryClientProvider in tests?
7. Are your mocks cleared or reset between tests?
8. Are you over-mocking internal functions instead of API calls?
9. Do your mocked responses match real API shape?
10. Can your tests simulate pagination, errors, and retries?
