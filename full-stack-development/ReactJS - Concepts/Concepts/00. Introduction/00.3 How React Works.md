# React Working – In Depth (Complete Internal Flow)

This is a **deep explanation of how React actually works behind the scenes** — from first render to updates, reconciliation, and DOM changes.

---

## 1. Core Idea of React Working

React follows one main rule:

> UI is a function of State

Meaning:
If state changes → UI must change automatically.

So React’s job is simple:

1. Track state
2. Render UI from state
3. Update UI efficiently when state changes

---

## 2. Full Lifecycle of a React Component

### High level sequence:

```
Component Created
      ↓
JSX Compiled
      ↓
Virtual DOM Created
      ↓
Real DOM Painted
      ↓
User Interaction
      ↓
State Changes
      ↓
Re-render Triggered
      ↓
New Virtual DOM
      ↓
Diffing Algorithm
      ↓
Minimal Real DOM Update
```

---

## 3. Step-by-Step Internal Working

### STEP 1: JSX Compilation

JSX is NOT HTML. It gets converted into JavaScript functions.

```jsx
<h1>Hello</h1>
```

Behind the scenes becomes:

```javascript
React.createElement("h1", null, "Hello")
```

So React works only with JavaScript objects, not HTML.

---

### STEP 2: Virtual DOM Creation

React creates a tree-like structure in memory:

```
Virtual DOM Tree
{
  type: 'h1',
  props: {
    children: 'Hello'
  }
}
```

This is:

* Lightweight
* Faster than real DOM
* Completely in memory

---

### STEP 3: Initial Rendering (Mount Phase)

React converts Virtual DOM into Real DOM and paints on screen.

This phase is called:
➡️ Mounting

Operations:

* create DOM nodes
* attach event listeners
* render UI

---

## 4. What Happens on State Change

Example:

```javascript
setCount(count + 1);
```

This triggers:

1. React marks component for re-render.
2. Component function runs again.
3. New JSX is produced.
4. New Virtual DOM is created.
5. Old Virtual DOM is compared with New one.

This comparison process is called:
✅ Reconciliation (Diffing Algorithm)

---

## 5. Reconciliation & Diffing Algorithm

React compares:

```
OLD Virtual DOM
vs
NEW Virtual DOM
```

Finds what actually changed:

* Text?
* Attribute?
* Element type?

Then updates only those nodes in real DOM.

This avoids full page re-render.

---

## 6. How React Minimizes DOM Updates

React follows rules:

* Same element type → update only properties
* Different type → destroy & recreate
* Child nodes re-ordered → use keys to track

Example:

Before:

```html
<p>Count: 1</p>
```

After:

```html
<p>Count: 2</p>
```

React only changes:

```
Text Node: 1 → 2
```

Not entire paragraph.

---

## 7. Rendering Engine Internals

### Functional Component Execution

When React renders:

```javascript
function App() {
  return <h1>Hello</h1>;
}
```

React does:

1. Calls App()
2. Gets JSX
3. Transforms to Virtual DOM
4. Diff + Update

Important:
Component function EXECUTES every render.

---

## 8. Role of Fiber Architecture

Modern React uses Fiber.

Fiber is a new engine that allows:

* Interruptible rendering
* Priority updates
* Smooth animations
* Concurrent mode

Tasks are broken into small units:

```
Large UI task → Small chunks → Execute intelligently
```

This prevents UI blocking.

---

## 9. How Hooks Fit in Working

### useState:

* Creates state bucket
* Returns current value + updater
* When updater called → triggers render

Pseudo flow:

```
useState(initial):
   store state
   return [value, setValue]

setValue(newValue):
   schedule re-render
```

---

### useEffect:

Runs after DOM paint.

Lifecycle:

```
Render -> DOM Paint -> useEffect runs
```

Used for:

* API calls
* Subscriptions
* DOM interaction

---

## 10. React Rendering Types

### A. Initial Render

Component first appears.

### B. Re-render

Triggered by:

* State change
* Props change
* Parent re-render

### C. Reconciliation

Optimizing DOM changes

---

## 11. Real Internal Flow Example

Component:

```javascript
function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

Working:

1. React calls Counter()
2. Generates VDOM with count=0
3. Shows 0
4. User clicks button
5. setCount(1) called
6. React schedules re-render
7. Counter() runs again
8. New VDOM created with count=1
9. Diff old vs new
10. Only text node updated

---

## 12. Rendering vs Re-rendering

| Term           | Meaning                 |
| -------------- | ----------------------- |
| Render         | First time showing UI   |
| Re-render      | Updating UI             |
| Commit Phase   | Applying changes to DOM |
| Reconciliation | Finding differences     |

---

## 13. Complete React Workflow Diagram

```
Component Function Runs
        ↓
JSX Returned
        ↓
Virtual DOM Created
        ↓
Old VDOM Stored
        ↓
User Action
        ↓
State Updated
        ↓
New VDOM Created
        ↓
Diff Algorithm
        ↓
Minimal DOM Changes
```

---

## 14. Key Internal Concepts

| Concept        | Explanation          |
| -------------- | -------------------- |
| Virtual DOM    | JS copy of UI        |
| Fiber          | Smart task scheduler |
| Reconciliation | Diff old vs new      |
| Commit Phase   | Update real DOM      |
| State Queue    | Holds updates        |

---

## 15. Why React is Fast

1. Virtual DOM diffing
2. Batched updates
3. Efficient scheduling
4. Avoid full page reloads
5. Smart memory tree

---

## 16. Pseudocode of React Engine

```
function renderComponent(component):
    vdom = component()
    compare(vdom, oldVdom)
    applyChanges()
    store vdom

onStateChange():
    mark for render
    re-run component
```

---

## 17. Developer's Mental Model

You just think:

* What should UI look like for this state?

React handles:

* When to update
* How to update
* What to update

---

## 18. Common Myths

❌ React automatically updates full DOM
✅ React updates only what changes

❌ React is slow
✅ React reduces DOM operations

---

## 19. Summary (Deep Working)

| Layer          | Responsibility              |
| -------------- | --------------------------- |
| Component      | UI logic                    |
| JSX            | Template                    |
| Virtual DOM    | UI memory copy              |
| Fiber          | Task manager                |
| Reconciliation | Difference finder           |
| Commit Phase   | Actual DOM update           |
| Hooks          | State & side-effect manager |

---

## 20. Interview Questions

1. Explain React rendering lifecycle.
2. What is reconciliation?
3. How does Virtual DOM improve performance?
4. What happens when state changes?
5. Explain Fiber architecture.
6. Difference between render and commit phase.
7. Why is React declarative?
8. How hooks interact with rendering?
9. How does React decide what to re-render?
10. Explain React diffing algorithm.

---


# React Rendering & Internal Architecture — Interview Questions/Answer (1–10)

---

# 1. Explain React rendering lifecycle.

## Concepts

React’s rendering lifecycle has **two major phases**:

### **1. Render Phase (Pure, No Side Effects)**

* React calls your component function
* Reads state + props
* Builds a new Virtual DOM
* Compares it with previous VDOM (diffing)
* Prepares updates
* This phase must be **pure** (no side-effects allowed)

### **2. Commit Phase (DOM Updates)**

* React applies updates to the actual DOM
* Runs layout effects (`useLayoutEffect`)
* Runs passive effects (`useEffect`)

### Lifecycle Summary

```
State/Props change → Render Phase → Commit Phase → Effects
```

The **render phase can run multiple times**, but **commit phase runs only when DOM updates are needed**.

## Interview Answer

React’s rendering lifecycle consists of a render phase where React calculates changes using Virtual DOM, and a commit phase where it updates the actual DOM and runs effects. Only the commit phase interacts with the browser.

---

# 2. What is reconciliation?

## Concepts

Reconciliation is React’s internal process of:

1. Rebuilding the Virtual DOM tree
2. Comparing it with the previous tree
3. Determining the minimum number of operations required
4. Updating only the changed nodes in the DOM

Reconciliation uses:

* **Diffing algorithm**
* **Fiber nodes (React Fiber)**
* **Heuristics like key matching**

## Interview Answer

Reconciliation is React’s process of comparing the new Virtual DOM with the previous one and updating only the changed parts in the real DOM using efficient diffing.

---

# 3. How does Virtual DOM improve performance?

## Concepts

Virtual DOM improves performance by:

1. Reducing expensive real DOM operations
2. Performing updates **in-memory** first
3. Running diffing to find minimal changes
4. Batch-updating the real DOM
5. Scheduling work using Fiber for smooth rendering

Real DOM updates are slow. Virtual DOM makes them fast by doing most work in memory.

## Interview Answer

Virtual DOM boosts performance by allowing React to compute UI changes in memory, compare trees efficiently, and update only the required DOM nodes instead of re-rendering the full UI.

---

# 4. What happens when state changes?

## Concepts

When state changes:

1. React schedules a re-render
2. Component function runs again (render phase)
3. A new Virtual DOM is generated
4. React compares the new VDOM with the old one (diffing)
5. Commit phase updates only changed DOM nodes
6. Effects run afterward
7. Component UI updates

## Interview Answer

State change triggers a re-render. React recalculates the UI, diffs it with the previous Virtual DOM, and updates only the necessary parts of the real DOM.

---

# 5. Explain Fiber architecture.

## Concepts

React Fiber is the internal engine introduced in React 16. It enables:

* **Time-sliced rendering** (work can be paused/resumed)
* **Prioritized rendering** (urgent tasks first)
* **Smooth UI** during heavy updates
* **Better scheduling**

Fiber breaks work into **small units (fibers)** that React can process incrementally instead of blocking the main thread.

## Interview Answer

React Fiber is the reconciliation algorithm rewrite that allows React to split rendering work into small chunks, prioritize updates, pause/resume work, and keep the UI responsive.

---

# 6. Difference between render and commit phase.

## Concepts

### **Render Phase**

* Pure calculation
* Creates new Virtual DOM
* Can be paused, aborted, or restarted
* No DOM mutations allowed

### **Commit Phase**

* Applies DOM updates
* Runs `useLayoutEffect` and then `useEffect`
* Cannot be interrupted

## Interview Answer

The render phase computes changes using Virtual DOM but does not affect the DOM. The commit phase applies changes to the DOM and runs effects. Render is interruptible; commit is not.

---

# 7. Why is React declarative?

## Concepts

Declarative means you describe **what the UI should look like**, not **how to update it**.

Imperative (Vanilla JS):

```js
button.disabled = isLoading;
```

Declarative (React):

```jsx
<button disabled={isLoading}>Submit</button>
```

React automatically updates UI when state changes.

## Interview Answer

React is declarative because you define the UI based on state, and React handles DOM updates internally, making code simpler, predictable, and easier to maintain.

---

# 8. How do hooks interact with rendering?

## Concepts

### Hooks are tied to the component’s render cycle:

* `useState` provides state preserved between renders
* `useEffect` runs after commit phase
* `useMemo` and `useCallback` optimize re-renders
* `useLayoutEffect` runs before the browser paints
* Hooks must run **in the same order each render**

Hooks do **not** modify rendering; they respond **to** rendering.

## Interview Answer

Hooks work by attaching state and effects to specific points in the render cycle. State hooks trigger re-renders, and effect hooks run after the commit phase. Hooks must follow the rules of consistent ordering.

---

# 9. How does React decide what to re-render?

## Concepts

React re-renders a component when:

* Its **state** changes
* Its **props** change
* Its **parent re-renders**, unless optimized

React checks:

1. If the component function runs
2. Creates new Virtual DOM
3. Diffs with previous VDOM
4. Updates only changed nodes

React does *not* re-render the entire UI—only affected parts.

Optimization tools:

* `React.memo`
* `useMemo`
* `useCallback`

## Interview Answer

React re-renders components when their state or props change. It regenerates the Virtual DOM, compares it with the previous one, and updates only the changed parts in the DOM.

---

# 10. Explain React diffing algorithm.

## Concepts

React uses a **heuristic O(n)** diffing algorithm with these rules:

### Rule 1: Elements of different types → replace entire subtree

`<div>` → `<span>` = full replace

### Rule 2: Compare child nodes recursively

Same type → diff attributes & children

### Rule 3: Keys optimize list diffing

Keys help React match elements uniquely.

Example:

```jsx
{items.map(item => <li key={item.id}>{item.name}</li>)}
```

Without keys → React may re-render entire list
With keys → React moves/updates only changed items

## Interview Answer

React's diffing algorithm compares Virtual DOM trees using optimized heuristics. It replaces nodes of different types, recursively compares same-type nodes, and uses keys to efficiently update lists with minimal DOM changes.

---

