# 18.5 Pagination & Infinite Scroll (React Query)

A complete, production-level guide explaining **how React Query handles pagination and infinite scroll**, why these features exist, how to structure APIs, how to use query keys correctly, and how to avoid common pitfalls.

This is core knowledge for building modern dashboards, e-commerce, feeds, search results, or any large dataset UI.

---

# 1. Why Pagination / Infinite Scroll?

### The core problem

Server datasets can be huge:

* millions of products
* thousands of blog posts
* full user tables
* analytics data

Fetching everything at once is:

* slow
* heavy on memory
* expensive
* unnecessary

You must load data **page by page** or **chunk by chunk**.

React Query provides patterns for both:

### A. **Pagination (page-by-page fetch)**

User clicks "Next Page" or UI uses page number.

### B. **Infinite Scroll (load more on scroll)**

Append new pages to existing data.

React Query makes both extremely efficient using:

* dynamic `queryKey`s
* stale-time
* manual or automatic cache usage
* infiniteQuery handling

---

# 2. Pagination (Page-by-Page)

Pagination means:

```
page=1
page=2
page=3
```

Each page is a separate query.

---

# 3. Basic Pagination Example

### Frontend

```jsx
const { data, isLoading } = useQuery({
  queryKey: ["products", page], // key includes page
  queryFn: () => fetch(`/api/products?page=${page}`).then(r => r.json()),
  keepPreviousData: true
});
```

Important:

```
queryKey MUST include page number
```

Why?

Each page is cached separately:

```
["products", 1] → cache for page 1  
["products", 2] → cache for page 2  
["products", 3] → cache for page 3  
```

With `keepPreviousData`, React Query:

* keeps old page visible
* prevents UI flicker
* shows loader next to old data
* avoids blank screen while fetching new page

---

# 4. Why keepPreviousData Matters?

Without:

```
Change page → product list disappears → loading → new page appears
```

With:

```
Change page → old data stays → background fetch → new page replaces it
```

Better UX.

---

# 5. Pagination Cache Behavior

Imagine:

Page 1 loaded → user navigates to Page 2 → then Page 1 again.

React Query:

* returns cached Page 1 instantly
* checks staleTime
* refetches if required

This avoids unnecessary API calls.

---

# 6. Pagination Example with Navigation Buttons

```jsx
const [page, setPage] = useState(1);

const { data, isFetching } = useQuery({
  queryKey: ["users", page],
  queryFn: () => fetch(`/api/users?page=${page}`).then(r => r.json()),
  keepPreviousData: true,
  staleTime: 5000
});

return (
  <>
    {isFetching && <p>Loading...</p>}
    {data?.users.map(u => <div key={u.id}>{u.name}</div>)}

    <button onClick={() => setPage((p) => Math.max(p - 1, 1))}>
      Prev
    </button>

    <button onClick={() => setPage((p) => p + 1)}>
      Next
    </button>
  </>
);
```

Clean, scalable pagination.

---

# 7. Infinite Scroll (useInfiniteQuery)

React Query gives a special hook:

```
useInfiniteQuery
```

Perfect for:

* social media feeds
* product lists
* infinite scrollers
* comment threads
* news lists

---

# 8. How Infinite Scroll Works

`useInfiniteQuery` requires:

* a query function
* a method to compute **next page param**

Example:

```jsx
const {
  data,
  fetchNextPage,
  hasNextPage,
  isFetchingNextPage
} = useInfiniteQuery({
  queryKey: ["products"],
  queryFn: ({ pageParam = 1 }) =>
    fetch(`/api/products?page=${pageParam}`).then(r => r.json()),

  getNextPageParam: (lastPage) => {
    return lastPage.hasMore ? lastPage.nextPage : undefined;
  }
});
```

---

# 9. How React Query Handles Infinite Data

The returned structure:

```jsx
data.pages = [
  page1,
  page2,
  page3
]
```

Every `fetchNextPage()` call appends to `data.pages`.

Your UI simply flattens it:

```jsx
data.pages.flatMap((page) => page.items)
```

React Query also:

* caches each page
* refetches only stale pages
* preserves scroll position
* avoids duplicate requests

---

# 10. Example: Infinite Scroll UI

```jsx
return (
  <>
    {data?.pages.flatMap((page) =>
      page.items.map((p) => <div key={p.id}>{p.name}</div>)
    )}

    <button
      onClick={() => fetchNextPage()}
      disabled={!hasNextPage || isFetchingNextPage}
    >
      {isFetchingNextPage ? "Loading more..." : "Load More"}
    </button>
  </>
);
```

---

# 11. Infinite Scroll with Intersection Observer

For auto-load when user scrolls:

```jsx
const loadMoreRef = useRef();

useEffect(() => {
  const ob = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting && hasNextPage) {
      fetchNextPage();
    }
  });
  ob.observe(loadMoreRef.current);
  return () => ob.disconnect();
}, [hasNextPage]);
```

HTML:

```jsx
<div ref={loadMoreRef}></div>
```

Hands-free infinite scroll.

---

# 12. Choosing Pagination vs Infinite Scroll

| Feature      | Pagination           | Infinite Scroll         |
| ------------ | -------------------- | ----------------------- |
| UX Style     | Page buttons         | Endless feed            |
| Best for     | Tables, admin panels | Social feed, products   |
| Memory usage | Low                  | Higher (all pages kept) |
| Caching      | Per-page             | Per-page, merged        |
| SEO          | Good                 | Poor                    |
| User Control | High                 | Low                     |

---

# 13. Common Mistakes

1. **Not including pageParam in queryKey**
   Causes data overwriting.

2. **Not using keepPreviousData for pagination**
   Causes UI flicker.

3. **Using infinite scroll for very large datasets**
   Memory grows because all pages kept.

4. **Not defining getNextPageParam**
   Infinite scroll won’t know when to stop.

5. **Using Zustand for paginated server data**
   Wrong tool. No stale-time, no caching.

6. **Triggering fetchNextPage twice due to scroll handlers**
   Use IntersectionObserver instead.

---

# 14. Best Practices

### Pagination

* Always include page in queryKey
* Enable keepPreviousData
* Use staleTime to reduce refetching
* Use server-side filters + pagination
* Reset page to 1 when filters change

### Infinite Scroll

* Prefer useInfiniteQuery
* Use getNextPageParam properly
* Combine pages with flatMap
* Use IntersectionObserver
* Limit max pages for memory control

---

# 15. Dry Run Example (Pagination)

Assume:

```jsx
queryKey: ["posts", page]
```

Flow:

1. Page 1 loads → cached
2. User goes to Page 2 → fetches & caches Page 2
3. User returns to Page 1 → instant load (cached)
4. If staleTime expired → background refresh
5. If cacheTime expired → fetch again

Smooth UX.

---

# 16. Dry Run Example (Infinite Scroll)

1. PageParam = 1 → fetch page 1
2. User scrolls → fetchNextPage → page 2
3. data.pages = [page1, page2]
4. Scroll again → fetch page 3
5. hasNextPage = false → stop

Cached pages remain available until cacheTime expiration.

---

# 17. Follow-up Questions

1. Why must queryKey include the page number in pagination?
2. What is keepPreviousData used for?
3. How does useInfiniteQuery store pages internally?
4. When should pagination be used instead of infinite scroll?
5. Why does infinite scroll consume more memory?
6. What happens when staleTime is long for paginated data?
7. How does React Query deduplicate simultaneous page requests?
8. Why is IntersectionObserver preferred for infinite scroll?
9. How does getNextPageParam work exactly?
10. Why is Zustand a bad choice for server-side pagination?
