# 18.3 Stale vs Fresh Data (React Query)

A deep, production-level explanation of **how React Query decides whether data is fresh or stale**, why this matters, how caching works, and how it affects refetching and UI behavior.

This is one of the most misunderstood but MOST important parts of React Query.

---

# 1. Why Stale vs Fresh Data Matters?

The biggest problem with server-state:

```
Data can become outdated anytime.
```

Your UI needs to decide:

* Should we use cached data?
* Should we refetch?
* Is the data fresh enough?
* Should we show loading again?
* Should we background-refetch?

React Query automates this decision.

Stale/Fresh system =
**React Query’s engine for intelligent caching & refetch control.**

---

# 2. Definitions

## Fresh Data

Data that is considered **valid** and **recent enough**.

React Query will:

* return cached value immediately
* skip network call
* skip background refetch

## Stale Data

Data that is **allowed to be shown**, but React Query thinks it might be outdated.

React Query will:

* show cached data
* trigger background refetch
* update UI automatically when fresh data arrives

Stale does NOT mean unusable.
It means "usable but likely outdated".

---

# 3. How Does React Query Decide Freshness?

Based on **staleTime**.

```js
staleTime: 10000 // 10 seconds
```

Meaning:

```
Data is fresh for 10 seconds.
After 10 seconds → becomes stale.
```

Default staleTime = **0 ms**
Meaning:

```
Data becomes stale instantly after fetching.
```

If stale and component mounts, React Query will refetch automatically.

---

# 4. Why Not Always Refetch?

Because unnecessary API calls cause:

* slow apps
* wasted bandwidth
* server load
* UI flicker
* extra cost

React Query's stale system reduces calls while keeping data fresh.

---

# 5. Example with staleTime

```jsx
useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  staleTime: 5000 // fresh for 5 seconds
});
```

Timeline:

```
T = 0s → fetch → cache → data is fresh
T = 3s → still fresh → no refetch
T = 5.1s → stale → next use will refetch
```

---

# 6. What Happens When Data is Fresh?

When data is fresh:

* Returned instantly from cache
* No network request
* No background refetch
* Fast UI

Fresh = stable, high-performance UI.

---

# 7. What Happens When Data is Stale?

When data is stale:

* Cached data returned immediately
* Background refetch starts
* UI updates automatically on fetch completion
* No visible loading if previous data exists

Stale data prevents UI flickering.

---

# 8. Stale Data Doesn’t Mean Expired

Important:
Stale data is STILL SHOWN.

React Query does NOT throw it away.

It just means:

```
“Refetch when you have the chance.”
```

This helps avoid:

* loading spinners
* flickering
* slow transitions

---

# 9. cacheTime vs staleTime (Important Distinction)

Many confuse these.
Clear distinction:

| Feature  | staleTime                 | cacheTime                           |
| -------- | ------------------------- | ----------------------------------- |
| Meaning  | How long data stays fresh | How long unused data stays in cache |
| Controls | Refetching behavior       | Memory cleanup                      |
| Affects  | background sync           | GC (garbage collection)             |
| Default  | 0 ms                      | 5 minutes                           |

Example:

```
staleTime: 5 seconds  
cacheTime: 5 minutes
```

Meaning:

* After 5 sec → stale
* After 5 min of inactivity → removed from cache

---

# 10. Example Timeline: staleTime + cacheTime

### staleTime = 10 seconds

### cacheTime = 5 minutes

```
T = 0   → fetch → fresh for 10 seconds
T = 10  → becomes stale
T = 20  → still in cache (5 min not reached)
T = 40  → component remount → use stale cache → background refetch
T = 300 → cache expires → removed from memory
```

---

# 11. How Staleness Controls Refetch Behavior

React Query refetches on:

* component mount
* window refocus
* network reconnect
* background intervals
* mutation invalidation

BUT only when data is stale.

Example:

```jsx
refetchOnWindowFocus: true
```

Behavior:

* If fresh → no refetch
* If stale → refetch on focus

This provides intelligent sync.

---

# 12. Example: Omitting staleTime (Default)

```jsx
useQuery({ queryKey: ["stats"], queryFn: fetchStats });
```

Because staleTime = 0:

```
Every mount → refetch  
Every focus → refetch  
Every reconnection → refetch
```

This ensures high freshness but heavier API usage.

---

# 13. Example: Setting a Large staleTime

```jsx
useQuery({
  queryKey: ["products"],
  queryFn: fetchProducts,
  staleTime: 5 * 60 * 1000 // 5 min
});
```

Meaning:

```
User browses → no refetch for 5 minutes.
Data reused from cache.
No flickers.
Fast transitions.
```

Great for product pages or dashboards.

---

# 14. When Should You Use Long staleTime?

Use long staleTime when:

* data doesn’t change often
* product lists
* blog posts
* category filters
* static settings

---

# 15. When Should You Use Short staleTime?

Use short staleTime when:

* fast-changing analytics
* crypto/stock data
* leaderboard updates
* messages/chat
* dashboards with live data

Example:

```jsx
staleTime: 1000 // 1 second
```

---

# 16. Practical Examples

## Example 1: Dashboard Analytics

```jsx
staleTime: 30_000 // 30 seconds
```

Data changes quickly, but not every millisecond.

---

## Example 2: Product List Page

```jsx
staleTime: 5 * 60_000 // 5 minutes
```

Improves UX by removing extra refetches.

---

## Example 3: User Profile

```jsx
staleTime: Infinity
```

User profile rarely changes.

React Query won't refetch automatically.

---

# 17. Dry Run Example

Assume:

```jsx
staleTime: 5000
```

Flow:

1. Data fetched at T=0 → fresh
2. User navigates away
3. User returns at T=3s → still fresh → no refetch
4. User returns at T=7s → stale → background refetch
5. Cached stale data shown → new data replaces it

Perfect UX:
No loading flicker + always updated.

---

# 18. Best Practices

1. Always define staleTime intentionally
2. Choose staleTime based on how often server data updates
3. Avoid staleTime = 0 for large apps (too many refetches)
4. Use Infinity when data rarely changes
5. Use small staleTime for real-time apps
6. Remember: stale != invalid
7. For real-time → also consider WebSockets

---

# 19. Comparison Table (Quick)

| Behavior             | Fresh | Stale          |
| -------------------- | ----- | -------------- |
| Returned immediately | Yes   | Yes            |
| Triggers refetch     | No    | Yes            |
| Background refetch   | No    | Yes            |
| Loading state        | No    | No (if cached) |
| Needs server call    | No    | Only if used   |

---

# 20. Follow-up Questions

1. Why does React Query mark data stale by default?
2. Why is stale data still shown in the UI?
3. How is staleTime different from cacheTime?
4. What happens if staleTime is set to Infinity?
5. Why does React Query refetch on focus only when stale?
6. Why should you avoid staleTime = 0 for most screens?
7. How do stale/fresh rules reduce API load?
8. How does background refetch improve UX?
9. How do different staleTime values affect performance?
10. When is staleTime more important than queryKey?
