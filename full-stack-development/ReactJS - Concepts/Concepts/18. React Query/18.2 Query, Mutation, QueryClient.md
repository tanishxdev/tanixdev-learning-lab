# 18.2 Query, Mutation, QueryClient (React Query Core)

A deep, clean, production-level explanation of the **three core building blocks of React Query**.
This is the “heart” of React Query — if you understand these three, the entire library becomes clear.

---

# 1. Why These Three Concepts Matter?

React Query is built around three pillars:

1. **Query** → Reading data (GET)
2. **Mutation** → Writing/updating data (POST/PUT/DELETE)
3. **QueryClient** → Central brain that manages cache, invalidation, stale-time, refetching

If you understand:

```
Query → how data is fetched & cached  
Mutation → how data is changed & synced  
QueryClient → how data stays fresh & organized
```

you understand React Query.

---

# 2. What is a Query?

## Query = fetch + cache + auto-refetch logic

A Query is used for **reading/fetching data from the server**.

Examples:

* get users
* get products
* get cart items
* get analytics
* get profile

Query handles:

* loading
* error
* caching
* refetch
* stale-time
* background updates
* deduplication

Basic usage:

```jsx
const { data, isLoading, isError } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers
});
```

---

# 3. Why Do We Need Query?

The core problems it solves:

### Problem 1: Duplicate API calls

React Query automatically deduplicates multiple components requesting same data.

### Problem 2: Stale data

React Query knows when data is stale and refetches automatically.

### Problem 3: Reload bugs

React Query persists data between renders.

### Problem 4: Manual loading/error logic

React Query handles these automatically.

### Problem 5: Shared server state

Many components consuming same data — React Query manages this perfectly.

---

# 4. How Query Works Internally

Flow:

```
1. Component mounts
2. React Query checks cache for ["users"]
3. If cached && fresh → return cached value
4. If no cache or stale → run queryFn
5. Store result in QueryClient cache
6. Notify all subscribers
7. Auto-refetch on window refocus
8. Tracks staleTime & cacheTime
```

You get all this for free.

---

# 5. Example Query

```jsx
const { data, isLoading, isError } = useQuery({
  queryKey: ["products"],
  queryFn: () =>
    fetch("/api/products").then((res) => res.json()),
  staleTime: 1000 * 60 * 5, // 5 minutes
});
```

### What React Query does automatically:

* caching
* background refetch
* stale-time management
* request deduplication
* loading/error/success

---

# 6. What is a Mutation?

## Mutation = write/update data on the server

Queries are for GET.
Mutations are for POST / PUT / DELETE.

Examples:

* create user
* update profile
* delete item
* like a post
* submit form
* update product

Basic usage:

```jsx
const mutation = useMutation({
  mutationFn: (newUser) =>
    fetch("/api/user", {
      method: "POST",
      body: JSON.stringify(newUser)
    })
});
```

Then:

```jsx
mutation.mutate({ name: "Tanish" });
```

---

# 7. Why Do We Need Mutation?

Because server updates are complex:

* optimistic updates
* error rollback
* invalidating cached queries
* retry logic
* tracking success/error states

React Query mutations provide:

* `isPending`, `isSuccess`, `isError`
* retry mechanisms
* rollback for optimistic updates
* invalidate relevant queries

Example: After adding a product:

```jsx
mutation.mutate(product, {
  onSuccess: () => {
    queryClient.invalidateQueries(["products"]);
  }
});
```

This keeps UI in sync.

---

# 8. How Mutation Works Internally

Flow:

```
1. mutate() called
2. mutationFn executes (POST/PUT/DELETE)
3. React Query tracks loading/error/success
4. Optionally updates cache optimistically
5. On success → invalidates related queries
6. Queries refetch to get updated data
```

Perfect for UI sync after writes.

---

# 9. What is QueryClient?

## QueryClient = central cache manager for all queries in the app

React Query works only if you wrap your app:

```jsx
const queryClient = new QueryClient();

root.render(
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
);
```

QueryClient stores:

* cached data
* stale vs fresh timestamps
* retry state
* observers (subscribers)
* configurations
* default options

QueryClient also exposes imperative functions:

```jsx
queryClient.invalidateQueries();
queryClient.resetQueries();
queryClient.refetchQueries();
queryClient.getQueryData();
queryClient.setQueryData();
```

It is the “brain” of React Query.

---

# 10. Why QueryClient is Needed?

### Problem 1: Multiple queries need shared cache

QueryClient stores all query caches globally.

### Problem 2: Manual invalidation needed

After mutation → invalidate queries.

### Problem 3: Global configuration

You can set:

* default stale time
* default retry count
* global refetch policy

### Problem 4: Imperative cache manipulation

Very useful in real apps (e.g., optimistic updates).

---

# 11. How QueryClient + Query + Mutation Work Together (Simple Diagram)

```
                 [QueryClient]
                     |
           -------------------------
           |          |           |
       useQuery   useMutation  queryClient APIs
           |          |           |
       GET Data     POST/PUT    Cache Management
```

Queries read.
Mutations write.
QueryClient orchestrates everything.

---

# 12. Real Production Example

### GET (Query)

```jsx
const { data: products } = useQuery({
  queryKey: ["products"],
  queryFn: fetchProducts,
  staleTime: 60000
});
```

### POST (Mutation)

```jsx
const mutation = useMutation({
  mutationFn: addProduct,
  onSuccess: () => {
    queryClient.invalidateQueries(["products"]);
  }
});
```

### Trigger update

```jsx
mutation.mutate(newProduct);
```

---

# 13. Dry Run of How Everything Updates

1. User clicks "Add Product"
2. mutation.mutate(newProduct)
3. React Query sets mutation state → `isPending = true`
4. Backend adds product
5. Mutation success
6. QueryClient invalidates "products" query
7. useQuery refetches products
8. UI updates automatically with new list

No manual state management.
React Query handles everything.

---

# 14. Best Practices

### Queries

* Always give stable `queryKey`
* Keep queryFn pure
* Use staleTime to reduce refetch
* Never manually store query data in Zustand/Redux

### Mutations

* Always invalidate queries after mutation
* Use optimistic updates when needed
* Catch errors in onError
* Return useful data from mutationFn

### QueryClient

* Keep one global instance
* Configure defaults centrally
* Use setQueryData for optimistic UI updates

---

# 15. Summary Table

| Concept         | Purpose                  | Usage                  |
| --------------- | ------------------------ | ---------------------- |
| **Query**       | Read server data         | `useQuery()`           |
| **Mutation**    | Write/update server data | `useMutation()`        |
| **QueryClient** | Cache + orchestration    | Provider + API methods |

These three together replace 80% of Redux/Zustand async logic.

---

# 16. Follow-up Questions

1. Why does React Query separate Query and Mutation?
2. How does QueryClient improve global caching?
3. What happens when queryKey changes?
4. Why is staleTime important?
5. Why must we invalidate queries after mutation?
6. What is the difference between refetch and invalidate?
7. How does React Query deduplicate simultaneous requests?
8. When should we use setQueryData?
9. Why should we not store server data in Zustand?
10. How do mutations trigger UI refresh automatically?
