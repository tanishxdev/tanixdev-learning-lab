# 18.1 Why React Query

A complete, production-level explanation of **why React Query exists**, what problem it solves, how it differs from global state like Zustand/Redux, and when it should be used in real apps.

This is one of the most important concepts in modern React architecture.

---

# 1. Why React Query? (The Core Problem)

React apps deal with **two types of state**:

## A. Client State

Example:

* Modal open/close
* Sidebar toggle
* Theme
* Form fields
* Local filters

Tools: `useState`, `useReducer`, Zustand, Redux Toolkit.

---

## B. Server State (the real problem)

Data that comes from an external server:

* Products
* Users
* Posts
* Comments
* Search results
* Paginated API lists
* Dashboard analytics

### Server state has four challenges:

1. **It can change on the server at any time**
2. **It must be fetched, cached, and updated**
3. **Needs loading/error/success handling**
4. **Needs refetching and background synchronization**

React, Redux, Zustand, Context — none of them solve these naturally.

Example problem with local state/stores:

```
fetch → store → use state → stale → manually update → refetch → stale → repeat
```

This turns into:

* duplicated logic everywhere
* inconsistent caching
* unnecessary API calls
* stale data bugs
* lots of loading/error boilerplate
* no unified async handling

React Query solves all of this automatically.

---

# 2. What React Query Solves

React Query handles **server-state lifecycle** automatically:

| Problem            | React Query Solution     |
| ------------------ | ------------------------ |
| Loading state      | Automatically handled    |
| Error state        | Automatically handled    |
| Caching            | Automatic caching system |
| Stale data         | Stale/fresh tracking     |
| Background refetch | Automatic                |
| Duplicate requests | Deduplication            |
| Pagination         | Built-in helpers         |
| Infinite scroll    | Built-in                 |
| Optimistic updates | Supported                |
| Data invalidation  | Centralized              |
| Sync between tabs  | Possible                 |

React Query removes 80%+ of server data complexity.

---

# 3. When to Use React Query?

Use React Query when:

* Your app fetches data from an API
* You need caching
* You need pagination or infinite scroll
* Data must be synced automatically
* Multiple components read the same API data
* You need optimistic updates (e.g., like button)
* You want automatic retries
* You need error recovery
* You want less boilerplate compared to Redux async thunks

React Query is ideal for:

* Dashboards
* SaaS apps
* E-commerce
* Admin panels
* Financial analytics
* Social media apps
* Anything API-driven

If your app uses API calls → React Query is almost always the best approach.

---

# 4. Analogy for React Query

Imagine your app is a library.

### Zustand / Redux

You manually write down every borrowed book, every return, every due date.

### React Query

You install a library management system:

* automatically tracks all books
* updates when changes happen
* syncs data in background
* shows loading/error states
* avoids duplicate entries
* keeps stale records updated

React Query is an **intelligent data manager**, not just global state.

---

# 5. Why Not Use Zustand or Redux for Server State?

Because:

### Zustand

Great for UI state, but:

* no caching
* no stale/fresh logic
* no invalidation
* no retry behavior
* no pagination
* no background sync
* no deduplication

You end up writing all of this manually.

---

### Redux Toolkit

Better than Zustand for server state, but:

* createAsyncThunk still only does fetch+store
* no built-in caching
* no stale times
* no invalidation
* no background sync

RTK Query solves this but still heavier than React Query.

---

### React Query exists because server state is fundamentally different from client state.

React Query handles server-state lifecycles, not global state storage.

---

# 6. How React Query Works (High-Level)

When you do:

```jsx
const { data, isLoading, isError } = useQuery(["products"], fetchProducts);
```

React Query:

1. Checks cache
2. Returns cached value instantly (if present)
3. If stale, fetches new data in background
4. Manages loading, error, success states
5. Deduplicates requests
6. Caches response with a stale time
7. Revalidates data when re-focused
8. Updates all components subscribed to this query

This behavior is impossible with plain React or Zustand.

---

# 7. Developer Mindset Thinking

Before using React Query, ask:

1. Is the data coming from a server?
2. Will many components use the same data?
3. Does this data need caching?
4. Does this data become stale over time?
5. Will this data need refetch or auto-sync?
6. Do I need pagination/infinite scroll?
7. Will users update the data (mutations)?

If answer is yes → React Query.

---

# 8. Example: Basic Query

```jsx
const { data, isLoading, isError } = useQuery({
  queryKey: ["users"],
  queryFn: () => fetch("/api/users").then(res => res.json())
});
```

React Query automatically provides:

* loading state
* caching
* deduplication
* auto-refetch on window focus
* error handling

---

# 9. Example: Mutation (Create User)

```jsx
const mutation = useMutation({
  mutationFn: (newUser) =>
    fetch("/api/user", {
      method: "POST",
      body: JSON.stringify(newUser)
    })
});
```

This gives:

* loading
* error
* success
* invalidation triggers

All automatic.

---

# 10. Example: Automatic Refetch on Component Focus

If you switch to another tab and return, React Query refreshes stale data:

```
User opens tab → switch → return → React Query refetches
```

No extra code required.

---

# 11. Example: Cache Time + Stale Time

React Query prevents duplicate API calls:

```jsx
useQuery({
  queryKey: ["products"],
  queryFn: fetchProducts,
  staleTime: 1000 * 60 * 5 // 5 minutes
});
```

Meaning:

* App stays fast
* Data stays fresh
* API calls reduce drastically

---

# 12. Why React Query is a Must in Modern React

Because modern apps have:

* tons of API calls
* real-time dashboards
* shared data across components
* search and filtering
* optimistic updates
* frequent refetch needs

React Query provides:

```
DATA LAYER = automated
UI LAYER = clean
```

Separation of concerns becomes very clean.

---

# 13. When NOT to Use React Query

Avoid React Query when:

* Data is not coming from a server
* State is purely UI
* You don’t need caching
* You don’t want dependency on a library
* Your app uses SSR-heavy Next.js (then use server components instead)

---

# 14. Best Practices Summary

1. use Zustand/Redux for **client state**
2. use React Query for **server state**
3. split UI state and data state logically
4. don’t store API responses inside Zustand
5. let React Query handle caching + invalidation
6. choose the right staleTime / cacheTime
7. always use query keys carefully

---

# 15. State Management Cheat Sheet (Very Important)

| Type of State           | Best Tool                 |
| ----------------------- | ------------------------- |
| UI Local State          | useState                  |
| UI Global State         | Zustand                   |
| Business Global State   | Redux Toolkit             |
| Server Data             | React Query               |
| High-Frequency Realtime | Zustand/WebSockets        |
| Very Large App          | Redux Toolkit + RTK Query |

This division is used by professional teams.

---

# 16. Follow-up Questions

1. Why can’t Zustand replace React Query for server state?
2. How does React Query prevent stale data bugs?
3. What is the difference between caching and persisting?
4. Why does React Query not belong to global state?
5. How does React Query deduplicate network requests?
6. When should you choose RTK Query instead?
7. Why is React Query ideal for dashboards?
8. What happens if you store API data inside Zustand?
9. What is stale time vs cache time?
10. Why does React Query automatically refetch on focus?
