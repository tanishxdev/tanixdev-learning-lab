# 16.6 Entity Adapter

---

# 1. Why Entity Adapter?

### The core problem

In Redux, storing **lists of items** (users, products, todos, posts, etc.) leads to typical issues:

1. Arrays are slow to update immutably
2. Removing an item requires filtering the whole list
3. Updating one item requires mapping every item
4. Searching by ID is O(n) instead of O(1)
5. Keeping arrays sorted during updates is hard
6. Logic becomes repetitive:

   * add item
   * update item
   * remove item
   * set all
   * upsert (update or insert)

Every Redux project ends up rewriting the same boilerplate.

Example old reducer logic:

```js
case "UPDATE_USER":
  return {
    ...state,
    users: state.users.map(u => u.id === action.payload.id ? action.payload : u)
  };
```

Tedious, inefficient, and error-prone.

**Entity Adapter** solves these problems in one shot.

---

# 2. What is Entity Adapter?

Entity Adapter is a Redux Toolkit utility that provides:

* A **normalized structure** for lists
* Built-in reducers for CRUD operations
* Fast lookup via ID
* Immutable updates powered by Immer
* Standardized list management
* Sorting and ID selection
* Cleaner reducers, fewer bugs

It stores data like this:

```js
{
  ids: ["1", "2", "3"],
  entities: {
    "1": { id: "1", name: "A" },
    "2": { id: "2", name: "B" },
    "3": { id: "3", name: "C" }
  }
}
```

This gives:

* O(1) lookup
* O(1) update
* Efficient immutable updates

---

# 3. When to use Entity Adapter?

Use it when you manage **collections of items**, for example:

* Todos
* Users
* Products
* Posts
* Comments
* Notifications
* Chat messages
* Any CRUD-heavy domain

Do NOT use it when:

* State is not a list
* Data has no unique ID
* You don’t need fast updates/search

---

# 4. Analogy

Think of a school database:

### Normal array approach:

Store students in one long list → searching, updating is slow.

### Entity Adapter approach:

Store by roll number:

```
rollNumbers = [1,2,3]
records = {1: data, 2: data, 3: data}
```

Updates become instant and clean.

---

# 5. How Entity Adapter works internally

1. You define an adapter:

```js
const usersAdapter = createEntityAdapter();
```

2. Adapter returns:

   * `getInitialState()`
   * CRUD reducers:

     * addOne
     * addMany
     * setOne
     * setMany
     * removeOne
     * upsertOne
     * updateOne

3. You integrate adapter reducers inside createSlice.

4. Selectors auto-generated:

   * selectAll
   * selectById
   * selectIds

Everything normalized automatically.

---

# 6. Developer Mindset Thinking

Ask:

1. Am I storing “many items of same structure”?
2. Do these items have unique IDs?
3. Will I update, delete, add items frequently?
4. Do I want O(1) lookup and CRUD convenience?
5. Do I need clean and scalable reducers?

If YES → use Entity Adapter.

---

# 7. Code Example (Full CRUD with Entity Adapter)

## File: usersSlice.js

```jsx
import { createSlice, createEntityAdapter } from "@reduxjs/toolkit";

const usersAdapter = createEntityAdapter({
  selectId: (user) => user.id,           // default: user.id
  sortComparer: (a, b) => a.name.localeCompare(b.name)
});

const initialState = usersAdapter.getInitialState({
  status: "idle"
});

const usersSlice = createSlice({
  name: "users",
  initialState,
  reducers: {
    addUser: usersAdapter.addOne,
    addUsers: usersAdapter.addMany,
    updateUser: usersAdapter.updateOne,
    removeUser: usersAdapter.removeOne,
    setUsers: usersAdapter.setAll,
    upsertUser: usersAdapter.upsertOne
  }
});

export const {
  addUser,
  addUsers,
  updateUser,
  removeUser,
  setUsers,
  upsertUser
} = usersSlice.actions;

export default usersSlice.reducer;

export const usersSelectors = usersAdapter.getSelectors(
  (state) => state.users
);
```

---

# 8. Dry Run (update logic)

Suppose initial normalized state:

```
ids = ["1","2"]
entities = {
  "1": {id:"1", name:"A"},
  "2": {id:"2", name:"B"}
}
```

Now:

```js
dispatch(updateUser({ id: "2", changes: { name: "Updated" } }));
```

Entity Adapter:

1. Finds entity with ID "2"
2. Applies only the changed fields
3. Maintains immutability automatically
4. Does not touch other entities
5. No array traversal needed

Efficient and clean.

---

# 9. Example 2: Using selectors

```jsx
const users = useSelector(usersSelectors.selectAll);
const singleUser = useSelector((state) =>
  usersSelectors.selectById(state, 5)
);
const userIds = useSelector(usersSelectors.selectIds);
```

Selectors are optimized and safe.

---

# 10. Example 3: Using with createAsyncThunk (combined)

```jsx
extraReducers: (builder) => {
  builder.addCase(fetchUsers.fulfilled, (state, action) => {
    usersAdapter.setAll(state, action.payload);
  });
}
```

No manual loops.
Data normalization happens automatically.

---

# 11. Common Mistakes

1. Storing non-list data in Entity Adapter
2. Adding duplicate IDs (adapter will overwrite silently)
3. Using wrong `id` field → must define selectId if custom
4. Forgetting to use selectors instead of manual state access
5. Doing list operations manually despite adapter support
6. Storing deeply nested objects (flatten before storing)

---

# 12. When NOT to Use Entity Adapter

* When the data has no unique ID
* When data is not list-like
* When state is local to a component
* When lists rarely update and performance doesn’t matter
* When server state is better handled with RTK Query

---

# 13. Best Practices

1. Always use getSelectors for UI components
2. Prefer upsertOne for API responses
3. Keep state shallow
4. Use sortComparer for automatic sorting
5. Name adapter methods same as domain actions
6. Combine with RTK Query for powerful list management
7. Keep all list operations inside slice, never in components

---

# 14. Comparison: Entity Adapter vs Array Reducers

| Feature            | Array       | Entity Adapter |
| ------------------ | ----------- | -------------- |
| Lookup by ID       | O(n)        | O(1)           |
| Update one item    | map()       | updateOne      |
| Delete item        | filter()    | removeOne      |
| Insert item        | push/spread | addOne         |
| Immutable update   | Manual      | Automatic      |
| Normalized state   | No          | Yes            |
| Selectors built-in | No          | Yes            |
| Sorting            | Manual      | Built-in       |

Entity Adapter is a major scalability upgrade.

---

# 15. Follow-up questions

1. Why does Entity Adapter store data as ids + entities?
2. What is the difference between addOne, upsertOne, and updateOne?
3. How does sortComparer help consistency?
4. Why is O(1) lookup important for large lists?
5. How does Entity Adapter integrate with createAsyncThunk?
6. Why should selectors be used instead of manually accessing state?
7. What problems occur when storing large arrays without normalization?
8. When should you avoid using Entity Adapter?
9. How does Immer improve adapter operations?
10. How does Entity Adapter compare with normalized Redux patterns?

---