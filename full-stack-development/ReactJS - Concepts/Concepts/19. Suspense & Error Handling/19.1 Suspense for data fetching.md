# **19.1 Suspense for Data Fetching**

React Suspense is a rendering mechanism that lets components **wait for asynchronous data** before rendering.
It is not a data-fetching library by itself. Instead, it gives a **consistent UI experience during loading states**.

React Query integrates with Suspense to provide:

1. Automatic loading boundaries
2. Automatic error boundaries
3. Cleaner component code
4. Declarative asynchronous UI
5. A predictable rendering flow

Modern apps use Suspense especially with:

* React Query
* Server Components
* Streaming UI
* Error Boundaries

---

# 1. Why Suspense?

## The Problem Without Suspense

Typical fetching component:

```jsx
const { isLoading, data, error } = useQuery(...);

if (isLoading) return <Spinner />;
if (error) return <ErrorBox />;
return <ProductList data={data} />;
```

Problems:

1. Loading logic gets duplicated in every component.
2. Error logic gets duplicated.
3. The UI tree becomes noisy with conditionals.
4. Breaks composition patterns.
5. Hard to coordinate nested async components.

---

# 2. What Suspense Solves

Suspense centralizes loading logic:

* You wrap a component inside a `<Suspense>` boundary.
* If the component is waiting for async data, it "suspends".
* Suspense boundary automatically shows a fallback UI.
* When data is ready, the component renders normally.

Error boundaries work the same way for errors.

This produces a clean, layered asynchronous UI system.

---

# 3. How React Suspense Works Internally (High-Level)

When Suspense-enabled code hits a pending async operation:

1. The component throws a Promise internally.
2. React catches the thrown Promise.
3. React displays the nearest `<Suspense fallback={...} />`.
4. When the Promise resolves, React retries rendering the component.

You never manually throw a Promise.
Libraries like React Query handle this internally.

---

# 4. Enabling Suspense in React Query

React Query provides a mode that integrates with Suspense:

```jsx
const client = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true,
      useErrorBoundary: true
    }
  }
});
```

Two important flags:

* `suspense: true` → loading handled by Suspense
* `useErrorBoundary: true` → errors handled by ErrorBoundary

This completely removes the need for:

* isLoading
* error
* manual conditionals

---

# 5. Basic Example: Using Suspense + React Query

## Step 1: Create a Query Hook

```jsx
export function useProducts() {
  return useQuery({
    queryKey: ["products"],
    queryFn: () => api.get("/products").then(r => r.data),
    suspense: true
  });
}
```

## Step 2: Component Using the Data

```jsx
export function Products() {
  const { data } = useProducts();
  return (
    <ul>
      {data.map(p => <li key={p.id}>{p.name}</li>)}
    </ul>
  );
}
```

## Step 3: Wrap it in Suspense

```jsx
<Suspense fallback={<p>Loading...</p>}>
  <Products />
</Suspense>
```

Now:

* When data is loading → Suspense shows fallback.
* After load → products render.

No `isLoading` logic inside components.

---

# 6. Suspense + Error Boundary Example

Add an error boundary:

```jsx
<ErrorBoundary fallback={<p>Failed to load</p>}>
  <Suspense fallback={<p>Loading...</p>}>
    <Products />
  </Suspense>
</ErrorBoundary>
```

This gives:

* Loading handled by Suspense
* Errors handled by ErrorBoundary
* Component tree stays clean

---

# 7. Why This Is Better (Dev Mindset)

Suspense gives:

1. Separation of concerns
   Loading and error UI are no longer mixed inside every component.

2. Cleaner components
   Component returns **data-only UI**.

3. Better composition
   Nested Suspense boundaries allow per-section loading.

4. Better UX
   Different parts of UI can load independently.

5. Error and loading boundaries behave like real UI layers.

---

# 8. Nested Suspense Boundaries (Practical Use)

Example:

```jsx
<Suspense fallback={<LayoutLoader />}>
  <PageLayout>
    
    <Suspense fallback={<SidebarLoader />}>
      <Sidebar />
    </Suspense>

    <Suspense fallback={<MainLoader />}>
      <MainContent />
    </Suspense>

  </PageLayout>
</Suspense>
```

Benefits:

* Sidebar loads separately
* Main content loads separately
* Page skeleton loads instantly

This produces extremely smooth UX.

---

# 9. Suspense and Axios Integration

Suspense does not care about Axios directly.
React Query integrates with Axios through:

```jsx
queryFn: () => api.get("/").then(res => res.data),
```

When Axios is pending → React Query suspends the component.
When Axios resolves → data becomes available.
If Axios throws → ErrorBoundary catches it.

---

# 10. Example With Delay Simulation (Realistic)

To simulate server delay:

```jsx
export function useUser() {
  return useQuery({
    queryKey: ["user"],
    queryFn: () =>
      api.get("/user").then(r => {
        return new Promise(res => {
          setTimeout(() => res(r.data), 1000);
        });
      }),
    suspense: true
  });
}
```

Using:

```jsx
<Suspense fallback={<SkeletonUser />}>
  <UserProfile />
</Suspense>
```

Suspense fallback appears for exactly 1s.

---

# 11. Common Mistakes and Solutions

### Mistake 1: Using `isLoading` with Suspense

Not needed. Suspense handles loading.

### Mistake 2: Forgetting `useErrorBoundary: true`

Then errors do not bubble to ErrorBoundary.

### Mistake 3: Wrapping entire app in one Suspense

Use smaller Suspense boundaries for smoother UX.

### Mistake 4: Combining Suspense with stale data incorrectly

You must use:

```
staleTime: X
```

Otherwise Suspense might show fallback too often.

---

# 12. When Should You Use Suspense?

### Use Suspense for:

* Dashboards
* Profile pages
* E-commerce product pages
* Apps with skeleton UI
* Components with expensive fetching
* Components nested deep in UI

### Avoid Suspense when:

* You want granular loading inside component
* You depend heavily on conditional fetching
* You want to avoid additional boundaries

Suspense is best when **UI and Data boundaries align**.

---

# 13. Full Production Architecture Example

```
App
 ├── Suspense (page skeleton)
 │     ├── Header
 │     ├── Suspense (sidebar skeleton)
 │     │     └── Sidebar
 │     └── Suspense (main skeleton)
 │           └── MainContent
 │
 ├── ErrorBoundary (global)
```

Each part loads independently.
This is how modern web apps feel “instant”.

---

# 14. Follow-up Questions

1. What does Suspense actually do inside React?
2. How do React Query and Suspense work together?
3. Why does Suspense require a thrown Promise?
4. What is the difference between Suspense and isLoading?
5. How does nested Suspense improve UX?
6. Why do we need ErrorBoundary with Suspense?
7. How does Suspense coordinate asynchronous rendering?
8. What are concurrent features of Suspense?
9. How do Suspense boundaries affect hydration in SSR?
10. Why is Suspense considered declarative loading?

---

# 15. Summary (Mental Model)

Suspense = UI layer that handles waiting.

React Query = Data layer that manages asynchronous state.

Together:

* React Query suspends on pending data
* Suspense shows loading UI
* ErrorBoundary handles failures
* Components stay clean and declarative

This is the modern approach for fetching-heavy apps.

---
