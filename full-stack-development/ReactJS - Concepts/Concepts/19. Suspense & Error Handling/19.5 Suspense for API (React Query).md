# **19.5 Suspense for API (React Query)**

A complete, production-level explanation of **how Suspense integrates with React Query for API fetching**, why this pattern is used in modern apps, how loading and error states are externalized through boundaries, and how this approach produces clean, declarative, predictable UI flows.

---

# 1. What Is Suspense for API?

Suspense for API is a mechanism where **React Query manages async data**, and React Suspense manages **the waiting UI**.

Normally, you write:

```jsx
if (isLoading) return <Spinner />;
if (error) return <ErrorBox />;
```

With Suspense + React Query:

```jsx
<Suspense fallback={<Skeleton />}>
  <UserProfile />
</Suspense>
```

Inside `UserProfile`, your data fetching hook:

```jsx
useQuery({
  suspense: true,
  useErrorBoundary: true
});
```

React Query:

* Suspends during loading
* Throws during error
* Provides data during success

Suspense + ErrorBoundary handle UI.

---

# 2. Why Use Suspense for API?

## Problem Without Suspense

1. Loading and error UI pollute components
2. Repetitive checks everywhere
3. Inconsistent user experience
4. Hard to coordinate multiple loading components
5. Nested components become cluttered with states

## Solution

Suspense moves loading responsibility to layout/UI boundaries.
Error Boundaries move failure responsibility to designated error UIs.

This creates a **clean separation**:

```
Components = pure views
Boundaries = loading + error logic
React Query = data logic
```

Your component code becomes simpler.

---

# 3. How React Query Integrates with Suspense

React Query normally returns:

* isLoading
* data
* error

When you enable Suspense mode:

```jsx
useQuery({
  queryKey: ["user"],
  queryFn: getUser,
  suspense: true,
  useErrorBoundary: true
});
```

React Query now behaves differently:

* Instead of giving `isLoading`, it **throws a Promise**, making React suspend.
* Instead of giving `error`, it **throws the error**, which is caught by ErrorBoundary.
* The component only renders when data is ready.

The component becomes:

```jsx
export function UserProfile() {
  const { data } = useQuery(...); 
  return <ViewUser data={data} />;
}
```

No loading or error logic inside the component.

---

# 4. Basic Suspense for API Example

API Hook:

```jsx
export function useUser() {
  return useQuery({
    queryKey: ["user"],
    queryFn: () => api.get("/user").then(res => res.data),
    suspense: true,
    useErrorBoundary: true
  });
}
```

Component:

```jsx
export function UserProfile() {
  const { data } = useUser();
  return <div>{data.name}</div>;
}
```

Wrapper:

```jsx
<ErrorBoundary fallback={<UserError />}>
  <Suspense fallback={<UserSkeleton />}>
    <UserProfile />
  </Suspense>
</ErrorBoundary>
```

This is the full Suspense-based data flow.

---

# 5. How Errors Flow Through Suspense for API

Error flow:

1. API request fails
2. Axios throws error
3. React Query catches and rethrows
4. Suspense cannot catch errors
5. ErrorBoundary catches the thrown error
6. Shows fallback UI
7. User may retry

This division ensures:

* Suspense handles loading only
* ErrorBoundaries handle errors only

---

# 6. Coordinating Multiple Queries with Suspense

Example:

```jsx
<Suspense fallback={<PageSkeleton />}>
  <Dashboard />
</Suspense>
```

Inside Dashboard:

```jsx
const { data: stats } = useStats();
const { data: products } = useProducts();
const { data: users } = useUsers();
```

All useQuery hooks:

* Feel like synchronous code
* Are orchestrated by Suspense
* Run in parallel
* Wait together under the same boundary

React Query internally:

* Starts all queries
* Suspends until all resolve
* Renders Dashboard after everything is ready

This creates a cohesive loading experience.

---

# 7. Fine-Grained Suspense Boundaries for API

You can isolate slow sections.

```jsx
<Suspense fallback={<StatsSkeleton />}>
  <StatsSection />
</Suspense>

<Suspense fallback={<ProductsSkeleton />}>
  <ProductSection />
</Suspense>
```

React Query will individually suspend each section based on:

* network speed
* backend response time
* stale-time rules
* cache freshness

You get the feeling of real-time streaming UI.

---

# 8. Combining Suspense with React Query Stale/Fresh Behavior

Suspense will only fire when:

* Query is fetching for the **first time**
* Query becomes invalidated and needs **fresh data**

If you set:

```jsx
staleTime: 5 * 60 * 1000
```

React Query will:

* Serve cached UI instantly
* Not show loading UI
* Not suspend

Suspense triggers only for initial hydration or stale cases.

This creates faster, smoother UI.

---

# 9. Example: Suspense + Mutations Flow

Fetch product details:

```jsx
function ProductDetails() {
  const { data } = useQuery({
    queryKey: ["product", id],
    queryFn: () => api.get(`/products/${id}`).then(r => r.data),
    suspense: true
  });
  return <ProductView data={data} />;
}
```

Mutation:

```jsx
const mutation = useMutation({
  mutationFn: (payload) => api.put(`/products/${id}`, payload),
  onSuccess: () => queryClient.invalidateQueries(["product", id])
});
```

Flow:

1. User edits product
2. Mutation succeeds
3. Query invalidates
4. ProductDetails suspends again
5. Suspense fallback appears briefly
6. New data appears

This produces a predictable update-reload UI cycle.

---

# 10. Cached Data + Suspense

When cached data exists AND staleTime has not expired:

* Suspense does not show fallback
* Data renders instantly
* A background refetch may still happen

Example:

```
UserProfile loads instantly from cache
Then fetches fresh data quietly
```

Only when data is missing or expired does Suspense show fallback.

---

# 11. Suspense + API Patterns (Real Dev)

## Pattern 1: Page Suspense Boundary with Section Boundaries

Used in dashboards:

```
PageSkeleton
 ├── StatsSkeleton (loads separately)
 ├── UserSkeleton
 └── ProductsSkeleton
```

## Pattern 2: Suspense during navigation only

React Router lazy-loaded routes use Suspense for route-level data.

## Pattern 3: Suspense for expensive API operations

For example, loading analytics or reports.

## Pattern 4: Suspense for SSR + Streaming

Hydration and partial UI streaming use Suspense boundaries to send UI chunks progressively.

---

# 12. Anti-Patterns

1. Using Suspense without ErrorBoundary
   Suspense cannot catch errors.

2. Putting expensive queries inside a single Suspense boundary
   Slower queries block faster ones.

3. Using Suspense for tiny queries
   No user benefit.

4. Triggering Suspense repeatedly due to low staleTime
   Causes flickering.

5. Mixing Suspense and isLoading checks in same component
   Creates inconsistent behavior.

---

# 13. Full Production Example

```jsx
export default function DashboardPage() {
  return (
    <ErrorBoundary fallback={<DashboardError />}>

      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>

      <div className="grid">

        <Suspense fallback={<StatsSkeleton />}>
          <Stats />
        </Suspense>

        <Suspense fallback={<UsersSkeleton />}>
          <Users />
        </Suspense>

        <Suspense fallback={<ProductsSkeleton />}>
          <Products />
        </Suspense>

      </div>

    </ErrorBoundary>
  );
}
```

Inside each section:

```jsx
const { data } = useQuery({
  queryKey: ["stats"],
  queryFn: getStats,
  suspense: true,
  useErrorBoundary: true
});
```

Each section loads independently and error-isolated.

---

# 14. Follow-up Questions

1. Which queries in your app are suitable for Suspense-based loading?
2. Do your components currently mix loading UI and data UI? Would Suspense simplify them?
3. Should your page use one Suspense boundary or multiple section-level boundaries?
4. Which boundaries should also have ErrorBoundary around them?
5. What should your staleTime be to avoid unnecessary Suspense flicker?
6. Are some of your queries heavy enough to justify separate Suspense boundaries?
7. Should cached user profiles load instantly without fallback?
8. How would you structure retry logic using ErrorBoundary with Suspense?
9. Which component in your UI would benefit from clean synchronous-like data reads?
10. How would you architect a full dashboard with Suspense-based data loading?

---
