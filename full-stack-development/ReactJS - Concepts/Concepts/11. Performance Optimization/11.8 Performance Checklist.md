# 11.8 Performance Checklist

This is a **practical, ready-to-use checklist** used by real frontend engineers before deploying apps.

It ensures your React application:

* Renders efficiently
* Avoids unnecessary re-renders
* Uses optimal list rendering
* Uses correct component structure
* Minimizes DOM operations
* Avoids hidden performance traps

This checklist is the perfect summary of everything you learned.

We will go through this slowly and clearly.

---

# PERFORMANCE CHECKLIST

(Everything you must verify in your React app)

---

# SECTION 1: Rendering Logic Checklist

Questions you should always ask:

### 1. Is this re-render necessary?

If the UI does not change, the re-render is unnecessary.

### 2. Does this component rely on props/state?

If not, it should not re-render.

### 3. Can this logic be moved outside the component?

Move pure logic outside the component to reduce internal recalculations.

### 4. Are you updating state only when required?

Avoid needless state updates.

---

# SECTION 2: React.memo Checklist

Use **React.memo** when:

1. Child renders even when props do not change
2. Parent re-renders frequently
3. Child is a heavy UI component
4. Child renders large list items
5. You want to prevent deep UI recalculations
6. Child must not visually update unless props change

Do NOT use React.memo:

1. On every component blindly
2. If props change every render
3. If component is extremely small
4. For pure layout wrappers

---

# SECTION 3: useCallback Checklist

Use **useCallback** when:

1. Passing functions to memoized children
2. Function identity causes new renders
3. Function logic is stable
4. Child is heavy and must not re-render
5. Parent re-renders frequently

Do NOT use useCallback when:

1. The function is not passed as a prop
2. The child is not memoized
3. The function is trivial
4. It increases cognitive complexity unnecessarily

---

# SECTION 4: useMemo Checklist

Use **useMemo** when:

1. Creating objects or arrays inside render
2. Passing objects/arrays to memoized children
3. Running expensive calculations
4. Filtering large lists
5. Sorting large lists
6. Doing expensive computations based on props

Do NOT use useMemo when:

1. Value is cheap to compute
2. Value changes every render
3. It complicates the code without benefit

---

# SECTION 5: Keys Checklist

Correct keys:

1. Must be unique
2. Must be stable
3. Must represent item identity
4. Should not change on reorder

Avoid:

1. Using index as key
2. Using random numbers
3. Using array length
4. Using unstable identifiers

Correct keys improve reconciliation efficiency.

---

# SECTION 6: List Rendering Checklist

Before rendering long lists:

1. Is the list more than 200 items?
2. Does the user scroll?
3. Do items include images or heavy UI?
4. Is it a table or feed-like structure?

If yes â†’ use Virtualization (react-window, react-virtualized).

---

# SECTION 7: Component Architecture Checklist

Good architecture reduces re-renders.

Ask:

1. Is the component too large?

   * Split into smaller components.

2. Does parent hold too much state?

   * Move state down or use context/setter functions.

3. Are you lifting state too high?

   * Lift only when necessary.

4. Can part of UI be memoized?

   * Memo heavy children.

5. Is global context causing many re-renders?

   * Split into smaller contexts or use Zustand.

6. Does the component do heavy work inside render?

   * Use useMemo.

---

# SECTION 8: API Performance Checklist

For API-driven UIs:

1. Are you fetching data only when needed?
2. Are you caching data? (React Query)
3. Are you avoiding re-fetch on every render?
4. Are you using debouncing for search filters?
5. Are you using pagination for large data sets?
6. Are you preventing repeated API calls?

---

# SECTION 9: Browser Performance Checklist

Ask:

1. Are animations smooth?
2. Are large images optimized?
3. Are too many DOM nodes rendered?
4. Is the browser memory stable?
5. Does slow internet break UI?

---

# SECTION 10: Final Deployment Checklist

Before deploying:

1. Build with production mode (`npm run build`)
2. Check bundle size
3. Remove console logs
4. Remove unused imports
5. Verify tree shaking
6. Use code splitting for large modules
7. Lazy load non-essential components
8. Optimize images
9. Profile app on slow 3G mode

---

# FULL PERFORMANCE SUMMARY

* Preventing unnecessary re-renders
* Component memoization
* Stabilizing functions and values
* Key-based optimization
* Virtualization for large lists
* Rendering architecture best practices
* How React's internals affect performance

This completes the entire **React Performance Optimization Module**.

You now understand React performance on a level that many developers never reach.

---
