# 11.7 Virtualized Lists (Windowing)

This is used in:

* Chat apps
* E-commerce product lists
* Social media feeds
* Data tables
* Infinite scrolling
* Dashboards
* Logs viewer
* File explorers

If you ever render more than **200–300 items**, you MUST use list virtualization.
This is required skill in modern frontend development.

We will go step-by-step.

---

# 1. Why Rendering Large Lists is Slow

Rendering 100 items is fine.
Rendering 1,000 items is slow.
Rendering 10,000 items freezes the browser.

Why?

Because each item becomes:

* A DOM node
* An object in memory
* Part of reconciliation
* A layout/paint participant

Even if you do not see them on screen, the browser still has to process ALL of them.

React is fast.

But the DOM is not.

---

# 2. What is Windowing / Virtualization?

Windowing means:

> Instead of rendering the entire list, only render the items visible in the viewport.

The rest are not rendered until needed.

Example:

List of 10,000 items:

* Without virtualization: 10,000 DOM nodes
* With virtualization: about 15–20 visible DOM nodes

This reduces:

* DOM size
* Memory usage
* Render time
* Reconciliation work

Your app becomes significantly faster.

---

# 3. How Virtualization Works (Concept)

Imagine a window:

```
[ Visible Items Only ]
-----------------------
| item 1000           |
| item 1001           |
| item 1002           |
| item 1003           |
-----------------------
[Invisible items not mounted]
```

As you scroll:

* New items mount
* Old items unmount
* DOM stays extremely small

---

# 4. Popular Virtualization Libraries

The most used:

1. react-window (lightweight, simple, modern)
2. react-virtualized (older, powerful, heavy)

Today, react-window is preferred.

We will use it.

---

# 5. Install react-window

In your project:

```
npm install react-window
```

or

```
yarn add react-window
```

---

# 6. Basic Virtualized List Example (react-window)

Folder:

```
src/components/11.PerformanceOptimization/Virtualization
```

File:

`VirtualList_Basic.jsx`

```jsx
import { FixedSizeList as List } from "react-window";

export default function VirtualList_Basic() {
  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);

  return (
    <div>
      <h3>Virtualized List (10,000 items)</h3>

      <List
        height={300}
        width={300}
        itemSize={35}
        itemCount={items.length}
      >
        {({ index, style }) => (
          <div style={style}>
            {items[index]}
          </div>
        )}
      </List>
    </div>
  );
}
```

Result:

* It feels instant
* No lag
* Only about 10–15 items rendered at a time

Without virtualization, this would freeze the browser.

---

# 7. Advanced Example: Virtual List with Objects

`VirtualList_Objects.jsx`

```jsx
import { FixedSizeList as List } from "react-window";

export default function VirtualList_Objects() {
  const users = Array.from(
    { length: 5000 },
    (_, i) => ({ id: i + 1, name: "User " + (i + 1) })
  );

  return (
    <div>
      <h3>Virtualized User List</h3>

      <List
        height={400}
        width={400}
        itemSize={50}
        itemCount={users.length}
      >
        {({ index, style }) => (
          <div style={style}>
            {users[index].id} - {users[index].name}
          </div>
        )}
      </List>
    </div>
  );
}
```

Now even 5,000 items render instantly.

---

# 8. Why Virtualization is Required for Real Apps

Without virtualization:

* Long lists cause lag
* Scrolling becomes slow
* Mobile devices struggle
* Large tables freeze the UI
* Re-rendering becomes heavy
* Memory usage spikes

With virtualization:

* DOM small
* Fast scroll
* Smooth performance
* Low memory usage
* Battery friendly

This is industry-standard.

---

# 9. Combining Virtualization with Infinite Scroll

This is a common pattern:

* API returns 20 items
* User scrolls to bottom
* Fetch next 20
* Virtualized list renders them smoothly

You essentially build:

* Facebook feed
* Instagram feed
* Chat apps
* Logs viewer

We can create this later if you want.

---

# 10. Summary of Virtualization

Virtualization solves:

1. Slow rendering of large lists
2. High memory usage
3. DOM overload
4. Frozen scrolling
5. Useless DOM nodes

Using react-window:

* Only visible items are rendered
* Rendered list stays small
* Everything stays fast and smooth

This is mandatory knowledge for advanced React developers.

---

# Completion of Performance Optimization Module

You have now learned:

* React.memo
* useCallback
* useMemo
* Key optimization
* Avoiding unnecessary re-renders
* Virtualization

This completes the **core performance skillset**.

---
