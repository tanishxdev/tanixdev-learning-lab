# 12.4 SCHEMA-BASED VALIDATION (Using Yup)

This is used in almost every serious company project because:

* Validation rules become reusable
* Validation becomes centralized
* Code becomes clean
* Large forms are easy to manage
* Validation becomes predictable and consistent
* Integrates perfectly with React Hook Form

You cannot scale forms without schema-based validation.

We will go step-by-step.

---

# 1. What is Schema-based Validation?

A schema is a **blueprint** that defines:

* What fields exist
* What type they should be
* What rules they must follow
* How errors should be shown

Example schema:

```
name: string().required()
email: string().email().required()
password: string().min(8)
```

You define rules once.
Libraries validate input based on these rules automatically.

React itself does not include schema validation, so we use **Yup**, which is the industry standard.

---

# 2. Why Use Schema-based Validation?

Problems with manual validation:

* Code becomes long
* Hard to maintain
* Hard to change rules
* Hard to reuse
* Hard to validate large forms
* Repeated logic for different forms

Schema-based validation solves all of this.

### Benefits:

1. All validation rules in one place
2. Easy to update rules
3. Works with large forms (10–100 fields)
4. Standard in companies using React
5. Works perfectly with React Hook Form
6. Very clean code

---

# 3. Install Yup

Run:

```
npm install yup
```

or

```
yarn add yup
```

---

# 4. Creating a Simple Schema (Signup Example)

Create file:

`schemaSignup.js`

```jsx
import * as Yup from "yup";

export const signupSchema = Yup.object({
  name: Yup.string()
    .required("Name is required"),

  email: Yup.string()
    .email("Invalid email format")
    .required("Email is required"),

  password: Yup.string()
    .min(8, "Password must be at least 8 characters")
    .matches(/[A-Z]/, "Must contain one uppercase letter")
    .matches(/[0-9]/, "Must contain one number")
    .required("Password is required")
});
```

This schema defines:

* Types
* Min/max
* Email format
* Regex rules
* Error messages

And can be reused in multiple places.

---

# 5. Validate Form Data with Schema

Now let's manually validate a form (we will integrate with React Hook Form later).

Create file:

`Validation5_YupManual.jsx`

```jsx
import { useState } from "react";
import { signupSchema } from "./schemaSignup";

export default function Validation5_YupManual() {
  const [form, setForm] = useState({
    name: "",
    email: "",
    password: ""
  });

  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    setForm({
      ...form,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      await signupSchema.validate(form, { abortEarly: false });
      console.log("Valid data:", form);
      setErrors({});
    } catch (err) {
      const formatted = {};
      err.inner.forEach((item) => {
        formatted[item.path] = item.message;
      });
      setErrors(formatted);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <h3>Schema Validation (Yup)</h3>

      <input
        name="name"
        placeholder="Name"
        value={form.name}
        onChange={handleChange}
      />
      {errors.name && (
        <p style={{ color: "red" }}>{errors.name}</p>
      )}

      <input
        name="email"
        placeholder="Email"
        value={form.email}
        onChange={handleChange}
      />
      {errors.email && (
        <p style={{ color: "red" }}>{errors.email}</p>
      )}

      <input
        name="password"
        type="password"
        placeholder="Password"
        value={form.password}
        onChange={handleChange}
      />
      {errors.password && (
        <p style={{ color: "red" }}>{errors.password}</p>
      )}

      <button type="submit">Submit</button>
    </form>
  );
}
```

What this gives you:

* Centralized validation rules
* Automatically formatted error messages
* No manual error checks
* Scalable architecture

This is how modern forms are done in production.

---

# 6. Schema-based Validation Flow (Very Important)

1. User submits form
2. Form data goes into schema
3. Schema validates every field
4. Returns:

   * valid data
   * OR error messages
5. UI shows errors

This separates validation **logic** from **UI**, which is the best way.

---

# 7. Real Advantages You Get

### A) Change rules in one place

Change password length → all forms update.

### B) Validation is consistent

Signup + Login + Admin panel → same rules.

### C) Easy to test

Schemas can be tested using Jest.

### D) Works with React Hook Form

Yup + React Hook Form = enterprise-level forms.

We will build it soon.

---

# 8. Summary of Schema-Based Validation

Yup gives you:

* Clean validation
* Scalable logic
* Reusable rules
* Centralized schemas
* Detailed error messages
* Industry-standard approach

This is mandatory knowledge for real production work.

---
