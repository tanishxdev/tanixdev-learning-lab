# 12.3 REAL-TIME VALIDATION (Controlled Components)

Real-time validation means:

* User types
* React checks the value
* UI updates instantly with errors
* Button enables/disables automatically
* Invalid inputs are blocked

This is required in every real app:

* Login
* Signup
* Checkout
* OTP
* Profile update
* Payment forms

We will build multiple examples, progressing slowly.

---

# 1. Why Real-time Validation?

Benefits:

1. Prevents invalid form submission
2. Guides users while typing
3. Shows errors instantly
4. Improves conversion rate (important for companies)
5. Required for UX standards

React makes this easy with controlled components.

---

# 2. Simple Example: Required Field Validation

Create file:

`Validation1_Required.jsx`

```jsx
import { useState } from "react";

export default function Validation1_Required() {
  const [name, setName] = useState("");
  const isInvalid = name.trim() === "";

  return (
    <div>
      <h3>Required Field Validation</h3>

      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      />

      {isInvalid && <p style={{ color: "red" }}>Name is required</p>}

      <button disabled={isInvalid}>
        Submit
      </button>
    </div>
  );
}
```

Concept:

* If input empty â†’ show error
* Disable button until valid

This pattern is extremely common.

---

# 3. Email Validation (Regex Example)

File:

`Validation2_Email.jsx`

```jsx
import { useState } from "react";

export default function Validation2_Email() {
  const [email, setEmail] = useState("");

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  const isValid = emailRegex.test(email);

  return (
    <div>
      <h3>Email Validation</h3>

      <input
        type="email"
        value={email}
        placeholder="Enter email"
        onChange={(e) => setEmail(e.target.value)}
      />

      {!isValid && email.length > 0 && (
        <p style={{ color: "red" }}>Invalid Email</p>
      )}

      <button disabled={!isValid}>
        Submit
      </button>
    </div>
  );
}
```

Concept:

* User types email
* Regex checks it
* Error shown only when user typed something but incorrect

---

# 4. Password Validation (Length + Rules)

We now validate:

* At least 8 characters
* Contains one uppercase
* Contains one digit

File:

`Validation3_Password.jsx`

```jsx
import { useState } from "react";

export default function Validation3_Password() {
  const [password, setPassword] = useState("");

  const rules = {
    length: password.length >= 8,
    upper: /[A-Z]/.test(password),
    number: /[0-9]/.test(password)
  };

  const isValid = rules.length && rules.upper && rules.number;

  return (
    <div>
      <h3>Password Validation</h3>

      <input
        type="password"
        placeholder="Enter password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />

      <ul>
        <li style={{ color: rules.length ? "green" : "red" }}>
          At least 8 characters
        </li>

        <li style={{ color: rules.upper ? "green" : "red" }}>
          At least 1 uppercase letter
        </li>

        <li style={{ color: rules.number ? "green" : "red" }}>
          At least 1 number
        </li>
      </ul>

      <button disabled={!isValid}>Submit</button>
    </div>
  );
}
```

Now the user gets live feedback as they type.

---

# 5. Multi-field Validation (Signup Form)

File:

`Validation4_SignupForm.jsx`

```jsx
import { useState } from "react";

export default function Validation4_SignupForm() {
  const [form, setForm] = useState({
    name: "",
    email: "",
    password: ""
  });

  const handleChange = (e) => {
    setForm({
      ...form,
      [e.target.name]: e.target.value
    });
  };

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  const passOk = form.password.length >= 8;

  const isValid =
    form.name.trim() !== "" &&
    emailRegex.test(form.email) &&
    passOk;

  return (
    <form>
      <h3>Signup Form with Validation</h3>

      <input
        name="name"
        placeholder="Name"
        value={form.name}
        onChange={handleChange}
      />
      {form.name.trim() === "" && (
        <p style={{ color: "red" }}>Name required</p>
      )}

      <input
        name="email"
        placeholder="Email"
        value={form.email}
        onChange={handleChange}
      />
      {!emailRegex.test(form.email) && form.email.length > 0 && (
        <p style={{ color: "red" }}>Invalid email</p>
      )}

      <input
        name="password"
        type="password"
        placeholder="Password"
        value={form.password}
        onChange={handleChange}
      />
      {!passOk && form.password.length > 0 && (
        <p style={{ color: "red" }}>Min 8 characters</p>
      )}

      <button disabled={!isValid}>Create Account</button>
    </form>
  );
}
```

This is very close to real-world signup forms.

---

# 6. Important Rule: Validate on Change or on Blur?

React offers two patterns:

### A. OnChange (real-time)

Validate as the user types.
Good for:

* Email
* Password strength
* Name
* Username availability

### B. OnBlur (after leaving input)

Validate only when input loses focus.
Good for:

* Address
* Country
* Large text inputs
* Expensive validation

We will implement both patterns later.

---

# 7. Real-time Validation Summary

You learned how to:

* Validate required fields
* Validate email format
* Validate password strength
* Validate multiple fields
* Disable submit button until valid
* Provide immediate feedback

This is what most forms in real web apps need.

---
