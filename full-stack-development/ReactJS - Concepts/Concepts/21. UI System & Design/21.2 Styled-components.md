# **21.2 Styled-components**

A complete, production-grade explanation of **what Styled-components is**, why teams use it, how it compares to Tailwind and traditional CSS, how styling works at runtime, how themes, props, variants, and dynamic styles operate, and how to architect scalable UI systems using Styled-components in React.

This chapter focuses on real-world usage, performance considerations, and design patterns used in component-based architecture.

---

# 1. What Are Styled-components?

Styled-components is a **CSS-in-JS library** for React that lets you write actual CSS inside JavaScript files and bind styles directly to components.

Example:

```jsx
import styled from "styled-components";

const Button = styled.button`
  padding: 12px 16px;
  background: blue;
  color: white;
  border-radius: 6px;
`;
```

The output is a real DOM element with a unique generated class name, ensuring:

* isolated styles
* no name collisions
* predictable styling

Styled-components integrates CSS deeply with React's component model.

---

# 2. Why Use Styled-components?

### Reason 1: Styles scoped to components

You never worry about global CSS pollution.

### Reason 2: Dynamic styling based on props

Example:

```jsx
background: ${(p) => (p.primary ? "blue" : "gray")};
```

### Reason 3: Removes the need for BEM or naming conventions

No more:

```
.card__title--active
```

### Reason 4: Great for design systems

Design tokens and variants are easy to maintain.

### Reason 5: Theme support built-in

Dark mode, brand themes, etc.

### Reason 6: Works with server-side rendering (Next.js)

Styled-components is designed for modern component-driven apps.

---

# 3. How Styled-components Works Internally

1. You write CSS inside tagged template literals
2. Styled-components generates a unique class name
3. It injects CSS into the `<style>` tag dynamically
4. The component uses this class name
5. Props drive dynamic styles at runtime

Generated class example:

```
.sc-a1b2c3
```

This ensures styles never collide.

---

# 4. Basic Usage

Component:

```jsx
const Title = styled.h1`
  color: #333;
  font-size: 24px;
  font-weight: bold;
`;
```

Usage:

```jsx
<Title>Hello</Title>
```

This is a styled `<h1>` element.

---

# 5. Styling with Props (Critical Feature)

Component:

```jsx
const Button = styled.button`
  background: ${(p) => (p.primary ? "#2563eb" : "#9ca3af")};
  color: white;
  padding: 10px 16px;
  border-radius: 6px;
`;
```

Usage:

```jsx
<Button primary>Save</Button>
<Button>Cancel</Button>
```

This is the dynamic styling power of CSS-in-JS.

---

# 6. Conditional Variants (Reusable Pattern)

Define variants:

```jsx
const Badge = styled.span`
  padding: 4px 8px;
  border-radius: 4px;
  color: white;

  background: ${({ type }) =>
    type === "success"
      ? "#16a34a"
      : type === "warning"
      ? "#f59e0b"
      : "#ef4444"};
`;
```

Usage:

```jsx
<Badge type="success">Active</Badge>
<Badge type="warning">Pending</Badge>
<Badge type="error">Failed</Badge>
```

Variants eliminate repetitive code.

---

# 7. Extending Components

You can extend existing styled components:

```jsx
const PrimaryButton = styled(Button)`
  background: #2563eb;
`;
```

Useful for creating reusable design systems.

---

# 8. Global Styles

Styled-components supports global styles via `createGlobalStyle`.

Example:

```jsx
import { createGlobalStyle } from "styled-components";

const GlobalStyles = createGlobalStyle`
  body {
    margin: 0;
    background: #f5f5f5;
  }
`;
```

Usage:

```jsx
<GlobalStyles />
```

Good for CSS resets and global typography.

---

# 9. Theming with ThemeProvider

Theme file:

```jsx
export const theme = {
  colors: {
    primary: "#2563eb",
    danger: "#dc2626"
  },
  spacing: {
    sm: "8px",
    md: "16px"
  }
};
```

Wrap app:

```jsx
<ThemeProvider theme={theme}>
  <App />
</ThemeProvider>
```

Use in components:

```jsx
const Box = styled.div`
  padding: ${(p) => p.theme.spacing.md};
  background: ${(p) => p.theme.colors.primary};
`;
```

Themes are one of the biggest advantages of styled-components.

---

# 10. Animations with Styled-components

Example:

```jsx
import { keyframes } from "styled-components";

const fade = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const Modal = styled.div`
  animation: ${fade} 0.3s ease-in-out;
`;
```

Animations integrate naturally with components.

---

# 11. Nesting and Pseudo-classes

```jsx
const Card = styled.div`
  padding: 20px;
  border-radius: 8px;

  &:hover {
    background: #f3f4f6;
  }

  & > h1 {
    margin-bottom: 10px;
  }
`;
```

Nesting allows structured component styling.

---

# 12. Styled-components vs Tailwind CSS

| Feature        | Styled-components | Tailwind                      |
| -------------- | ----------------- | ----------------------------- |
| Style location | Inside JS         | Utility classes in JSX        |
| Dynamic styles | Excellent         | Limited (needs classnames)    |
| Themes         | Built-in          | Config-based                  |
| CSS complexity | Full CSS power    | Utility-first                 |
| Learning curve | Higher for CSS    | Lower (predefined utilities)  |
| Build size     | runtime overhead  | compile-time only             |
| Design systems | Very strong       | Requires component extraction |

Styled-components is ideal for:

* large design systems
* runtime dynamic styling
* complex themes
* apps with deep custom UI

Tailwind is ideal for:

* rapid prototyping
* atomic UI patterns

Both coexist depending on needs.

---

# 13. Performance Considerations

Styled-components adds:

* runtime parsing
* dynamic class generation
* style injection overhead

Solutions:

* Use Babel plugin for optimization
* Avoid rendering styled components inside loops
* Prefer theme tokens
* Extract heavy dynamic logic into functions

Styled-components is fast enough for most apps but requires awareness.

---

# 14. Testing Styled-components

Using Jest:

```jsx
import renderer from "react-test-renderer";

test("Button renders correctly", () => {
  const tree = renderer.create(<Button primary />).toJSON();
  expect(tree).toMatchSnapshot();
});
```

RTL also works:

```jsx
render(<Button primary />);
```

You can assert styles:

```jsx
expect(screen.getByRole("button")).toHaveStyle("background: #2563eb");
```

---

# 15. Best Practices for Large Projects

### 1. Create a design system folder

```
/design-system
  /Button.jsx
  /Input.jsx
  /Card.jsx
  /Theme.js
```

### 2. Use theme tokens, not raw values

Avoid:

```
color: red;
```

Prefer:

```
color: ${(p) => p.theme.colors.danger};
```

### 3. Limit dynamic props

Too many dynamic styles slow rendering.

### 4. Extract repeated styles using mixins

```jsx
const flexCenter = css`
  display: flex;
  justify-content: center;
  align-items: center;
`;
```

### 5. Use variants for consistent UI patterns

---

# 16. Full Production Example: Styled Button System

```jsx
const Button = styled.button`
  padding: 8px 16px;
  border-radius: 6px;
  font-weight: 500;
  color: white;

  background: ${(p) =>
    p.variant === "primary"
      ? p.theme.colors.primary
      : p.variant === "danger"
      ? p.theme.colors.danger
      : "#6b7280"};

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
```

Usage:

```jsx
<Button variant="primary">Save</Button>
<Button variant="danger">Delete</Button>
<Button disabled>Disabled</Button>
```

This is scalable and theme-driven.

---

# 17. Follow-up Questions

1. Will your project use Tailwind, Styled-components, or a hybrid approach?
2. Do you need runtime dynamic styling (if yes â†’ styled-components)?
3. Should your project include a theme system for colors, spacing, or typography?
4. Are your components reusable enough to justify variant patterns?
5. Do you need animation or keyframes integration?
6. Should global styles be migrated into styled-components?
7. Will your design system require component extension?
8. Do you need snapshot testing for styled UI?
9. Are you using too many dynamic props causing runtime overhead?
10. How will you organize your design-system folder?
