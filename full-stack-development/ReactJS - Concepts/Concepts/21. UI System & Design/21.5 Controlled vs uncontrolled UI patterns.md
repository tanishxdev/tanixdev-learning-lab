# **21.5 Controlled vs Uncontrolled UI Patterns**

A complete, production-grade explanation of **Controlled vs Uncontrolled Components in React**, why these two patterns exist, how they affect UI architecture, when to choose each, how form libraries use them, how design systems expose both patterns, and how to avoid common pitfalls.

This is a core React concept for building scalable UI and reusable components.

---

# 1. What Are Controlled and Uncontrolled Components?

React components that manage input values fall into two categories:

## Controlled Component

React controls the value.

```jsx
<input value={email} onChange={e => setEmail(e.target.value)} />
```

State lives in React.

## Uncontrolled Component

DOM controls the value.

```jsx
<input defaultValue="hello" ref={inputRef} />
```

State lives in DOM.

Both patterns are valid and used in production for different purposes.

---

# 2. Why Do These Patterns Exist?

The main difference:

```
Controlled → React manages state
Uncontrolled → Browser manages state
```

React is not always required for input management.

Uncontrolled makes some things easier:

* Performance
* Simple forms
* Non-reactive fields

Controlled makes other things easier:

* Validation
* Re-render-based UI
* Instant feedback
* Integration with global state

This chapter explains when to use which.

---

# 3. Controlled Components (Deep Understanding)

Controlled = **value changes only when React state updates**.

Example:

```jsx
function Form() {
  const [text, setText] = useState("");

  return (
    <input
      value={text}
      onChange={(e) => setText(e.target.value)}
    />
  );
}
```

Flow:

1. User types
2. `onChange` fires
3. React updates state
4. state updates `value`
5. input re-renders

This is how controlled components give you power.

---

# 4. Advantages of Controlled Components

1. **Full control of UI state**
   React always knows the latest value.

2. **Live validation**
   Example: show error as user types.

3. **Conditional rendering**
   Example: disable submit until valid.

4. **Sync with other components**
   Controlled = predictable state machine.

5. **Easier to test**
   Use user-event to type and assert value.

Controlled is perfect for:

* React forms
* Search inputs
* Controlled dropdowns
* Dynamic UI changes
* Data-bound inputs

---

# 5. Disadvantages of Controlled Components

1. Performance (frequent re-renders)
2. Verbose for simple forms
3. Heavy for large uncontrolled forms

Controlled becomes slow if misused inside:

* long tables
* large editable forms
* complex dashboards

---

# 6. Uncontrolled Components (Deep Understanding)

Uncontrolled components let **DOM manage the input**.

Example:

```jsx
function Form() {
  const inputRef = useRef();

  function submit() {
    console.log(inputRef.current.value);
  }

  return (
    <>
      <input ref={inputRef} defaultValue="hello" />
      <button onClick={submit}>Submit</button>
    </>
  );
}
```

Flow:

1. User types
2. DOM stores value
3. You read it only when needed

No React re-renders based on typing.

---

# 7. Advantages of Uncontrolled Components

1. Better performance (no rerenders)
2. Perfect for large/static forms
3. Ideal for file inputs
4. Works well with HTML forms
5. Reduces useState clutter

Most UI libraries internally use uncontrolled inputs for performance.

---

# 8. Disadvantages of Uncontrolled Components

1. No live validation
2. Hard to sync with other UI parts
3. Harder to test
4. Requires refs
5. More imperative code

Use uncontrolled only when React does **not** need the value continuously.

---

# 9. Real-World Example: Search Input

## Controlled Version (live search)

```jsx
const [q, setQ] = useState("");

<input value={q} onChange={(e) => setQ(e.target.value)} />;
```

Used for:

* search-as-you-type
* filtering lists
* dynamic UI updates

## Uncontrolled Version (submit-based search)

```jsx
const ref = useRef();

<input ref={ref} />;

<button onClick={() => doSearch(ref.current.value)}>Search</button>
```

Used for:

* search with button press
* server-side forms
* legacy UIs

---

# 10. React Hook Form vs Formik Example

### React Hook Form

Uses **uncontrolled** components for performance.

```jsx
<input {...register("email")} />
```

### Formik

Uses **controlled** components.

```jsx
<input value={values.email} onChange={handleChange} />
```

Knowing controlled vs uncontrolled explains why React Hook Form is faster.

---

# 11. When Building a Design System: Which Should You Support?

UI libraries often expose:

### Controlled API

Developer controls value externally.

```jsx
<Select value={value} onChange={setValue} />
```

### Uncontrolled API

Library manages internal state.

```jsx
<Select defaultValue="blue" />
```

A robust component supports **both**, like:

* Radix UI
* Headless UI
* Material UI

---

# 12. Hybrid Pattern (Best for Reusable Components)

A component can start uncontrolled and become controlled if value prop is provided.

Example:

```jsx
function Input({ value, defaultValue, onChange }) {
  const [internal, setInternal] = useState(defaultValue);

  const isControlled = value !== undefined;
  const finalValue = isControlled ? value : internal;

  function handle(e) {
    if (!isControlled) setInternal(e.target.value);
    onChange?.(e);
  }

  return (
    <input
      value={finalValue}
      onChange={handle}
    />
  );
}
```

Allows both:

```jsx
<Input defaultValue="hello" />    // uncontrolled
<Input value={state} />          // controlled
```

This is how **professional UI libraries** are built.

---

# 13. Example: Controlled Toggle Component

```jsx
function Toggle({ on, onChange }) {
  return (
    <button onClick={() => onChange(!on)}>
      {on ? "On" : "Off"}
    </button>
  );
}
```

Used when parent wants full control.

---

# 14. Example: Uncontrolled Toggle

```jsx
function ToggleUncontrolled({ defaultOn = false }) {
  const [on, setOn] = useState(defaultOn);

  return (
    <button onClick={() => setOn(!on)}>
      {on ? "On" : "Off"}
    </button>
  );
}
```

Used when state does not matter to parent.

---

# 15. Common Anti-Patterns

Avoid:

### 1. Mixing both patterns unintentionally

Component must detect controlled vs uncontrolled mode.

### 2. Controlled component without onChange

This freezes the input.

### 3. Uncontrolled component with value

React warns because value overrides DOM.

### 4. Using React state for huge forms

Kills performance.

### 5. Using uncontrolled where validation is required

Bad UX.

---

# 16. When to Use Which (Decision Framework)

| Scenario             | Use Controlled | Use Uncontrolled |
| -------------------- | -------------- | ---------------- |
| Live validation      | Yes            | No               |
| Dynamic UI updates   | Yes            | No               |
| Large forms          | No             | Yes              |
| Performance critical | No             | Yes              |
| File inputs          | No             | Yes              |
| Reusable components  | Both           | Both             |
| React Hook Form      | No             | Yes              |

Controlled = correctness
Uncontrolled = performance

---

# 17. Full Production Example: Controlled Input With Validation

```jsx
function EmailInput() {
  const [email, setEmail] = useState("");
  const error = !email.includes("@");

  return (
    <>
      <input
        value={email}
        onChange={e => setEmail(e.target.value)}
      />
      {error && <p>Invalid email</p>}
    </>
  );
}
```

---

# 18. Full Production Example: Uncontrolled File Upload

```jsx
function Upload() {
  const ref = useRef();

  function submit() {
    const file = ref.current.files[0];
    console.log(file);
  }

  return (
    <>
      <input type="file" ref={ref} />
      <button onClick={submit}>Upload</button>
    </>
  );
}
```

Uncontrolled is ideal here.

---

# 19. Follow-up Questions

1. Which components in your app depend on controlled state unnecessarily?
2. Do any large forms need refactoring to uncontrolled for performance?
3. Are you building reusable inputs that should support both patterns?
4. Should your design system implement hybrid controlled/uncontrolled logic?
5. Do you need live validation or just submit-time validation?
6. Do you know which pattern your form library uses?
7. Are you facing performance issues due to controlled inputs?
8. Have you mistakenly mixed controlled and uncontrolled props?
9. Do you require immediate UI updates based on input?
10. Should file inputs stay fully uncontrolled to avoid React complexity?
