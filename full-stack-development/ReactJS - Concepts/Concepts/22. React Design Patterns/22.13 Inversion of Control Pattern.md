# **22.13 Inversion of Control (IoC) Pattern**

A complete, production-grade explanation of **what the Inversion of Control Pattern is in React**, why it matters, how it increases flexibility, how it’s used inside modern UI libraries (React Aria, Downshift, Radix), and how to implement it to give consumers full control over your component’s behavior and rendering.

This pattern is the foundation for headless, flexible, customizable React components.

---

# 1. What Is Inversion of Control in React?

Inversion of Control means:

### **The component does NOT decide how something should happen.

The consumer decides.**

Instead of:

```
Component → controls behavior, rendering, state transitions
```

IoC flips it:

```
Consumer → controls behavior or rendering
Component → only provides data, events, or helpers
```

IoC moves control **out of the component** and into the user’s hands.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Components become too opinionated

They enforce:

* how to render
* how to style
* how to handle events
* how to manage state

This makes them **hard to reuse**.

### Problem 2: Users need customization

Examples:

* different workflows
* different validation
* different UI
* different animations
* different event logic

IoC allows users to override or replace almost any behavior.

### Problem 3: Forms, dropdowns, modals, tabs need complete flexibility

Headless UI solves this using IoC.

### Problem 4: Hooks created enormous opportunity for IoC

Hooks let components expose their logic externally.

---

# 3. How IoC Works in React (Core Idea)

A component exposes **only logic**, and the user supplies **all UI and behavior**.

Simple flow:

```
Component runs internal logic → exposes functions/state → consumer controls final UI and state changes
```

This enables:

* custom rendering
* custom event handling
* custom layout
* custom transitions
* custom animations

---

# 4. The Three Main IoC Forms in React

## 1. **Render Props Pattern**

Component gives control of UI to the consumer.

```jsx
<Counter>
  {({ count, inc }) => (
    <button onClick={inc}>{count}</button>
  )}
</Counter>
```

UI is not inside the component anymore → user decides.

---

## 2. **State Reducer Pattern**

Component gives control of *state transitions* to the user.

```jsx
stateReducer(prevState, proposedChanges) → finalState
```

The internal logic is no longer controlling state.

---

## 3. **Custom Hooks Pattern**

Pure logic is extracted into hooks.

Component becomes:

```jsx
const { count, inc } = useCounter();
return <CustomUI count={count} onInc={inc} />;
```

User controls UI and behavior.

---

IoC is when **logic is provided** but **control is externalized**.

---

# 5. Basic Example of IoC: Controlled Rendering

Component:

```jsx
function Toggle({ children }) {
  const [on, setOn] = useState(false);
  const toggle = () => setOn((v) => !v);

  return children({
    on,
    toggle
  });
}
```

Consumer:

```jsx
<Toggle>
  {({ on, toggle }) => (
    <button onClick={toggle}>{on ? "On" : "Off"}</button>
  )}
</Toggle>
```

The consumer completely controls the UI.

This is inversion of control.

---

# 6. IoC Example: Modal Logic Without UI

### Hook (logic only)

```jsx
function useModal() {
  const [open, setOpen] = useState(false);
  return {
    open,
    openModal: () => setOpen(true),
    closeModal: () => setOpen(false)
  };
}
```

### Consumer controls UI

```jsx
const modal = useModal();

return (
  <>
    <button onClick={modal.openModal}>Open</button>

    {modal.open && (
      <div className="overlay">
        <div className="modal">
          <button onClick={modal.closeModal}>Close</button>
          <p>Hello</p>
        </div>
      </div>
    )}
  </>
);
```

The hook provides behavior.
The consumer builds UI.

This is the purest form of IoC.

---

# 7. IoC Example: Dropdown Component with Render Props

### Component provides logic

```jsx
function Dropdown({ children }) {
  const [open, setOpen] = useState(false);

  return children({
    open,
    toggle: () => setOpen((v) => !v)
  });
}
```

### User controls rendering

```jsx
<Dropdown>
  {({ open, toggle }) => (
    <div>
      <button onClick={toggle}>Menu</button>
      {open && <div className="menu">Items</div>}
    </div>
  )}
</Dropdown>
```

This is why headless UI systems are extremely flexible.

---

# 8. IoC Example: Autocomplete with State Reducer

```jsx
function useAutocomplete({ stateReducer }) {
  const [state, setState] = useState({ open: false });

  function change(changes) {
    setState((prev) => {
      const next = { ...prev, ...changes };
      return stateReducer ? stateReducer(prev, next) : next;
    });
  }

  return {
    open: state.open,
    toggle: () => change({ open: !state.open })
  };
}
```

User overrides logic:

```jsx
const autocomplete = useAutocomplete({
  stateReducer: (state, next) => {
    if (next.open === false) return state; // prevent closing
    return next;
  }
});
```

Internal logic is not the authority anymore.

---

# 9. Why IoC Makes Components More Reusable

IoC lets consumers:

* build custom UI
* reject certain transitions
* override event handlers
* define custom logic
* control rendering
* replace animations
* change layout

Your component becomes a **logic engine**, not a rigid UI.

This is how design systems achieve ultimate flexibility.

---

# 10. IoC in Real Libraries

### Radix UI

All components are headless — user controls styling.

### Downshift

Autocomplete library powered by state reducer + render props.

### React Aria

Hooks expose behavior; user builds UI using them.

### React Hook Form

IoC for form registration and validation logic.

### Headless UI

Logic provided, UI controlled by developer.

Every modern UI library uses IoC to maximize flexibility.

---

# 11. Best Practices for IoC

### 1. Expose logic via hooks

e.g., `useDropdown`, `useModal`, `useTabs`

### 2. Use render props when consumers need UI control

Especially in deeply dynamic UIs.

### 3. Allow overriding logic using stateReducer

Critical for advanced control.

### 4. Keep internal logic pure

UI must not leak into hooks.

### 5. Provide event types when exposing state changes

Better debugging + user control.

---

# 12. Anti-Patterns

Avoid:

### 1. Components that do everything

Monolithic UI + logic components violate IoC.

### 2. Hiding internal decisions

Users must be able to override behavior.

### 3. Returning unstable handlers

Use `useCallback` when appropriate.

### 4. Breaking encapsulation

Exposing too much internal detail defeats the purpose.

### 5. IoC overuse

Not all components require full external control.

Balance is key.

---

# 13. When Should You Use IoC?

Use when:

* building headless components
* building design systems
* exposing customizable UI logic
* creating reusable widgets (dropdowns, tabs, modals)
* consumers need to override state transitions
* UI should vary but logic should remain stable

Avoid when:

* UI is fixed and simple
* consumer benefits from simplicity over flexibility

IoC is a powerful but advanced pattern.

---

# 14. Follow-up Questions

1. Should your app use IoC for modals, dropdowns, tabs, or navigation?
2. Do you want to create headless components using IoC?
3. Should your hooks expose event types for stateReducer overrides?
4. Do you prefer render props or hooks for IoC?
5. Should IoC be used for forms in your system?
6. Do you want TypeScript versions of IoC implementations?
7. Should IoC be combined with Compound Components in your design system?
8. Do you want a headless dropdown example built from scratch?
9. Should your IoC components expose context or return objects?
10. Should IoC be integrated with React Query or Zustand?
