# **22.5 Props Getter Pattern**

A complete, production-grade explanation of **what the Props Getter pattern is**, why it exists, how it improves flexibility in reusable components, how modern headless UI libraries use it, and how to implement it in real applications.

This pattern is heavily used in libraries like Downshift, Radix UI, Headless UI, React Aria.

---

# 1. What Is the Props Getter Pattern?

A **Props Getter** is a function that returns a set of props that users can spread onto their UI elements.

Example:

```jsx
const { getToggleProps } = useToggle();
<button {...getToggleProps()} />
```

Instead of passing props manually, the internal logic generates props dynamically and exposes them through getter functions.

The user has full control over the UI.

---

# 2. Why Does This Pattern Exist?

The Props Getter pattern solves three major problems:

### Problem 1: Reusable components need user-defined UI

Reusable logic should not dictate HTML structure.

### Problem 2: Users need to override props or add their own

Direct props can conflict or override internal behavior.

### Problem 3: Behavior should merge safely with user props

Click handlers, refs, aria attributes must combine correctly.

Props Getter delivers:

```
One place where logic computes the necessary props  
User spreads them onto their DOM element  
```

This preserves full flexibility.

---

# 3. How the Pattern Works (Architecture Overview)

A hook returns functions like:

* `getButtonProps()`
* `getInputProps()`
* `getItemProps()`
* `getToggleProps()`

These functions return attributes such as:

* `onClick`
* `aria-*`
* merged event handlers
* internal state
* refs

Users then spread them onto their elements:

```jsx
<button {...getButtonProps({ className: "btn-primary" })}>
  Toggle
</button>
```

Internal logic + user-provided props = cleanly merged.

---

# 4. Basic Example: Toggle Behavior

### Logic Hook with Props Getter

```jsx
function useToggle() {
  const [on, setOn] = useState(false);

  function toggle() {
    setOn((v) => !v);
  }

  function getToggleProps(userProps = {}) {
    return {
      onClick: (e) => {
        userProps.onClick?.(e);
        toggle();
      },
      "aria-pressed": on,
      ...userProps
    };
  }

  return { on, getToggleProps };
}
```

### Usage

```jsx
const { on, getToggleProps } = useToggle();

<button {...getToggleProps({ className: "btn" })}>
  {on ? "On" : "Off"}
</button>
```

User has full UI control.

---

# 5. Why This Pattern Is Powerful

1. **Complete UI freedom**
   Logic does not impose DOM structure.

2. **Safe merging of event handlers**
   Both internal and user events are executed.

3. **Predictable API**
   Users simply call getter functions.

4. **No wrapper components**
   Zero extra rendering layers.

5. **Perfect for headless UI**
   Pattern used in Radix, Downshift, React Aria.

Example:

```
Logic stays inside hook  
UI stays outside completely  
```

---

# 6. Real-World Example: Dropdown Menu (Headless)

### Logic Hook

```jsx
function useDropdown() {
  const [open, setOpen] = useState(false);

  function getButtonProps(userProps = {}) {
    return {
      onClick: (e) => {
        userProps.onClick?.(e);
        setOpen((v) => !v);
      },
      "aria-expanded": open,
      ...userProps
    };
  }

  function getItemProps(userProps = {}) {
    return {
      role: "menuitem",
      tabIndex: 0,
      ...userProps
    };
  }

  return { open, getButtonProps, getItemProps };
}
```

### UI

```jsx
const { open, getButtonProps, getItemProps } = useDropdown();

<button {...getButtonProps({ className: "btn" })}>
  Menu
</button>

{open && (
  <ul>
    <li {...getItemProps()}>Profile</li>
    <li {...getItemProps()}>Logout</li>
  </ul>
)}
```

Full control, no imposed structure.

---

# 7. Props Getter Pattern vs Render Props vs HOCs

| Feature        | Props Getter | Render Props       | HOC                 |
| -------------- | ------------ | ------------------ | ------------------- |
| UI freedom     | Highest      | High               | Medium              |
| Extra elements | None         | Sometimes          | Yes                 |
| Complexity     | Medium       | High               | Medium              |
| Modern usage   | Very common  | Rare               | Limited             |
| Best for       | Headless UI  | Behavior injection | Cross-cutting logic |

Props Getter is the **modern solution** for headless components.

---

# 8. Merging Event Handlers (Core Problem Solved)

Props Getter ensures both user and internal handlers run:

```jsx
onClick: (e) => {
  userProps.onClick?.(e);
  toggle();
}
```

That solves:

* accidental overrides
* handler conflicts
* conditional execution

This is why UI libraries prefer this pattern.

---

# 9. Accessibility Integration

Props getters can automatically apply:

* ARIA attributes
* keyboard handlers
* screen-reader text
* role attributes

Example:

```jsx
getInputProps() {
  return {
    role: "combobox",
    "aria-expanded": open,
    "aria-controls": "listbox"
  };
}
```

This centralizes accessibility rules.

---

# 10. Anti-Patterns

Avoid:

### 1. Returning large objects in getters

Heavy recalculations on each render.

### 2. Creating getters inside JSX

Leads to new references â†’ unnecessary re-renders.

### 3. Logic inside UI components

Breaks headless design.

### 4. Mixing behavior and layout

Getter pattern expects clean separation.

### 5. Not allowing user override

Getter should accept user props.

---

# 11. When Should You Use This Pattern?

Use Props Getter when:

* building a headless component library
* creating inputs or dropdowns with custom UI
* needing accessible UI without forcing design
* building composable layouts
* needing safe merges of handlers
* designing flexible UI APIs for teams

Avoid it when:

* UI is fixed and never overridden
* component is tiny
* custom hook alone solves the problem

---

# 12. Follow-up Questions

1. Do you plan to build headless components in your app or design system?
2. Should your custom hooks start exposing props getters?
3. Do you need accessibility attributes automatically applied?
4. Should we create props getters for forms, modals, or dropdowns next?
5. Would your UI benefit from separating logic from layout?
6. Do you want the getter pattern combined with compound components later?
7. Should we build a reusable toggle, dropdown, or tabs with props getters?
8. Should getters internally use useCallback for stable references?
9. Are there event merging conflicts in your current components?
10. Do you want a comparison of custom hooks vs props getter vs compound components?

---