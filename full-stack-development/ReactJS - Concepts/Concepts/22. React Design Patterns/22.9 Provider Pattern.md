# **22.9 Provider Pattern**

A complete, production-grade explanation of **what the Provider Pattern is**, why it exists, how it centralizes shared state and logic, how it solves prop-drilling, and how modern React apps use it to build scalable architectures and design systems.

This pattern powers React Context, theming systems, authentication layers, feature flags, and global configuration.

---

# 1. What Is the Provider Pattern?

A Provider is a component that:

1. Holds shared state or shared behavior
2. Exposes it to any descendant components using Context
3. Allows consumers to read/update that state without prop drilling

Pattern structure:

```
<Provider>
   <Child />
</Provider>
```

Inside Provider:

* logic
* state
* shared resources
* configuration

Children consume values through `useContext`.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Prop drilling

Passing props through many levels:

```
<App → Page → Layout → Component → Button>
```

Hard to maintain.

### Problem 2: Multiple components need the same shared state

Examples:

* theme (dark/light)
* authentication info
* user preferences
* react-query clients
* global modals
* notification systems

### Problem 3: Need a global source of truth

Provider allows a **central store** with predictable access.

### Problem 4: Composable architecture

Complex apps need layers:

* AuthProvider
* ThemeProvider
* SettingsProvider
* QueryClientProvider
* FeatureFlagProvider

All are based on Provider Pattern.

---

# 3. How the Pattern Works (Architecture Overview)

1. Create a context
2. Create a provider component that stores logic
3. Wrap your app or component subtree with it
4. Use a hook (`useContext`) to consume its values

Example flow:

```
Provider → stores value
Consumer → reads value
```

---

# 4. Minimal Example

### Step 1: Create context

```jsx
const ThemeContext = createContext();
```

### Step 2: Create provider

```jsx
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  const value = { theme, setTheme };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### Step 3: Consume

```jsx
function Button() {
  const { theme } = useContext(ThemeContext);
  return <button className={theme}>Click</button>;
}
```

### Step 4: Wrap tree

```jsx
<ThemeProvider>
  <App />
</ThemeProvider>
```

Now the entire subtree has access.

---

# 5. Provider Pattern in Modern React Apps

Providers are used to define **application layers**.

Example real app structure:

```jsx
<QueryClientProvider>
  <AuthProvider>
    <ThemeProvider>
      <FeatureFlagProvider>
        <App />
      </FeatureFlagProvider>
    </ThemeProvider>
  </AuthProvider>
</QueryClientProvider>
```

This matches architectures used by platforms like:

* Stripe
* Shopify
* Product Hunt
* Slack
* Notion

Providers establish controlled global environments.

---

# 6. Provider Pattern with Custom Hook (Modern Way)

Encapsulate context usage into a custom hook:

### Create provider

```jsx
const UserContext = createContext();

export function UserProvider({ children }) {
  const [user, setUser] = useState(null);

  const value = { user, setUser };
  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
}
```

### Create custom hook for consumers

```jsx
export function useUser() {
  return useContext(UserContext);
}
```

### Usage

```jsx
function Profile() {
  const { user } = useUser();
  return <h1>{user?.name}</h1>;
}
```

Better DX, more maintainable.

---

# 7. Provider Pattern + React Query (Real Case)

React Query client is provided once:

```jsx
const queryClient = new QueryClient();

<QueryClientProvider client={queryClient}>
  <App />
</QueryClientProvider>
```

All descendants:

```jsx
useQuery(...)
```

work without configuration.

This is classic Provider Pattern.

---

# 8. Provider Pattern + Zustand (Optional Store Provider)

Zustand store can also be injected via a Provider (optional):

```jsx
const StoreContext = createContext();

export function StoreProvider({ children }) {
  return (
    <StoreContext.Provider value={useStore()}>
      {children}
    </StoreContext.Provider>
  );
}

export function useStoreContext() {
  return useContext(StoreContext);
}
```

Powerful for integrating multiple stores.

---

# 9. Advanced Provider Pattern: Nested Providers

Large apps combine multiple providers for modularity.

Example:

```jsx
<AuthProvider>
  <PermissionsProvider>
    <CartProvider>
      <ThemeProvider>
        <App />
      </ThemeProvider>
    </CartProvider>
  </PermissionsProvider>
</AuthProvider>
```

Each provider is responsible for exactly one domain.

---

# 10. Provider Pattern + Compound Components

Compound components often read state from a Provider.

Example Tabs:

```jsx
<Tabs value={index} onChange={setIndex}>
  <Tabs.List>...</Tabs.List>
  <Tabs.Panel>...</Tabs.Panel>
</Tabs>
```

Internally:

```jsx
const TabsContext = createContext();
```

All children consume context automatically.

This is the backbone of headless UI.

---

# 11. Anti-Patterns

Avoid:

### 1. Putting unrelated logic in the same provider

Breaks single-responsibility.

### 2. Deep provider nesting (“provider hell”)

Too many providers reduce readability.

### 3. Storing large objects in context

Causes unnecessary re-renders.

### 4. Passing unstable values without memoization

Use `useMemo` for stable provider values.

### 5. Creating provider per component unnecessarily

Providers should represent domains, not small units.

---

# 12. When Should You Use the Provider Pattern?

Use it when:

* many components need shared state
* you want a clean architecture with layers
* logic belongs at the app level (auth, theme, settings)
* you want config to be globally available
* you are building a design system
* compound components need shared state

Avoid when:

* only a parent-child pair needs the state
* data is local to a component
* Zustand or Jotai already provides simpler state

Providers are perfect for **domain-level shared logic**.

---

# 13. Follow-up Questions

1. Which domains in your project need Providers (auth, theme, settings, flags)?
2. Do you want to replace prop drilling in any current feature?
3. Should your Providers expose hooks for better DX?
4. Do you want a global provider architecture diagram?
5. Should Providers use memoized values for performance?
6. Should Providers be colocated inside feature folders?
7. Should we implement a multi-provider wrapper utility for cleaner code?
8. Do your compound components require internal Providers?
9. Should Providers use Zustand instead of useState?
10. Should I show a real example of Provider + State Reducer?
