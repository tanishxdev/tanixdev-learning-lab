# **22.1 Container–Presenter Pattern**

A complete explanation of **what this pattern is**, why it matters in real React applications, how it solves UI–logic coupling, how to implement it in modern React (with hooks, React Query, Zustand), and how teams use it in scalable frontend architecture.

This chapter is the foundation for all other React patterns.

---

# 1. What Is the Container–Presenter Pattern?

It is a design pattern that separates a component into two parts:

### 1. **Container Component** (Logic Layer)

Handles:

* data fetching
* state management
* side effects
* mutations
* event handlers
* business rules

### 2. **Presenter Component** (UI Layer)

Handles:

* layout
* markup
* styling
* displaying props
* simple UI state (like toggles)

The pattern creates a clean boundary:

```
Container → Logic
Presenter → UI
```

This is essential in large codebases.

---

# 2. Why Do We Need This Pattern?

### Problem 1: Mixed UI + Logic = Messy Component

Beginners commonly write components like:

```jsx
function UserCard() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch("/api/user/1")
      .then(res => res.json())
      .then(setUser);
  }, []);

  return (
    <div>
      <h1>{user?.name}</h1>
    </div>
  );
}
```

This component:

* fetches data
* stores state
* displays UI

Everything is mixed.
Scaling this becomes painful.

---

### Problem 2: UI becomes impossible to reuse

If you change API logic, UI breaks.

### Problem 3: Logic duplication

You rewrite the same fetching logic in many components.

### Problem 4: Hard to test

You must mock network + UI in one test.

### Problem 5: Redesigning UI becomes expensive

Business logic is tangled inside UI.

The container–presenter pattern solves all these problems cleanly.

---

# 3. How the Pattern Works (Architecture Overview)

The component is split into two files:

```
UserCardContainer.jsx → handles fetching, state
UserCardUI.jsx         → renders the UI using props
```

Flow:

1. Container fetches data
2. Container transforms or prepares data
3. Container passes data as props to Presenter
4. Presenter renders UI
5. Presenter remains reusable

It becomes extremely clean:

```
Container = “What to show”
Presenter = “How to show”
```

---

# 4. Basic Example (Modern React)

## Presenter — Pure UI

```jsx
export function UserCardUI({ user }) {
  return (
    <div className="card">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

No state
No effects
No fetching
No business logic

## Container — Logic Only

```jsx
export function UserCardContainer() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch("/api/user/1")
      .then(res => res.json())
      .then(setUser);
  }, []);

  if (!user) return <p>Loading...</p>;

  return <UserCardUI user={user} />;
}
```

Now the component is maintainable.

---

# 5. Pattern with React Query (Real World)

## Container (clean, testable)

```jsx
export function ProductCardContainer({ id }) {
  const { data, isLoading } = useQuery({
    queryKey: ["product", id],
    queryFn: () => api.get(`/products/${id}`).then(r => r.data)
  });

  if (isLoading) return <ProductSkeleton />;

  return <ProductCardUI product={data} />;
}
```

## Presenter (design-friendly)

```jsx
export function ProductCardUI({ product }) {
  return (
    <div className="shadow p-4">
      <h1>{product.title}</h1>
      <p>${product.price}</p>
    </div>
  );
}
```

Benefits:

* backend change does not affect UI
* UI redesign does not affect logic
* business rule changes do not affect UI

---

# 6. Pattern with Custom Hooks (Preferred Modern Approach)

Most modern codebases implement this pattern using hooks:

### Logic → custom hook

```jsx
export function useUser(id) {
  return useQuery({
    queryKey: ["user", id],
    queryFn: () => api.get(`/user/${id}`).then(r => r.data)
  });
}
```

### Container

```jsx
export function UserCardContainer({ id }) {
  const { data, isLoading } = useUser(id);
  if (isLoading) return <Loading />;
  return <UserCardUI user={data} />;
}
```

### Presenter

```jsx
export function UserCardUI({ user }) {
  return (
    <section className="profile">
      <h2>{user.name}</h2>
    </section>
  );
}
```

Logic is centralized
UI is reusable
Containers become very thin

---

# 7. When Should You Use This Pattern?

Use Container–Presenter when:

* building reusable UI
* pages have complex data requirements
* redesigns happen frequently
* logic is shared across components
* API layer may change
* you want components that are easy to test
* working in a large team

Avoid using it when:

* component is small
* logic is trivial
* UI is tightly bound to one screen

Pattern should be used intentionally, not everywhere.

---

# 8. Anti-Patterns

Avoid these mistakes:

### 1. Presenter calling APIs

Presenter should never fetch.

### 2. Presenter having complex logic

UI components must be shallow.

### 3. Container rendering complex layout

Container should return simple JSX and pass data to presenter.

### 4. Container mutating UI state

UI state belongs to Presenter.

### 5. Presenter reading from Context/Redux

This violates the separation.

---

# 9. Example of a Bad Component (Anti-pattern)

```jsx
function DashboardCard() {
  const { data } = useQuery(...);
  const [expanded, setExpanded] = useState(false);

  return (
    <div onClick={() => setExpanded(!expanded)}>
      <h1>{data.name}</h1>
      {expanded && <p>{data.details}</p>}
    </div>
  );
}
```

Everything is mixed.
Impossible to reuse.

---

# 10. Good Refactor Using Container–Presenter

### Presenter

```jsx
export function DashboardCardUI({ title, details, expanded, onToggle }) {
  return (
    <div onClick={onToggle}>
      <h1>{title}</h1>
      {expanded && <p>{details}</p>}
    </div>
  );
}
```

### Container

```jsx
export function DashboardCardContainer({ id }) {
  const { data } = useQuery(...);
  const [expanded, setExpanded] = useState(false);

  return (
    <DashboardCardUI
      title={data.name}
      details={data.details}
      expanded={expanded}
      onToggle={() => setExpanded((v) => !v)}
    />
  );
}
```

Perfect separation.

---

# 11. How Big Companies Use This Pattern

This pattern is used in:

* Stripe Dashboard
* Shopify Admin
* Airbnb Frontend
* Netflix internal panels
* Slack UI system
* GitHub frontend

They use it because:

* designers can focus on UI
* devs can change logic safely
* performance is easier to optimize
* testing layers are separated

---

# 12. Folder Structure for This Pattern

A scalable structure:

```
UserCard/
  UserCardContainer.jsx
  UserCardUI.jsx
  useUserCard.js
```

Or at scale:

```
features/
  user/
    components/
      UserCardUI.jsx
    containers/
      UserCardContainer.jsx
    hooks/
      useUser.js
      useUserCard.js
```

Clean, modular, team-friendly.

---

# 13. Follow-up Questions

1. Which components in your project currently mix UI and logic?
2. Should you move business logic into custom hooks or containers?
3. Does your team need a strict boundary between UI and logic?
4. Do you plan to redesign UI often?
5. Should presenters live inside your design system folder?
6. Should containers live at page-level or feature-level?
7. Do you want examples for forms, tables, or modals?
8. Do you want to integrate Zustand/React Query with this pattern?
9. Should presenters be pure components (no hooks)?
10. Should presenters support composition (Card.Header, Card.Body)?
