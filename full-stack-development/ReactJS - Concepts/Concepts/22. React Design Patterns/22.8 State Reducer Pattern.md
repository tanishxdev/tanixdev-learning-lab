# **22.8 State Reducer Pattern**

A complete, production-grade explanation of **what the State Reducer Pattern is**, why it exists, how it enables maximum flexibility in reusable components, how major headless libraries use it, and how to implement it using modern React (hooks + reducers).

This pattern is heavily used in libraries like Downshift, React Aria, and advanced form components.

---

# 1. What Is the State Reducer Pattern?

A **State Reducer Pattern** allows the *consumer* (the user of your component) to **override or modify** the internal state transitions of your component.

Instead of your component deciding:

```
currentState → nextState
```

You expose a state reducer that lets the user modify or replace this transition:

```
stateReducer(currentState, changes) → finalState
```

This gives users full control over how your component behaves.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Reusable components must be flexible

Users of your component might want to:

* disable part of the behavior
* override a specific state transition
* alter how toggle, selection, or open/close works

The normal internal state logic is too rigid.

### Problem 2: Hooks and context alone cannot override internal state logic

React hooks allow sharing logic but **do not allow users to override internal decisions**.

### Problem 3: UI libraries need fully customizable behavior

Examples:

* autocomplete suggestions
* dropdown open/close rules
* value selection in menus
* keyboard navigation logic
* form validation rules

The State Reducer Pattern provides a clean extension API.

---

# 3. How the Pattern Works

Your component:

1. Computes what it *thinks* the next state should be
2. Passes `currentState` and the desired `changes` to the user's `stateReducer`
3. The reducer returns the *actual* nextState
4. Component applies the returned state

Flow:

```
Component logic → proposes state changes → stateReducer → final state applied
```

The consumer becomes the final authority.

---

# 4. Basic Example: Toggle Component with State Reducer

### Custom Hook

```jsx
function useToggle({ initialOn = false, stateReducer } = {}) {
  const [state, setState] = useState(initialOn);
  const on = state;

  function internalSetState(changes) {
    setState((prevState) => {
      const nextState =
        typeof changes === "function" ? changes(prevState) : { on: changes.on };

      return stateReducer
        ? stateReducer(prevState, nextState)
        : nextState.on;
    });
  }

  function toggle() {
    internalSetState({ on: !on });
  }

  return { on, toggle };
}
```

### Consumer Usage (Override Logic)

User overrides toggle behavior:

```jsx
const { on, toggle } = useToggle({
  stateReducer: (state, changes) => {
    if (state.on === true) {
      return { on: true }; // Prevent turning off
    }
    return changes;
  }
});
```

### UI

```jsx
<button onClick={toggle}>{on ? "On" : "Off"}</button>
```

The toggle can turn on, but never off.
Full behavioral override without modifying internal code.

---

# 5. Real Use Case: Dropdown Menu Logic Override

Imagine a dropdown that normally closes when selecting an item.

User wants it to stay open after selection.

### Default behavior (inside component):

```jsx
changes = { open: false };
```

### User override:

```jsx
stateReducer: (state, changes) => {
  if (changes.open === false) return state; // ignore close
  return changes;
}
```

The component behaves exactly as the user intends.

This is impossible without State Reducer Pattern.

---

# 6. Real Example from Downshift (Industry Standard)

Downshift exposes:

* `stateReducer`
* `onStateChange`

Usage:

```jsx
<Downshift
  stateReducer={(state, changes) => {
    if (changes.type === Downshift.stateChangeTypes.blurInput) {
      return {}; // prevent menu close
    }
    return changes;
  }}
>
  ...
</Downshift>
```

The user controls internal behavior without rewriting the component.

---

# 7. State Reducer Pattern vs useReducer

| Feature          | useReducer            | State Reducer Pattern                 |
| ---------------- | --------------------- | ------------------------------------- |
| Purpose          | manage internal state | allow user to override internal logic |
| Reducer location | inside component      | outside, passed by user               |
| Flexibility      | fixed transitions     | user-defined transitions              |
| Use case         | component logic       | design systems, headless UI           |

This pattern extends beyond hooks—it is an **architectural API pattern**.

---

# 8. State Reducer Pattern with Events

Components can expose the “intent” of state change:

```jsx
internalSetState({ open: true, type: "itemSelected" });
```

User can override:

```jsx
(state, changes) => {
  if (changes.type === "itemSelected") {
    return { open: state.open }; // keep it open
  }
  return changes;
}
```

You expose internal transitions as event types.
User decides behavior.

---

# 9. Designing a Component Using State Reducer Pattern

### Step 1: Define internal state

```jsx
const [state, setState] = useState({ open: false });
```

### Step 2: Propose changes

```jsx
const changes = { open: !state.open, type: "toggle" };
```

### Step 3: Pass through stateReducer

```jsx
const final = stateReducer
  ? stateReducer(state, changes)
  : changes;
```

### Step 4: Apply final state

```jsx
setState(final);
```

This becomes your template for extensible components.

---

# 10. Anti-Patterns

Avoid:

### 1. Letting users override everything without limits

Provide clear event types.

### 2. Calling stateReducer without passing current state

Breaks the contract.

### 3. Allowing uncontrolled vs controlled conflict

State Reducer pattern should work consistently with both modes.

### 4. Extremely complex reducer APIs

Reducer should be simple:

```
(state, changes) → newState
```

### 5. Forcing stateReducer in small components

Use only when customization is needed.

---

# 11. When Should You Use This Pattern?

Use when:

* building headless UI components
* building complex reusable components (dropdown, select, autocomplete)
* need to allow advanced users to override behavior
* internal logic must be flexible
* creating a design system
* building multi-step widgets
* building wizards or configurable inputs

Avoid when:

* component logic is simple
* no external customization needed
* adding reducer complicates API unnecessarily

---

# 12. Follow-up Questions

1. Do you need State Reducer Pattern for dropdowns, accordions, tabs, or autocomplete?
2. Should your design system expose `stateReducer` like Downshift does?
3. Do you want to combine State Reducer Pattern with Controlled vs Uncontrolled?
4. Should state transitions include event types for debugging?
5. Do you want to build a reusable headless dropdown using this pattern?
6. Should we add internal warnings for invalid stateReducer outputs?
7. Do you want a TypeScript version of this pattern?
8. Should the reducer handle async transitions?
9. Should consumers be able to override keyboard behavior?
10. Should we build a full demo component using this pattern next?
