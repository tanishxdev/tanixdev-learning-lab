# 17.4 Async Actions (Zustand)

A complete, dev-mindset explanation of **how async logic works in Zustand**, how it differs from Redux thunks, when to use async actions, and how to structure them cleanly.

---

# 1. Why Async Actions in Zustand?

### The core problem

React developers often need async logic for:

* API requests
* Fetching user data
* Searching
* Pagination
* Updating remote resources
* Delayed UI logic
* Loading states

Redux provides `createAsyncThunk`, but Zustand does NOT.

This is GOOD because Zustand:

* Doesn't enforce a structure
* Lets you write async logic directly
* Removes Redux boilerplate
* Gives freedom and simplicity

Async actions in Zustand = **just normal async functions inside the store**.

---

# 2. What are Async Actions in Zustand?

Zustand async action = any function inside the store that uses:

```js
async () => { ... }
```

and updates state using `set()`.

Example:

```jsx
fetchUser: async () => {
  const res = await fetch("/api/user");
  const data = await res.json();
  set({ user: data });
}
```

You write async like normal JavaScript.

No special middleware.
No thunks.
No action types.

Simple and powerful.

---

# 3. When to Use Async Actions?

Use async actions when:

1. Fetching data from API
2. Updating data on server
3. Triggering asynchronous UI logic
4. Performing delayed actions
5. Handling loading/error states
6. Doing async computations

Do NOT use async actions when:

* You need caching → use React Query or RTK Query
* You need automatic retries, stale data, invalidation
* You need abstraction for very large applications

---

# 4. Analogy

Think of Zustand as a notebook.

Async actions are simply writing in the notebook after fetching data from somewhere.

No forms, no paperwork, no Redux ceremony.

---

# 5. How Async Actions Work Internally

When Zustand sees:

```js
fetchUser: async () => { ... }
```

The flow is:

1. Component calls `useStore.getState().fetchUser()`
2. fetchUser runs async logic
3. When ready, calls `set()` to update store
4. Zustand notifies only subscribed components
5. Only those specific components re-render

Unlike Redux, Zustand does not trigger global state comparisons for entire slices.

---

# 6. Developer Mindset Thinking

Before writing async logic, ask:

1. Should this response live in global state?
2. Will multiple components need it?
3. Do I need loading + error indicators?
4. Should I cache the response myself or use React Query?
5. Should I keep this async logic inside the component instead?

Zustand encourages **simple, local decision-making**, not complex architecture.

---

# 7. Basic Async Example

## userStore.js

```jsx
import { create } from "zustand";

export const useUserStore = create((set) => ({
  user: null,
  loading: false,
  error: null,

  fetchUser: async () => {
    set({ loading: true, error: null });

    try {
      const res = await fetch("/api/user");
      const data = await res.json();

      set({ user: data, loading: false });
    } catch (err) {
      set({ loading: false, error: "Failed to load user" });
    }
  }
}));
```

---

# 8. Dry Run of Example

1. Component calls `fetchUser()`
2. loading: true → shows spinner
3. API request happens
4. Success → user stored in Zustand
5. Zustand re-renders components using user
6. loading resets → UI updates
7. If error → error state updates

Very predictable flow.

---

# 9. Example: Updating Server Data

```jsx
updateUser: async (payload) => {
  set({ loading: true });
  const res = await fetch("/api/user", {
    method: "PUT",
    body: JSON.stringify(payload)
  });
  const data = await res.json();

  set({ user: data, loading: false });
}
```

---

# 10. Example: Async Logic with get()

Sometimes you need the previous state:

```jsx
increaseSalary: async () => {
  const current = get().salary;
  await new Promise((r) => setTimeout(r, 1000));
  set({ salary: current + 1000 });
}
```

`get()` allows reading state inside async code.

---

# 11. Example: Derived Async Logic

```jsx
searchProducts: async (query) => {
  set({ loading: true });

  const res = await fetch(`/api/products?q=${query}`);
  const data = await res.json();

  set({ results: data, loading: false });
}
```

Perfect for search bars, filter UIs.

---

# 12. Example: Async Action with Pagination

```jsx
fetchPage: async (page) => {
  set({ loading: true });

  const res = await fetch(`/api/products?page=${page}`);
  const data = await res.json();

  set((state) => ({
    products: [...state.products, ...data],
    loading: false
  }));
}
```

---

# 13. Common Mistakes

1. Not setting loading/error
2. Updating state before async finishes
3. Wrapping too many async actions in one store
4. Fetching server data through Zustand instead of React Query
5. Creating a new store inside component (breaks everything)
6. Forgetting to use selectors when reading state
7. Handling derived computation inside store instead of in selectors

---

# 14. When NOT to Use Zustand Async

Avoid Zustand async for:

1. Complex API flows
2. Server caching
3. Invalidation logic
4. Pagination / infinite scroll caching
5. Prefetching
6. Optimistic updates
7. Retrying failed requests

For these → React Query / RTK Query are far better.

Zustand async = great for small to medium async use-cases.

---

# 15. Best Practices

1. Keep async logic close to state (inside store)
2. Always include `loading` and `error`
3. Use try/catch
4. Use `get()` for reading state
5. Return resolved values when needed
6. Keep stores flat (avoid deep nesting)
7. Avoid storing huge server data blobs

---

# 16. Comparing Zustand Async to Redux Async Thunk

| Feature                | Zustand Async        | createAsyncThunk        |
| ---------------------- | -------------------- | ----------------------- |
| Boilerplate            | Almost none          | Medium                  |
| Built-in loading/error | No                   | Yes                     |
| Caching                | No                   | No (but RTK Query does) |
| Structure              | Flexible             | Strict                  |
| Good for               | UI flows, small APIs | Enterprise APIs         |
| Error handling         | Manual               | Auto                    |
| Re-render control      | Fine-grained         | Slice-based             |

Zustand is simpler.
Redux Toolkit is more structured.

---

# 17. Follow-up Questions

1. Why doesn’t Zustand need special middleware for async actions?
2. When should async logic be moved out of zustand into React Query?
3. Why is using get() important in async flows?
4. What happens if async updates modify deeply nested state?
5. Which state belongs in Zustand vs component local state?
6. Should Zustand async actions return values?
7. How to handle race conditions in Zustand async?
8. Why is loading state essential in async logic?
9. How does async logic in Zustand differ from Redux thunks?
10. When is using Zustand async wrong for architecture?
