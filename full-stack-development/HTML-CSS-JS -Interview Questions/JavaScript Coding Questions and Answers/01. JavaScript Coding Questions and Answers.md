## Problem: Reverse a given string in JavaScript

Input: `"Hello, World!"`
Output: `"!dlroW ,olleH"`

---

### Approach 1: Iterative (for loop)

##### Thinking aloud

- Strings in JS are **immutable**, so I cannot modify characters in place.
- I’ll create a new empty string `reversedStr`.
- I’ll start from the **last index** of the string.
- I’ll move backwards and **append each character**.
- Finally, return the new string.

#### Code

```js
function reverseString(str) {
  let reversedStr = "";

  // Start from last character and move backward
  for (let i = str.length - 1; i >= 0; i--) {
    reversedStr += str[i];
  }

  return reversedStr;
}

// Example usage
const inputString = "Hello, World!";
console.log(reverseString(inputString));
```

#### Dry Run (small)

```
str = "abc"
i = 2 → reversedStr = "c"
i = 1 → reversedStr = "cb"
i = 0 → reversedStr = "cba"
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (new string)

#### Interview Notes

- Very **clear and readable**
- Works in all JS environments
- Slight downside: string concatenation inside loop (still acceptable)

---

### Approach 2: Recursion

#### Thinking aloud

- Recursion means:
  - Break the problem into **smaller subproblems**

- Base case:
  - If string is empty, return empty string

- Recursive step:
  - Reverse the remaining string
  - Add the first character at the end

#### Code

```js
function reverseStringRecursively(str) {
  if (str === "") {
    return "";
  }

  return reverseStringRecursively(str.substr(1)) + str.charAt(0);
}

// Example usage
console.log(reverseStringRecursively("Hello, World!"));
```

#### Dry Run (for "abc")

```
reverse("abc")
→ reverse("bc") + "a"
→ reverse("c") + "b" + "a"
→ reverse("") + "c" + "b" + "a"
→ "cba"
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (call stack)

#### Interview Notes

- Shows **recursion understanding**
- Not ideal for very long strings (stack overflow risk)
- Good for concept explanation, not production preferred

---

### Approach 3: Built-in Methods

#### Thinking aloud

- Convert string → array
- Reverse array
- Join back into string
- Shortest and cleanest solution

#### Code

```js
function reverseStringUsingBuiltInMethods(str) {
  return str.split("").reverse().join("");
}

// Example usage
console.log(reverseStringUsingBuiltInMethods("Hello, World!"));
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)**

#### Interview Notes

- Most **concise**
- Interviewer may ask:
  “Can you do it without built-ins?”
  → That’s why approach 1 matters.

### Interview Answers

> “I can reverse a string by iterating from the end and building a new string.
> Time complexity is O(n).
> Alternatively, recursion or built-in methods can be used, but iteration is the safest and most readable.”

## Problem: Check whether a given string is a palindrome in JavaScript

Input: `"naman"`
Output: `true`

---

### Approach 1: Using reverse method

#### Thinking aloud

- A palindrome reads the same forward and backward.
- I will reverse the string and compare it with the original.
- Before comparison:
  - Remove non-alphanumeric characters.
  - Convert to lowercase for case-insensitive check.

#### Code

```js
function checkPalindrome(str) {
  const cleanedStr = str.replace(/[^A-Za-z0-9]/g, "").toLowerCase();
  const reversedStr = cleanedStr.split("").reverse().join("");
  return cleanedStr === reversedStr;
}

// Example usage
const inputString = "naman";
console.log(checkPalindrome(inputString));
```

#### Dry Run (small)

```
str = "naman"
cleanedStr = "naman"
reversedStr = "naman"
comparison → true
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (reversed string)

#### Interview Notes

- Very simple and readable
- Uses extra space for reversed string
- Interviewer may ask for solution without reverse

---

### Approach 2: Two-pointer (loop)

#### Thinking aloud

- I will compare characters from both ends.
- Use two pointers:
  - `left` from start
  - `right` from end

- If any mismatch occurs, it is not a palindrome.
- No need to reverse the string.

#### Code

```js
function checkPalindromeUsingLoop(str) {
  const cleanedStr = str.replace(/[^A-Za-z0-9]/g, "").toLowerCase();
  let left = 0;
  let right = cleanedStr.length - 1;

  while (left < right) {
    if (cleanedStr[left] !== cleanedStr[right]) {
      return false;
    }
    left++;
    right--;
  }
  return true;
}

// Example usage
const inputString1 = "naman";
console.log(checkPalindromeUsingLoop(inputString1));
```

#### Dry Run (for "naman")

```
left=0, right=4 → n === n
left=1, right=3 → a === a
left=2, right=2 → stop
return true
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- More optimal than reverse method
- Preferred in interviews
- Shows understanding of two-pointer technique

---

### Interview Answers

> “I check a palindrome by comparing characters from both ends using two pointers.
> If all characters match, the string is a palindrome.
> This runs in O(n) time with O(1) extra space.”

## Problem: Find the largest number in an array in JavaScript

Input: `[3, 5, 7, 2, 8]`
Output: `8`

---

### Approach 1: Iterative (for loop)

#### Thinking aloud

- First, handle the edge case:
  - If the array is empty, return `null`.

- Assume the **first element** is the largest initially.
- Traverse the array from index `1`.
- Compare each element with the current largest.
- If a larger value is found, update `largest`.
- After the loop, return the largest value.

#### Code

```js
function findLargest(arr) {
  if (arr.length === 0) {
    return null;
  }

  let largest = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > largest) {
      largest = arr[i];
    }
  }

  return largest;
}

// Example usage
const numbers = [3, 5, 7, 2, 8];
console.log(findLargest(numbers));
```

#### Dry Run (small)

```
arr = [3, 5, 7, 2, 8]

largest = 3
i=1 → 5 > 3 → largest = 5
i=2 → 7 > 5 → largest = 7
i=3 → 2 > 7 → no change
i=4 → 8 > 7 → largest = 8

return 8
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- Most reliable and clear approach
- Works for all numeric values
- Preferred when avoiding built-in helpers

---

### Approach 2: Using `Math.max`

#### Thinking aloud

- `Math.max` returns the maximum value from given arguments.
- Use the spread operator to pass array elements.
- Still need to handle empty array case.

#### Code

```js
function findLargestUsingMathMax(arr) {
  if (arr.length === 0) {
    return null;
  }
  return Math.max(...arr);
}

// Example usage
const numbers1 = [3, 5, 7, 2, 8];
console.log(findLargestUsingMathMax(numbers1));
```

#### Dry Run (small)

```
Math.max(3, 5, 7, 2, 8)
→ 8
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (spread operator creates arguments)

#### Interview Notes

- Short and clean
- Not ideal for very large arrays (argument limit)
- Interviewer may ask for loop-based solution

---

### Interview Answers

> “I find the largest number by iterating through the array and tracking the maximum value.
> This takes O(n) time and O(1) extra space.
> A built-in alternative is Math.max with spread, but the loop approach is safer.”
