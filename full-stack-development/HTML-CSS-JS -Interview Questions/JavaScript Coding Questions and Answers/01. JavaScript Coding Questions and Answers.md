## Problem 1: Reverse a given string in JavaScript

Input: `"Hello, World!"`
Output: `"!dlroW ,olleH"`

---

### Approach 1: Iterative (for loop)

##### Thinking aloud

- Strings in JS are **immutable**, so I cannot modify characters in place.
- I’ll create a new empty string `reversedStr`.
- I’ll start from the **last index** of the string.
- I’ll move backwards and **append each character**.
- Finally, return the new string.

#### Code

```js
function reverseString(str) {
  let reversedStr = "";

  // Start from last character and move backward
  for (let i = str.length - 1; i >= 0; i--) {
    reversedStr += str[i];
  }

  return reversedStr;
}

// Example usage
const inputString = "Hello, World!";
console.log(reverseString(inputString));
```

#### Dry Run (small)

```
str = "abc"
i = 2 → reversedStr = "c"
i = 1 → reversedStr = "cb"
i = 0 → reversedStr = "cba"
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (new string)

#### Interview Notes

- Very **clear and readable**
- Works in all JS environments
- Slight downside: string concatenation inside loop (still acceptable)

---

### Approach 2: Recursion

#### Thinking aloud

- Recursion means:
  - Break the problem into **smaller subproblems**

- Base case:
  - If string is empty, return empty string

- Recursive step:
  - Reverse the remaining string
  - Add the first character at the end

#### Code

```js
function reverseStringRecursively(str) {
  if (str === "") {
    return "";
  }

  return reverseStringRecursively(str.substr(1)) + str.charAt(0);
}

// Example usage
console.log(reverseStringRecursively("Hello, World!"));
```

#### Dry Run (for "abc")

```
reverse("abc")
→ reverse("bc") + "a"
→ reverse("c") + "b" + "a"
→ reverse("") + "c" + "b" + "a"
→ "cba"
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (call stack)

#### Interview Notes

- Shows **recursion understanding**
- Not ideal for very long strings (stack overflow risk)
- Good for concept explanation, not production preferred

---

### Approach 3: Built-in Methods

#### Thinking aloud

- Convert string → array
- Reverse array
- Join back into string
- Shortest and cleanest solution

#### Code

```js
function reverseStringUsingBuiltInMethods(str) {
  return str.split("").reverse().join("");
}

// Example usage
console.log(reverseStringUsingBuiltInMethods("Hello, World!"));
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)**

#### Interview Notes

- Most **concise**
- Interviewer may ask:
  “Can you do it without built-ins?”
  → That’s why approach 1 matters.

### Interview Answers

> “I can reverse a string by iterating from the end and building a new string.
> Time complexity is O(n).
> Alternatively, recursion or built-in methods can be used, but iteration is the safest and most readable.”

## Problem 2: Check whether a given string is a palindrome in JavaScript

Input: `"naman"`
Output: `true`

---

### Approach 1: Using reverse method

#### Thinking aloud

- A palindrome reads the same forward and backward.
- I will reverse the string and compare it with the original.
- Before comparison:
  - Remove non-alphanumeric characters.
  - Convert to lowercase for case-insensitive check.

#### Code

```js
function checkPalindrome(str) {
  const cleanedStr = str.replace(/[^A-Za-z0-9]/g, "").toLowerCase();
  const reversedStr = cleanedStr.split("").reverse().join("");
  return cleanedStr === reversedStr;
}

// Example usage
const inputString = "naman";
console.log(checkPalindrome(inputString));
```

#### Dry Run (small)

```
str = "naman"
cleanedStr = "naman"
reversedStr = "naman"
comparison → true
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (reversed string)

#### Interview Notes

- Very simple and readable
- Uses extra space for reversed string
- Interviewer may ask for solution without reverse

---

### Approach 2: Two-pointer (loop)

#### Thinking aloud

- I will compare characters from both ends.
- Use two pointers:
  - `left` from start
  - `right` from end

- If any mismatch occurs, it is not a palindrome.
- No need to reverse the string.

#### Code

```js
function checkPalindromeUsingLoop(str) {
  const cleanedStr = str.replace(/[^A-Za-z0-9]/g, "").toLowerCase();
  let left = 0;
  let right = cleanedStr.length - 1;

  while (left < right) {
    if (cleanedStr[left] !== cleanedStr[right]) {
      return false;
    }
    left++;
    right--;
  }
  return true;
}

// Example usage
const inputString1 = "naman";
console.log(checkPalindromeUsingLoop(inputString1));
```

#### Dry Run (for "naman")

```
left=0, right=4 → n === n
left=1, right=3 → a === a
left=2, right=2 → stop
return true
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- More optimal than reverse method
- Preferred in interviews
- Shows understanding of two-pointer technique

---

### Interview Answers

> “I check a palindrome by comparing characters from both ends using two pointers.
> If all characters match, the string is a palindrome.
> This runs in O(n) time with O(1) extra space.”

## Problem 3: Find the largest number in an array in JavaScript

Input: `[3, 5, 7, 2, 8]`
Output: `8`

---

### Approach 1: Iterative (for loop)

#### Thinking aloud

- First, handle the edge case:
  - If the array is empty, return `null`.

- Assume the **first element** is the largest initially.
- Traverse the array from index `1`.
- Compare each element with the current largest.
- If a larger value is found, update `largest`.
- After the loop, return the largest value.

#### Code

```js
function findLargest(arr) {
  if (arr.length === 0) {
    return null;
  }

  let largest = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > largest) {
      largest = arr[i];
    }
  }

  return largest;
}

// Example usage
const numbers = [3, 5, 7, 2, 8];
console.log(findLargest(numbers));
```

#### Dry Run (small)

```
arr = [3, 5, 7, 2, 8]

largest = 3
i=1 → 5 > 3 → largest = 5
i=2 → 7 > 5 → largest = 7
i=3 → 2 > 7 → no change
i=4 → 8 > 7 → largest = 8

return 8
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- Most reliable and clear approach
- Works for all numeric values
- Preferred when avoiding built-in helpers

---

### Approach 2: Using `Math.max`

#### Thinking aloud

- `Math.max` returns the maximum value from given arguments.
- Use the spread operator to pass array elements.
- Still need to handle empty array case.

#### Code

```js
function findLargestUsingMathMax(arr) {
  if (arr.length === 0) {
    return null;
  }
  return Math.max(...arr);
}

// Example usage
const numbers1 = [3, 5, 7, 2, 8];
console.log(findLargestUsingMathMax(numbers1));
```

#### Dry Run (small)

```
Math.max(3, 5, 7, 2, 8)
→ 8
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (spread operator creates arguments)

#### Interview Notes

- Short and clean
- Not ideal for very large arrays (argument limit)
- Interviewer may ask for loop-based solution

---

### Interview Answers

> “I find the largest number by iterating through the array and tracking the maximum value.
> This takes O(n) time and O(1) extra space.
> A built-in alternative is Math.max with spread, but the loop approach is safer.”

## Problem 4: Remove the first element from an array in JavaScript

Input: `[5, 6, 7]`
Output: `[6, 7]`

---

### Approach 1: Using `slice()`

#### Thinking aloud

- `slice(startIndex)` returns a **new array**.
- `slice(1)` means:
  - Start from index `1`
  - Exclude index `0`

- It does **not modify the original array**.
- So I must reassign the result back to `arr`.

#### Code

```js
let arr = [5, 6, 7];

// Create a new array starting from index 1
arr = arr.slice(1);

console.log(arr);
```

#### Dry Run

```
arr = [5, 6, 7]
slice(1) → [6, 7]
arr = [6, 7]
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)** (new array created)

#### Interview Notes

- Does not mutate original array
- Functional / immutable approach
- Preferred when immutability matters

---

### Approach 2: Using `shift()`

#### Thinking aloud

- `shift()` removes the first element.
- It **modifies the original array**.
- It also returns the removed element.

#### Code

```js
let arr = [5, 6, 7];

// Remove first element
arr.shift();

console.log(arr);
```

#### Dry Run

```
arr = [5, 6, 7]
shift() removes 5
arr becomes [6, 7]
```

#### Complexity

- Time: **O(n)** (elements shift left)
- Space: **O(1)**

#### Interview Notes

- Mutates original array
- Simple and direct
- Good for small arrays
- Not ideal in performance-critical large arrays

---

### Interview Answers

> “To remove the first element, I can use `shift()` which mutates the array.
> If I want to avoid mutation, I use `slice(1)` which returns a new array.
> Both take O(n) time.”

## Problem: Write a code to create an arrow function?

The code defines an arrow function add that takes two arguments a and b and returns their sum (a + b). When console.log(add(6, 2)) is executed, it calls the add function with 6 and 2, and prints the result which is 8, to the console.

## Problem 5: Write a Program to use a callback function

Input: `name = "Geek"`
Output: `Hello, Geek!`

---

### Approach

#### Thinking aloud

- A callback function is a function passed as an argument to another function.
- The main function executes the callback when needed.
- Here:
  - `greet` takes `name` and `callback`.
  - It calls `callback` with a formatted message.

#### Code

```js
function greet(name, callback) {
  callback(`Hello, ${name}!`);
}

greet("Geek", function (message) {
  console.log(message);
});
```

#### Output

```
Hello, Geek!
```

#### Complexity

- Time: **O(1)**
- Space: **O(1)**

#### Interview Notes

- Callbacks are used in:
  - Asynchronous operations
  - Event handling
  - Higher-order functions

- Important concept in JS execution model

---

## Problem 6: Write a code to create an arrow function

Input: `6, 2`
Output: `8`

---

### Approach

#### Thinking aloud

- Arrow functions are shorter syntax for function expressions.
- Syntax:
  - `(params) => expression`

- If single expression:
  - It implicitly returns the value.

#### Code

```js
const add = (a, b) => a + b;

console.log(add(6, 2));
```

#### Output

```
8
```

#### Complexity

- Time: **O(1)**
- Space: **O(1)**

#### Interview Notes

- Arrow functions:
  - Do not have their own `this`
  - Cannot be used as constructors

- Common in modern JavaScript

---

## Problem 7: Write a Program to add a property to an object

Input: `{ name: 'Riya' }`
Output: `{ name: 'Riya', age: 21 }`

---

### Approach

#### Thinking aloud

- Objects in JS are dynamic.
- We can add properties using:
  - Dot notation
  - Bracket notation

#### Code

```js
const obj = { name: "Riya" };

obj.age = 21;

console.log(obj);
```

#### Output

```
{ name: 'Riya', age: 21 }
```

#### Complexity

- Time: **O(1)**
- Space: **O(1)**

#### Interview Notes

- Objects are mutable.
- Properties can be added anytime.
- Important in dynamic data handling.

---

## Problem 8: Write a Program to delete a property from an object

Input: `{ name: 'Riya', age: 21 }`
Output: `{ name: 'Riya' }`

---

### Approach

#### Thinking aloud

- Use `delete` keyword.
- It removes the property from the object.
- It mutates the original object.

#### Code

```js
const obj = { name: "Riya", age: 21 };

delete obj.age;

console.log(obj);
```

#### Output

```
{ name: 'Riya' }
```

#### Complexity

- Time: **O(1)**
- Space: **O(1)**

#### Interview Notes

- `delete` removes property completely.
- Alternative:
  - Use destructuring to create new object without property (immutability).

- Important when working with state management.

## Problem 9: What will be the output?

```js
console.log([1, 2, 3].reduce((a, b) => a + b));
```

Output: `6`

---

### Explanation

#### Thinking aloud

- `reduce()` processes array elements one by one.
- `a` = accumulator
- `b` = current value
- No initial value provided:
  - `a` starts as first element → `1`
  - `b` starts as second element → `2`

#### Dry Run

```
Step 1: a=1, b=2 → 1+2=3
Step 2: a=3, b=3 → 3+3=6
```

Final result → `6`

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- If array is empty and no initial value → error
- Always safe to provide initial value

---

## Problem 10: What will be the output?

```js
console.log("gfg".repeat(3));
```

Output: `gfggfggfg`

---

### Explanation

#### Thinking aloud

- `repeat(3)` repeats the string 3 times.
- It returns a new string.
- Original string is unchanged.

#### Dry Run

```
'gfg' + 'gfg' + 'gfg'
→ 'gfggfggfg'
```

#### Complexity

- Time: **O(n × k)** (string length × repeat count)
- Space: **O(n × k)**

#### Interview Notes

- Useful for pattern printing
- Throws error if negative number passed

---

## Problem 11: What will be the output?

```js
console.log(1 + "2");
```

Output: `12`

---

### Explanation

#### Thinking aloud

- `+` operator with string → triggers string concatenation.
- Number `1` gets converted to string.
- `"1" + "2"` → `"12"`

#### Interview Notes

- `+` is both addition and concatenation.
- Type coercion happens automatically.

---

## Problem 12: What will be the output?

```js
console.log("6" - 1);
```

Output: `5`

---

### Explanation

#### Thinking aloud

- `-` operator only works with numbers.
- JS converts `'6'` to number `6`.
- `6 - 1 = 5`

#### Interview Notes

- `-`, `*`, `/` force numeric conversion.
- This is implicit type coercion.

---

## Problem 13: What will be the output?

```js
console.log(1 === "1");
```

Output: `false`

---

### Explanation

#### Thinking aloud

- `===` checks:
  - Value
  - Type

- `1` → number
- `'1'` → string
- Different types → `false`

#### Interview Notes

- Always prefer `===` over `==`
- Avoid loose equality in production code

---

## Problem 14: What will be the output?

```js
console.log(null == undefined);
```

Output: `true`

---

### Explanation

#### Thinking aloud

- `==` is loose equality.
- JS treats:
  - `null`
  - `undefined`
    as equal only to each other.

#### Interview Notes

- `null === undefined` → false
- `null == undefined` → true
- Common interview trap on type coercion

## Problem 15: Write a Program to find sum of an array

Input: `[15, 6, 10, 2]`
Output: `33`

---

### Approach 1: Using for loop

#### Thinking aloud

- Initialize `sum = 0`
- Traverse the array
- Add each element to `sum`
- Return final `sum`

#### Code

```js
function sumArray(arr) {
  let sum = 0;

  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
  }

  return sum;
}

console.log(sumArray([15, 6, 10, 2]));
```

#### Dry Run

```
sum = 0
i=0 → sum = 0 + 15 = 15
i=1 → sum = 15 + 6 = 21
i=2 → sum = 21 + 10 = 31
i=3 → sum = 31 + 2 = 33
return 33
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- Simple accumulation pattern
- Works for all numeric arrays
- Can also be solved using `reduce()`

---

### Approach 2: Using reduce

#### Thinking aloud

- `reduce()` accumulates values
- Start with initial value `0`
- Add each element

#### Code

```js
function sumArray(arr) {
  return arr.reduce((acc, curr) => acc + curr, 0);
}

console.log(sumArray([15, 6, 10, 2]));
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- Cleaner syntax
- Must provide initial value to avoid edge-case errors

---

## Problem 16: Write a Program to check if a number is prime

Input: `7`
Output: `true`

---

### Approach 1: Basic loop

#### Thinking aloud

- Prime number:
  - Greater than 1
  - Divisible only by 1 and itself

- If number ≤ 1 → return false
- Check divisibility from `2` to `num - 1`
- If divisible → not prime
- Otherwise → prime

#### Code

```js
function isPrime(num) {
  if (num <= 1) return false;

  for (let i = 2; i < num; i++) {
    if (num % i === 0) {
      return false;
    }
  }

  return true;
}

console.log(isPrime(7));
```

#### Dry Run (for 7)

```
i=2 → 7%2 ≠ 0
i=3 → 7%3 ≠ 0
i=4 → 7%4 ≠ 0
i=5 → 7%5 ≠ 0
i=6 → 7%6 ≠ 0
return true
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- Works but not optimal
- Can optimize to check till √num

---

### Approach 2: Optimized (check till square root)

#### Thinking aloud

- If `num` has a factor greater than √num,
  it must also have a factor smaller than √num
- So only check till `i * i <= num`

#### Code

```js
function isPrime(num) {
  if (num <= 1) return false;

  for (let i = 2; i * i <= num; i++) {
    if (num % i === 0) {
      return false;
    }
  }

  return true;
}

console.log(isPrime(7));
```

#### Complexity

- Time: **O(√n)**
- Space: **O(1)**

#### Interview Notes

- Optimized version preferred
- Common interview question
- Important for number theory basics

## Problem 17: Write a Program to print Fibonacci sequence up to n terms

Input: `7`
Output:

```
0
1
1
2
3
5
8
```

---

### Approach

#### Thinking aloud

- Fibonacci starts with:
  - `0`
  - `1`

- Every next number:
  - `next = num1 + num2`

- After printing:
  - Shift values:
    - `num1 = num2`
    - `num2 = next`

- Repeat this `n` times.

#### Code

```js
function fibonacci(n) {
  let num1 = 0;
  let num2 = 1;
  let nextNum;

  for (let i = 1; i <= n; i++) {
    console.log(num1);
    nextNum = num1 + num2;
    num1 = num2;
    num2 = nextNum;
  }
}

fibonacci(7);
```

#### Dry Run (n=7)

```
i=1 → 0
i=2 → 1
i=3 → 1
i=4 → 2
i=5 → 3
i=6 → 5
i=7 → 8
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- Important sequence question
- Can also be solved using recursion
- Iterative is more efficient

---

## Problem 18: Write a Program to find factorial of a number

Input: `7`
Output: `5040`

---

### Approach

#### Thinking aloud

- Factorial:
  - `n! = n × (n-1) × ... × 1`

- Initialize `answer = 1`
- Multiply from `2` to `num`
- Return final result

#### Code

```js
function factorial(num) {
  let answer = 1;

  for (let i = 2; i <= num; i++) {
    answer *= i;
  }

  return answer;
}

console.log(factorial(7));
```

#### Dry Run (7)

```
1 × 2 = 2
2 × 3 = 6
6 × 4 = 24
24 × 5 = 120
120 × 6 = 720
720 × 7 = 5040
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- Edge case: 0! = 1
- Recursive solution also possible

---

## Problem 19: Calculate the Power of a Number in JavaScript

Input: `3, 4`
Output: `81`

---

### Approach

#### Thinking aloud

- Use exponentiation operator `**`
- `base ** exponent`
- Direct mathematical operation

#### Code

```js
function power(base, exponent) {
  return base ** exponent;
}

console.log(power(3, 4));
```

#### Dry Run

```
3 ** 4
= 3 × 3 × 3 × 3
= 81
```

#### Complexity

- Time: **O(1)** (built-in optimized)
- Space: **O(1)**

#### Interview Notes

- Can also be done using loop
- Important when discussing binary exponentiation (advanced)

---

## Problem 20: Write a Program to print frequency of elements in an array

Input: `[1, 1, 2, 3, 3, 4]`
Output: `{ '1': 2, '2': 1, '3': 2, '4': 1 }`

---

### Approach

#### Thinking aloud

- Create empty object `freq`
- Traverse array
- If element already exists in object:
  - Increment count

- Else:
  - Initialize count to 1

- Return object

#### Code

```js
function frequency(arr) {
  const freq = {};

  for (let i = 0; i < arr.length; i++) {
    if (freq[arr[i]]) {
      freq[arr[i]] += 1;
    } else {
      freq[arr[i]] = 1;
    }
  }

  return freq;
}

console.log(frequency([1, 1, 2, 3, 3, 4]));
```

#### Dry Run

```
1 → {1:1}
1 → {1:2}
2 → {1:2, 2:1}
3 → {1:2, 2:1, 3:1}
3 → {1:2, 2:1, 3:2}
4 → {1:2, 2:1, 3:2, 4:1}
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)**

#### Interview Notes

- Very common interview question
- Can also use Map instead of object
- Important for counting problems

## Problem 21: Count occurrences of a character in a string

Input: `"GeeksForGeeks", 'G'`
Output: `2`

---

### Approach 1: Using split()

#### Thinking aloud

- Split the string using the character.
- The number of occurrences equals:
  - `array length - 1`

#### Code

```js
function countChar(str, char) {
  return str.split(char).length - 1;
}

console.log(countChar("GeeksForGeeks", "G"));
```

#### Dry Run

```
"GeeksForGeeks".split("G")
→ ["", "eeksFor", "eeks"]
length = 3
3 - 1 = 2
```

#### Complexity

- Time: **O(n)**
- Space: **O(n)**

#### Interview Notes

- Simple one-liner
- Case-sensitive
- Creates extra array

---

### Approach 2: Using for loop

#### Thinking aloud

- Initialize `count = 0`
- Traverse each character
- If match found → increment count

#### Code

```js
function countChar(str, char) {
  let count = 0;

  for (let i = 0; i < str.length; i++) {
    if (str[i] === char) {
      count++;
    }
  }

  return count;
}

console.log(countChar("GeeksForGeeks", "G"));
```

#### Complexity

- Time: **O(n)**
- Space: **O(1)**

#### Interview Notes

- More optimal (no extra array)
- Preferred in interviews

---

## Problem 22: Convert Celsius to Fahrenheit

Input: `20`
Output: `68`

---

### Approach

#### Thinking aloud

- Formula:
  - `F = (C × 9/5) + 32`

- Direct mathematical conversion

#### Code

```js
function celsiusToFahrenheit(celsius) {
  return (celsius * 9) / 5 + 32;
}

console.log(celsiusToFahrenheit(20));
```

#### Complexity

- Time: **O(1)**
- Space: **O(1)**

#### Interview Notes

- Pure formula-based
- No loop required

---

## Problem 23: Convert Fahrenheit to Celsius

Input: `68`
Output: `20`

---

### Approach

#### Thinking aloud

- Formula:
  - `C = (F - 32) × 5/9`

#### Code

```js
function fahrenheitToCelsius(fahrenheit) {
  return ((fahrenheit - 32) * 5) / 9;
}

console.log(fahrenheitToCelsius(68));
```

#### Complexity

- Time: **O(1)**
- Space: **O(1)**

#### Interview Notes

- Reverse formula of previous question
- Simple arithmetic conversion

---

## Problem 24: Sort array in Ascending Order

Input: `[5, 3, 8, 1]`
Output: `[1, 3, 5, 8]`

---

### Approach: Nested loops (Simple selection-style sort)

#### Thinking aloud

- Compare each element with remaining elements
- If smaller element found → swap
- Repeat until array sorted

#### Code

```js
function sortArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j]) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }

  return arr;
}

console.log(sortArray([5, 3, 8, 1]));
```

#### Dry Run (key swaps)

```
[5,3,8,1]
swap 5 & 3 → [3,5,8,1]
swap 3 & 1 → [1,5,8,3]
swap 5 & 3 → [1,3,8,5]
swap 8 & 5 → [1,3,5,8]
```

#### Complexity

- Time: **O(n²)**
- Space: **O(1)**

#### Interview Notes

- Basic sorting logic
- Not efficient for large arrays
- Good for learning sorting fundamentals

---

## Problem 25: Sort array in Descending Order

Input: `[5, 3, 8, 1]`
Output: `[8, 5, 3, 1]`

---

### Approach: Bubble Sort (Descending)

#### Thinking aloud

- Compare adjacent elements
- If left < right → swap
- Repeat passes until sorted

#### Code

```js
function sortArrayDesc(arr) {
  let n = arr.length;

  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] < arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }

  return arr;
}

console.log(sortArrayDesc([5, 3, 8, 1]));
```

#### Complexity

- Time: **O(n²)**
- Space: **O(1)**

#### Interview Notes

- Simple bubble sort logic
- Inefficient for large data
- Built-in `sort()` with comparator is better for production
