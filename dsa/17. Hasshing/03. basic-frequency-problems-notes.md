# HASHING – PROBLEM 1

## Count Frequency of Array Elements

### Problem

You are given an array:

```
[1, 2, 1, 3, 2]
```

You must find how many times each number appears.

Expected result:

```
1 → 2 times  
2 → 2 times  
3 → 1 time
```

---

## 1. Concept

Frequency = How many times an element occurs in the array.

Instead of scanning the array again and again, we:

* Store the count of each element once.
* Reuse it whenever needed.

This is where **hashing (frequency table)** is used.

---

## 2. Intuition (How a good DSA mind thinks)

Ask yourself:

* “Am I repeating work?”
* “Can I store results to reuse instead of recalculating?”

Instead of:

```
For every element → scan whole array ❌
```

We do:

```
Scan once → store counts → reuse ✅
```

Key idea:

> Trade a little memory for massive speed.

---

## 3. DSA Problem Solving Mindset

We need:

1. A structure that can store counts.
2. A way to access any element fast.

So we choose:

* unordered_map (best for large or unknown ranges)
* array hash (only when range is small)

Here we will use unordered_map because it generalises better.

---

## 4. Approach

Step-by-step:

1. Create an empty hash map `freq`
2. Traverse the array
3. For each element `x`:

   * Do freq[x]++
4. Now freq contains frequency of every number

---

## 5. Algorithm

```
Create map freq

For each element x in array:
    freq[x] = freq[x] + 1

For each key-value pair in freq:
    print key and its frequency
```

---

## 6. Pseudocode (Before real code)

```
function countFrequency(array):
    create empty map freq

    for i from 0 to n-1:
        freq[array[i]]++

    for each element in freq:
        print element and freq[element]
```

---

## 7. Dry Run (Very Important)

Array:

```
[1, 2, 1, 3, 2]
```

Initial:

```
freq = {}
```

Step-by-step:

i = 0 → value = 1
freq = {1:1}

i = 1 → value = 2
freq = {1:1, 2:1}

i = 2 → value = 1
freq = {1:2, 2:1}

i = 3 → value = 3
freq = {1:2, 2:1, 3:1}

i = 4 → value = 2
freq = {1:2, 2:2, 3:1}

Final Hash Table:

```
1 → 2
2 → 2
3 → 1
```

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem: Count frequency of each element in array
Approach: Use hashing with unordered_map
Time Complexity: O(N)
Space Complexity: O(N)
*/

void countFrequency(vector<int> &arr)
{
    unordered_map<int, int> freq; // stores element -> frequency

    // Step 1: Pre-store frequencies
    for(int i = 0; i < arr.size(); i++)
    {
        freq[arr[i]]++;  // increment count
    }

    // Step 2: Print results
    for(auto it : freq)
    {
        cout << it.first << " -> " << it.second << endl;
    }
}

int main()
{
    vector<int> arr = {1, 2, 1, 3, 2};

    countFrequency(arr);

    return 0;
}
```

---

## 9. Output

```
1 -> 2
2 -> 2
3 -> 1
```

---

## 10. Important Notes

• This pattern is the foundation of almost ALL hashing problems
• Converts O(N²) problems into O(N)
• Used in:

* Counting characters
* Finding duplicates
* Anagrams
* Subarray sum problems
* Sliding window problems

---

## Key Thinking Habit

When you see:

> “How many times…?”
> Your brain should instantly think:
> HASHING

---

# HASHING – PROBLEM 2

## Find the Element with HIGHEST Frequency

---

### Problem

Given an array:

```
[1, 2, 1, 3, 2, 2, 4]
```

You must find:

* The element that appears the MOST times
* And its frequency

Expected:

```
Element = 2  
Frequency = 3
```

---

## 1. Concept

This problem is a direct extension of **frequency counting**.

We already know how to build:

```
element → frequency
```

Now we add one more logic:

> Track the maximum frequency while iterating over the hash table.

So the problem becomes:

* Build frequency map
* Find maximum value in that map

---

## 2. Intuition (How DSA mind thinks)

Ask:

* "I already know how many times each element appears."
* "Now I just need the biggest one."

So instead of sorting or rechecking array, we:

1. Store all frequencies once.
2. Compare them to find the largest.

No repeated scanning. No brute force.

---

## 3. DSA Mindset

This problem has two layers:

Layer 1:

* Convert array → frequency table

Layer 2:

* Scan frequency table → find max

This teaches an important pattern:

> Preprocess → then analyse result

Almost every advanced DSA question follows this logic.

---

## 4. Approach

Steps:

1. Create unordered_map freq
2. Traverse array and store counts
3. Initialize:

   * maxFreq = 0
   * maxElement = -1
4. Iterate through map:

   * If current frequency > maxFreq
     update both

---

## 5. Algorithm

```
Create freq map

For each element in array:
    freq[element]++

maxFreq = 0
maxElement = -1

For each (key, value) in freq:
    if value > maxFreq:
        maxFreq = value
        maxElement = key

Print maxElement and maxFreq
```

---

## 6. Pseudocode

```
function highestFrequency(arr):

    freq = empty map

    for each x in arr:
        freq[x]++

    maxFreq = 0
    maxElement = -1

    for each element in freq:
        if freq[element] > maxFreq:
            maxFreq = freq[element]
            maxElement = element

    return maxElement, maxFreq
```

---

## 7. Dry Run

Array:

```
[1, 2, 1, 3, 2, 2, 4]
```

Frequency map after preprocessing:

```
1 → 2  
2 → 3  
3 → 1  
4 → 1
```

Now scanning:

Start:

```
maxFreq = 0
maxElement = -1
```

Check 1 → 2
2 > 0 → update
maxFreq = 2, maxElement = 1

Check 2 → 3
3 > 2 → update
maxFreq = 3, maxElement = 2

Check 3 → 1
ignore

Check 4 → 1
ignore

Final result:

```
Element = 2  
Frequency = 3
```

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : Find the element with highest frequency
Approach: Hashing + maximum comparison
TC      : O(N)
SC      : O(N)
*/

pair<int,int> highestFrequency(vector<int> &arr)
{
    unordered_map<int, int> freq;

    // Step 1: Build frequency table
    for(int x : arr)
        freq[x]++;

    int maxFreq = 0;
    int maxElement = -1;

    // Step 2: Find highest frequency
    for(auto it : freq)
    {
        if(it.second > maxFreq)
        {
            maxFreq = it.second;
            maxElement = it.first;
        }
    }

    return {maxElement, maxFreq};
}

int main()
{
    vector<int> arr = {1, 2, 1, 3, 2, 2, 4};

    auto result = highestFrequency(arr);

    cout << "Element with highest frequency: " << result.first << endl;
    cout << "Frequency: " << result.second << endl;

    return 0;
}
```

---

## 9. Output

```
Element with highest frequency: 2
Frequency: 3
```

---

## 10. Important Notes

* If multiple elements have same highest frequency:

  * Current code returns the first found
* Can be modified to handle ties if required
* This pattern is used in:

  * Mode of array
  * Voting systems
  * Majority element problems

---

## DSA Thinking Upgrade

You just learned:

> Frequency table → Maximum search
> This is one of the most reusable mental patterns in DSA.

---

# HASHING – PROBLEM 3

## Find the Element with LOWEST Frequency

---

### Problem

Given an array:

```
[1, 2, 1, 3, 2, 2, 4]
```

You must find:

* The element that appears the LEAST times
* And its frequency

Expected Output:

```
Element = 3 (or 4)  
Frequency = 1
```

(Because both 3 and 4 appear once. Our logic will return the first found.)

---

## 1. Concept

This is the reverse of the previous problem.

Earlier:

* We searched for MAX frequency

Now:

* We search for MIN frequency

Same base structure:

```
element → frequency
```

Only the comparison changes.

---

## 2. Intuition (DSA Thinking)

We already know:

* How many times each element appears.

So the thinking is:

> From all frequencies, pick the smallest one.

So logically:

* Instead of looking for greater (`>`)
* We now look for smaller (`<`)

---

## 3. DSA Mindset

Always build frequency map FIRST.
Then ask:

* Which condition do I want?

  * Highest?
  * Lowest?
  * Exactly k times?
  * More than k?

Same tool, different logic.

---

## 4. Approach

Steps:

1. Create unordered_map freq
2. Store frequencies
3. Initialise:

   * minFreq = INT_MAX
   * minElement = -1
4. Traverse map:

   * If current frequency < minFreq
     update both

---

## 5. Algorithm

```
Create freq map

For each element x in array:
    freq[x]++

minFreq = infinity
minElement = -1

For each (key, value) in freq:
    if value < minFreq:
        minFreq = value
        minElement = key

Print minElement and minFreq
```

---

## 6. Pseudocode

```
function lowestFrequency(arr):

    create empty map freq

    for each x in arr:
        freq[x]++

    minFreq = very_large_number
    minElement = -1

    for each element in freq:
        if freq[element] < minFreq:
            minFreq = freq[element]
            minElement = element

    return minElement, minFreq
```

---

## 7. Dry Run

Array:

```
[1, 2, 1, 3, 2, 2, 4]
```

Frequency Map:

```
1 → 2  
2 → 3  
3 → 1  
4 → 1
```

Initial:

```
minFreq = infinity
minElement = -1
```

Check 1 → 2
2 < infinity → update
minFreq = 2, minElement = 1

Check 2 → 3
ignore

Check 3 → 1
1 < 2 → update
minFreq = 1, minElement = 3

Check 4 → 1
1 < 1 ❌ (not smaller) → ignore

Final result:

```
Element = 3  
Frequency = 1
```

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : Find element with lowest frequency
Approach: Hashing + minimum comparison
TC      : O(N)
SC      : O(N)
*/

pair<int,int> lowestFrequency(vector<int> &arr)
{
    unordered_map<int, int> freq;

    // Step 1: build frequency table
    for(int x : arr)
        freq[x]++;

    int minFreq = INT_MAX;
    int minElement = -1;

    // Step 2: find lowest frequency
    for(auto it : freq)
    {
        if(it.second < minFreq)
        {
            minFreq = it.second;
            minElement = it.first;
        }
    }

    return {minElement, minFreq};
}

int main()
{
    vector<int> arr = {1, 2, 1, 3, 2, 2, 4};

    auto result = lowestFrequency(arr);

    cout << "Element with lowest frequency: " << result.first << endl;
    cout << "Frequency: " << result.second << endl;

    return 0;
}
```

---

## 9. Output

```
Element with lowest frequency: 3
Frequency: 1
```

---

## 10. Important Notes

• If multiple elements share lowest frequency → first encountered is returned
• Can be modified to return all such elements
• Very common interview follow-up after highest frequency

---

## Pattern You Are Building

You now fully understand this core trio:

1. Count frequencies
2. Find highest frequency
3. Find lowest frequency

This trio forms the base for:

* Mode problems
* Majority element
* Top K frequent elements
* Grouping problems

---

# HASHING – PROBLEM 4

## First Non-Repeating Element in Array

---

### Problem

Given an array:

```
[4, 5, 1, 2, 0, 4, 1, 2]
```

Find the **first element that appears exactly once**.

Expected Output:

```
5
```

Because:

* 4 → repeated
* 5 → appears once ✅ (first such element)

---

## 1. Concept

A **non-repeating element** is one whose frequency = 1.

But here the tricky part is:

> We must return the FIRST such element in original order.

So this problem has two requirements:

1. Frequency logic (hashing)
2. Order preservation (array traversal)

---

## 2. Intuition (DSA Thinking)

Ask yourself:

* “Which elements are unique?”
* “But also, which one comes first?”

So we:

1. Count all frequencies using hashing.
2. Traverse the array again in order.
3. The first element with frequency 1 is our answer.

This is a classic two-pass hashing pattern.

---

## 3. DSA Mindset

When problem says:

> “First” / “Leftmost” / “Order matters”

Always think:

* I must traverse the original structure again.

So structure:

```
Array -> Frequency Map
Array again -> Check condition
```

---

## 4. Approach

Steps:

1. Build frequency map using unordered_map
2. Traverse array from left to right
3. If freq[arr[i]] == 1
   return arr[i]

---

## 5. Algorithm

```
Create empty map freq

For each element x in array:
    freq[x]++

For each element x in array (left to right):
    if freq[x] == 1:
        print x
        break
```

---

## 6. Pseudocode

```
function firstNonRepeating(arr):

    freq = empty map

    for each x in arr:
        freq[x]++

    for each x in arr:
        if freq[x] == 1:
            return x

    return -1  // if none exists
```

---

## 7. Dry Run

Array:

```
[4, 5, 1, 2, 0, 4, 1, 2]
```

Frequency map after preprocessing:

```
4 → 2  
5 → 1  
1 → 2  
2 → 2  
0 → 1
```

Now second traversal:

Check 4 → freq = 2 ❌
Check 5 → freq = 1 ✅ ← STOP

Answer:

```
5
```

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : First non-repeating element
Approach: Hashing + order traversal
TC      : O(N)
SC      : O(N)
*/

int firstNonRepeating(vector<int> &arr)
{
    unordered_map<int, int> freq;

    // Step 1: Count frequencies
    for(int x : arr)
        freq[x]++;

    // Step 2: Find first element with freq = 1
    for(int x : arr)
    {
        if(freq[x] == 1)
            return x;
    }

    return -1; // if no unique element exists
}

int main()
{
    vector<int> arr = {4, 5, 1, 2, 0, 4, 1, 2};

    int result = firstNonRepeating(arr);

    cout << "First non-repeating element: " << result << endl;

    return 0;
}
```

---

## 9. Output

```
First non-repeating element: 5
```

---

## 10. Important Notes

• Requires two passes — this is intentional
• Single pass cannot preserve proper order reliably
• Very common interview problem
• Used in stream processing and queue problems

---

## DSA Pattern You Just Learned

This is powerful:

```
Frequency + Original Order = First Unique
```

This same logic will reappear in:

* First unique character in string
* Data stream problems
* Queue based interview tasks

---

# HASHING – PROBLEM 5

## Remove Duplicates from Array (Preserve Order)

---

### Problem

Given an array:

```
[4, 5, 1, 2, 0, 4, 1, 2]
```

Remove all duplicate elements but **preserve the original order**.

Expected Output:

```
[4, 5, 1, 2, 0]
```

Because:

* 4 → keep first, remove rest
* 5 → unique
* 1 → keep first, remove rest
* 2 → keep first, remove rest
* 0 → unique

---

## 1. Concept

This problem mixes two ideas:

1. **Uniqueness** (remove duplicates)
2. **Order preservation**

So we need:

* A structure to remember what we've already seen
* Logic to only keep first occurrence

That structure?
✅ Hashing (unordered_set)

---

## 2. Intuition (DSA Thinking)

Ask yourself:

* "How do I know if I’ve seen this element before?"

Answer:

* Keep a record of visited elements.

So the logic becomes:

```
If seen before → skip  
If not seen → keep + mark as seen
```

---

## 3. DSA Mindset

This is a classic pattern:

```
Track seen → decide action
```

This pattern appears in:

* Duplicate removal
* Visited nodes in graphs
* Cycle detection
* Sliding window problems

---

## 4. Approach

Steps:

1. Create an unordered_set `seen`
2. Create result array `unique`
3. Traverse the original array:

   * If element NOT in seen:
     add it to unique
     insert it into seen

---

## 5. Algorithm

```
Create empty set seen
Create empty list result

For each x in array:
    if x not in seen:
        add x to result
        add x to seen

Return result
```

---

## 6. Pseudocode

```
function removeDuplicates(arr):

    seen = empty set
    result = empty list

    for each x in arr:
        if x not in seen:
            result.push(x)
            seen.insert(x)

    return result
```

---

## 7. Dry Run

Array:

```
[4, 5, 1, 2, 0, 4, 1, 2]
```

Initial:

```
seen = {}
result = []
```

Step-by-step:

x = 4 → not in seen
result = [4]
seen = {4}

x = 5 → not in seen
result = [4,5]
seen = {4,5}

x = 1 → not in seen
result = [4,5,1]
seen = {4,5,1}

x = 2 → not in seen
result = [4,5,1,2]
seen = {4,5,1,2}

x = 0 → not in seen
result = [4,5,1,2,0]
seen = {4,5,1,2,0}

x = 4 → already exists ❌
skip

x = 1 → already exists ❌
skip

x = 2 → already exists ❌
skip

Final result:

```
[4, 5, 1, 2, 0]
```

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : Remove duplicates from array while preserving order
Approach: Hash set to track visited elements
Time Complexity: O(N)
Space Complexity: O(N)
*/

vector<int> removeDuplicates(vector<int> &arr)
{
    unordered_set<int> seen;
    vector<int> result;

    for(int x : arr)
    {
        // If element not seen before
        if(seen.find(x) == seen.end())
        {
            result.push_back(x);
            seen.insert(x);
        }
    }

    return result;
}

int main()
{
    vector<int> arr = {4, 5, 1, 2, 0, 4, 1, 2};

    vector<int> uniqueArr = removeDuplicates(arr);

    cout << "Array after removing duplicates: ";
    for(int x : uniqueArr)
        cout << x << " ";

    return 0;
}
```

---

## 9. Output

```
Array after removing duplicates: 4 5 1 2 0
```

---

## 10. Important Notes

• preserves original order
• unordered_set ensures O(1) lookup
• If order not needed → set alone is enough
• This is core logic for many higher problems

---

## Mental Pattern You Just Learned

```
Tracking Seen + Conditional Insert = Uniqueness Control
```

This idea fuels:

* Unique string creation
* Removing duplicate characters
* First occurrence problems
* Data stream filters

---

# HASHING – PROBLEM 6

## Check if Two Arrays are Equal (Same Frequency)

---

### Problem

You are given two arrays:

```
A = [1, 2, 3, 2, 5]
B = [2, 1, 5, 2, 3]
```

Determine whether both arrays are **equal in frequency**, meaning:

* Every element appears the same number of times in both arrays.

This is the numeric version of the **anagram concept**.

Expected Output:

```
Yes, both arrays are equal
```

---

## 1. Concept

Two arrays are considered equal by hashing if:

* They contain the same elements
* With the same frequencies
* Order does NOT matter

So we are not comparing positions, we are comparing **distribution**.

---

## 2. Intuition (DSA Thinking)

Ask:

* “Do these two arrays represent the same multiset of elements?”

Instead of sorting or comparing directly:
We use hashing to count frequencies.

If both frequency maps match → arrays are equal.

---

## 3. DSA Mindset

This is a comparison problem using hashing.

Pattern:

```
Build freq(A)
Build freq(B)
Compare both maps
```

If even one element has different frequency → NOT equal.

---

## 4. Approach

Steps:

1. If size of A != size of B → return false
2. Create unordered_map freq
3. Increase frequency for all elements in A
4. Decrease frequency for all elements in B
5. If any value ≠ 0 → arrays are not equal

This is more efficient than building two maps.

---

## 5. Algorithm

```
if size(A) != size(B):
    return false

Create empty map freq

For each x in A:
    freq[x]++

For each x in B:
    freq[x]--

For each element in freq:
    if freq[element] != 0:
        return false

return true
```

---

## 6. Pseudocode

```
function areArraysEqual(A, B):

    if length(A) != length(B):
        return false

    create empty map freq

    for x in A:
        freq[x]++

    for x in B:
        freq[x]--

    for each key in freq:
        if freq[key] != 0:
            return false

    return true
```

---

## 7. Dry Run

A:

```
[1, 2, 3, 2, 5]
```

B:

```
[2, 1, 5, 2, 3]
```

After processing A:

```
1 → 1  
2 → 2  
3 → 1  
5 → 1
```

After processing B (decrement):

```
1 → 0  
2 → 0  
3 → 0  
5 → 0
```

Every value = 0 ✅
So arrays are equal.

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : Check if two arrays are equal by frequency
Approach: Single hash map difference method
TC      : O(N)
SC      : O(N)
*/

bool areArraysEqual(vector<int> &A, vector<int> &B)
{
    if(A.size() != B.size())
        return false;

    unordered_map<int, int> freq;

    // Count elements in A
    for(int x : A)
        freq[x]++;

    // Subtract elements in B
    for(int x : B)
        freq[x]--;

    // Check for mismatch
    for(auto it : freq)
    {
        if(it.second != 0)
            return false;
    }

    return true;
}

int main()
{
    vector<int> A = {1, 2, 3, 2, 5};
    vector<int> B = {2, 1, 5, 2, 3};

    if(areArraysEqual(A, B))
        cout << "Arrays are equal" << endl;
    else
        cout << "Arrays are NOT equal" << endl;

    return 0;
}
```

---

## 9. Output

```
Arrays are equal
```

---

## 10. Important Notes

• Order does not matter
• Uses balancing logic (+1 and -1)
• Foundation for:

* String Anagram problems
* Multiset comparison
* Permutation checks

---

## DSA Pattern Locked

```
Frequency matching = Structural equality (ignoring order)
```

This pattern appears heavily in:

* String manipulation
* Competitive programming
* Interview challenges

---

# HASHING – PROBLEM 7

## Check if Two Strings are Anagrams

---

### Problem

You are given two strings:

```
s1 = "listen"
s2 = "silent"
```

Check whether they are **anagrams**.

Definition:
Two strings are anagrams if:

* They contain the same characters
* With the same frequency
* Order does NOT matter

Expected Output:

```
Yes, they are anagrams
```

---

## 1. Concept

Anagram = Character frequency equality.

So the logic is identical to:
"Check if two arrays are equal by frequency"
But here the data type is characters instead of numbers.

So we are comparing:

```
frequency of each character in s1
vs
frequency of each character in s2
```

---

## 2. Intuition (DSA Thinking)

Ask:

* “Do these two words have the same letters?”
* “Just arranged differently?”

Instead of sorting (which costs O(n log n)), we use hashing which gives O(n).

Better performance, cleaner logic.

---

## 3. DSA Mindset

This is a classic interview pattern:

```
String comparison based on structure, not order
```

So the steps become:

1. Count characters of first string
2. Decrease using second string
3. Verify if all values become zero

---

## 4. Approach

Steps:

1. If lengths differ → not anagram
2. Create frequency array of size 26 (for lowercase)
3. Traverse s1 → increment freq
4. Traverse s2 → decrement freq
5. If any freq ≠ 0 → not anagram

---

## 5. Algorithm

```
if length(s1) != length(s2):
    return false

Create freq[26] = {0}

for each char c in s1:
    freq[c - 'a']++

for each char c in s2:
    freq[c - 'a']--

for i from 0 to 25:
    if freq[i] != 0:
        return false

return true
```

---

## 6. Pseudocode

```
function areAnagrams(s1, s2):

    if size(s1) != size(s2):
        return false

    freq = array[26] initialised to 0

    for each char in s1:
        freq[char - 'a']++

    for each char in s2:
        freq[char - 'a']--

    for each value in freq:
        if value != 0:
            return false

    return true
```

---

## 7. Dry Run

s1 = "listen"
s2 = "silent"

Frequency build from s1:

```
l → 1  
i → 1  
s → 1  
t → 1  
e → 1  
n → 1
```

After subtracting s2:

```
All values become 0 ✅
```

So strings are anagrams.

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : Check if two strings are anagrams
Approach: Character hashing
TC      : O(N)
SC      : O(1) [because fixed 26 size array]
*/

bool areAnagrams(string &s1, string &s2)
{
    if(s1.length() != s2.length())
        return false;

    int freq[26] = {0};

    // Count characters in s1
    for(char c : s1)
        freq[c - 'a']++;

    // Subtract characters of s2
    for(char c : s2)
        freq[c - 'a']--;

    // Check mismatch
    for(int i = 0; i < 26; i++)
    {
        if(freq[i] != 0)
            return false;
    }

    return true;
}

int main()
{
    string s1 = "listen";
    string s2 = "silent";

    if(areAnagrams(s1, s2))
        cout << "Strings are Anagrams" << endl;
    else
        cout << "Strings are NOT Anagrams" << endl;

    return 0;
}
```

---

## 9. Output

```
Strings are Anagrams
```

---

## 10. Important Notes

• This method works for lowercase only
• For mixed case or ASCII → use int freq[256]
• Much faster than sorting approach
• Core problem in interviews

---

## Pattern You Now Own

```
Frequency Matching = Anagram Detection
```

This pattern is reused in:

* Group Anagrams
* Substring problems
* Permutation checks

---

# HASHING – PROBLEM 8

## First Repeating Element in Array

---

### Problem

Given an array:

```
[10, 5, 3, 4, 3, 5, 6]
```

Find the **first element that repeats** (the one whose second occurrence appears first while scanning left to right).

Expected Output:

```
5
```

Why?

* 10 → appears once
* 5 → appears again later ✅ (this is the first repeating element encountered)
* 3 also repeats, but its repeat appears after 5’s repeat

---

## 1. Concept

Repeating element = frequency > 1
But this problem is not just about frequency, it is about **position of second occurrence**.

So we need:

* Hashing to track what we have seen
* Order logic to detect the first repeat

---

## 2. Intuition (DSA Thinking)

Your brain should ask:

* "When do I detect a repeat?"
* "The moment I see something already seen before."

So the key idea:

> The first repeating element is the first one that appears AGAIN.

That means:

* When scanning the array,
* If an element already exists in our hash → this is the answer.

---

## 3. DSA Mindset

Compare with first non-repeating:

| Problem             | Logic                               |
| ------------------- | ----------------------------------- |
| First Non-Repeating | Check freq == 1                     |
| First Repeating     | Detect when element is already seen |

So the tool changes from unordered_map to unordered_set.

---

## 4. Approach

Steps:

1. Create unordered_set `seen`
2. Traverse array left to right
3. If current element already exists in seen:
   return that element
4. Else insert it into seen

---

## 5. Algorithm

```
Create empty set seen

For each element x in array:
    if x in seen:
        return x
    else:
        seen.insert(x)

Return -1 if none repeats
```

---

## 6. Pseudocode

```
function firstRepeating(arr):

    seen = empty set

    for each x in arr:
        if x exists in seen:
            return x
        else:
            seen.insert(x)

    return -1
```

---

## 7. Dry Run

Array:

```
[10, 5, 3, 4, 3, 5, 6]
```

Initial:

```
seen = {}
```

x = 10 → not seen → insert
seen = {10}

x = 5 → not seen → insert
seen = {10, 5}

x = 3 → not seen → insert
seen = {10, 5, 3}

x = 4 → not seen → insert
seen = {10, 5, 3, 4}

x = 3 → already in seen ✅
STOP → Answer = 3?

But expected output was 5 earlier example? Let's clarify logic:

Actually, correct first repeating here:

```
Array: [10, 5, 3, 4, 3, 5, 6]
First element whose SECOND appearance occurs first = 3
```

So correct answer for this input is:

```
3
```

(5 also repeats, but 3 repeats earlier)

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : First repeating element
Approach: Hash set to track seen elements
TC      : O(N)
SC      : O(N)
*/

int firstRepeating(vector<int> &arr)
{
    unordered_set<int> seen;

    for(int x : arr)
    {
        // If already seen, it's the first repeating element
        if(seen.find(x) != seen.end())
            return x;

        seen.insert(x);
    }

    return -1; // if no repeating element exists
}

int main()
{
    vector<int> arr = {10, 5, 3, 4, 3, 5, 6};

    int result = firstRepeating(arr);

    cout << "First repeating element: " << result << endl;

    return 0;
}
```

---

## 9. Output

```
First repeating element: 3
```

---

## 10. Important Notes

• Detects repetition at the moment it occurs
• Order-sensitive problem
• Very efficient O(N)

---

## Pattern Learned

```
Seen before? → It's repeating
Not seen? → Mark as seen
```

This is a cornerstone logic in:

* Data validation
* Input sanitization
* Real-time duplicate detection

---

# HASHING – PROBLEM 9

## Count Number of Distinct Elements in an Array

---

### Problem

Given an array:

```
[10, 20, 20, 10, 30, 40, 40]
```

Find the **number of distinct (unique) elements**.

Expected Output:

```
4
```

Because the unique elements are:

```
{10, 20, 30, 40}
```

---

## 1. Concept

Distinct elements means:

* Count of values that appear at least once
* Duplicates should be ignored

So our goal is not frequency now, only uniqueness.

This naturally maps to:

> A structure that stores only unique values

Answer:
✅ Hash Set

---

## 2. Intuition (DSA Thinking)

Ask yourself:

* “How do I automatically remove duplicates?”
* “How do I ensure every value is counted only once?”

Set property:

> A set never stores duplicate values.

So:

* Insert everything into set
* The size of the set is the answer

---

## 3. DSA Mindset

When problem says:

* "How many unique?"
* "How many distinct?"

Your brain should instantly think:

```
Use SET
```

Because:

```
set = unique container
```

---

## 4. Approach

Steps:

1. Create unordered_set distinct
2. Traverse array
3. Insert every element into the set
4. Return distinct.size()

---

## 5. Algorithm

```
Create empty set distinct

For each x in array:
    distinct.insert(x)

Return size of distinct
```

---

## 6. Pseudocode

```
function countDistinct(arr):

    distinct = empty set

    for each x in arr:
        distinct.insert(x)

    return size of distinct
```

---

## 7. Dry Run

Array:

```
[10, 20, 20, 10, 30, 40, 40]
```

Initial:

```
set = {}
```

Insert 10 → {10}
Insert 20 → {10,20}
Insert 20 → ignored
Insert 10 → ignored
Insert 30 → {10,20,30}
Insert 40 → {10,20,30,40}
Insert 40 → ignored

Final size = 4 ✅

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : Count distinct elements in array
Approach: Use unordered_set
Time Complexity: O(N)
Space Complexity: O(N)
*/

int countDistinct(vector<int> &arr)
{
    unordered_set<int> distinct;

    for(int x : arr)
        distinct.insert(x);

    return distinct.size();
}

int main()
{
    vector<int> arr = {10, 20, 20, 10, 30, 40, 40};

    cout << "Number of distinct elements: "
         << countDistinct(arr) << endl;

    return 0;
}
```

---

## 9. Output

```
Number of distinct elements: 4
```

---

## 10. Important Notes

• Order does not matter
• Uses set's property of uniqueness
• Faster than nested loops
• Foundation for:

* Unique element problems
* Duplicate removal
* Set based questions

---

## Pattern You Just Learned

```
Distinct count = Size of Set
```

This is one of the most fundamental hashing applications.

---

# HASHING – PROBLEM 10

## Find Elements that Appear Exactly K Times

---

### Problem

Given an array:

```
[1, 2, 2, 3, 3, 3, 4, 4, 5]
```

And a number:

```
K = 2
```

Find all elements that appear **exactly K times**.

Expected Output:

```
2 4
```

Because:

* 2 → appears 2 times ✅
* 4 → appears 2 times ✅
* Others do not match exactly K.

---

## 1. Concept

This is no longer just:

* highest frequency
* lowest frequency

Now the condition is:

```
frequency == K
```

So again:

1. Build frequency map
2. Filter elements based on a condition

---

## 2. Intuition (DSA Thinking)

Ask:

* “I already know how to count frequency.”
* “Now I just filter based on my requirement.”

So the mental model:

> Hashing + condition based selection

This single idea solves MANY interview problems.

---

## 3. DSA Mindset

This teaches an important habit:

Instead of writing different logic for:

* exactly 1 time
* exactly 2 times
* more than 3 times

You write:

```
if freq[x] == K
```

Generic. Reusable. Clean.

---

## 4. Approach

Steps:

1. Build unordered_map freq
2. Traverse freq map
3. If freq[element] == K → add to result

---

## 5. Algorithm

```
Create freq map

For each element x in array:
    freq[x]++

Create empty list result

For each (key, value) in freq:
    if value == K:
        add key to result

Return result
```

---

## 6. Pseudocode

```
function elementsExactlyK(arr, K):

    freq = empty map
    result = empty list

    for each x in arr:
        freq[x]++

    for each element in freq:
        if freq[element] == K:
            result.push(element)

    return result
```

---

## 7. Dry Run

Array:

```
[1, 2, 2, 3, 3, 3, 4, 4, 5]
K = 2
```

Frequency Map:

```
1 → 1  
2 → 2 ✅  
3 → 3  
4 → 2 ✅  
5 → 1
```

Elements with freq = 2:

```
2, 4
```

---

## 8. C++ Code (Clean + Commented)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
Problem : Find elements appearing exactly K times
Approach: Hashing + conditional filtering
TC      : O(N)
SC      : O(N)
*/

vector<int> elementsExactlyK(vector<int> &arr, int K)
{
    unordered_map<int, int> freq;
    vector<int> result;

    // Step 1: build frequency table
    for(int x : arr)
        freq[x]++;

    // Step 2: check condition
    for(auto it : freq)
    {
        if(it.second == K)
            result.push_back(it.first);
    }

    return result;
}

int main()
{
    vector<int> arr = {1, 2, 2, 3, 3, 3, 4, 4, 5};
    int K = 2;

    vector<int> ans = elementsExactlyK(arr, K);

    cout << "Elements appearing exactly " << K << " times: ";
    for(int x : ans)
        cout << x << " ";

    return 0;
}
```

---

## 9. Output

```
Elements appearing exactly 2 times: 2 4
```

---

## 10. Important Notes

• Works for any value of K
• If no element satisfies → result will be empty
• Often used in:

* Top K problems
* Frequency filtering
* Competitive programming

---

## Key Pattern Now Locked

```
Frequency + Condition = Targeted Filtering
```

You can now easily solve:

* Appears at least K times
* Appears at most K times
* Appears more than K times

---