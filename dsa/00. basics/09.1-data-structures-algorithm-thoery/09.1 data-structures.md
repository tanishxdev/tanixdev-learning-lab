# DATA STRUCTURES — COMPLETE FOUNDATION (BASICS → ADVANCED)

This is the **core theory layer** behind:

* DSA
* Competitive programming
* Interviews
* System design

---

## 1. What is Data? (Absolute Start)

**Data** is any form of information.

Examples:

* Number → `10`
* Character → `'a'`
* Text → `"hello"`
* Collection → `[1, 2, 3]`
* Record → `{id: 1, name: "A"}`

But raw data alone is:

* Disorganized
* Hard to search
* Hard to update

So the real problem is **not data**, but **how data is stored and used**.

---

## 2. What is a Data Structure?

A **Data Structure** is:

> A systematic way to **store data** so that operations on it are **efficient, safe, and scalable**.

Operations always include:

* Insert
* Delete
* Search
* Update
* Traverse

Core idea:

```
Data Structure = Data + Organization + Operations
```

---

## 3. Why Data Structures Exist (Real Reason)

### Think like this:

You never ask:

> “Which data structure is best?”

You ask:

> “What operation do I need to optimize?”

Examples:

* Google search → fast lookup
* Undo feature → last operation
* Navigation app → shortest path
* Database → sorted + searchable data

Each need **different data organization**.

---

## 4. Core Tradeoff (Very Important)

Every data structure balances:

* Time
* Space
* Simplicity

You **cannot optimize everything at once**.

This is why **multiple data structures exist**.

---

## 5. High-Level Classification

```
Data Structures
├── Primitive
└── Non-Primitive
```

---

## 6. Primitive Data Structures

Store **single values**.

Examples:

* int
* char
* float
* bool

Characteristics:

* Fixed size
* No internal structure
* Fast

They are **building blocks**, not solutions to complex problems.

---

## 7. Non-Primitive Data Structures

Store **multiple values** and relationships.

```
Non-Primitive
├── Linear
└── Non-Linear
```

This division is **very important**.

---

## 8. Linear Data Structures (Sequential)

Data elements are arranged **one after another**.

```
Linear DS = One path of traversal
```

Examples:

* Array
* Linked List
* Stack
* Queue
* Deque

---

## 9. Array (Foundation of Everything)

### What

* Fixed-size collection
* Stored in **contiguous memory**

### Why

* Fastest possible access

### How

```
arr[i] = base_address + i * size
```

### Strengths

* O(1) access
* Cache-friendly
* Simple

### Weaknesses

* Fixed size
* Costly insert/delete

### Used when

* Index-based access matters
* Size is known
* Performance is critical

---

## 10. Dynamic Array (Vector)

This is still an **array**, but smarter.

* Grows automatically
* Copies data when capacity is full

Tradeoff:

* Amortized O(1) insertion
* Extra memory

Used almost everywhere in C++.

---

## 11. Linked List

### What

* Nodes connected via pointers
* Memory is scattered

### Why

* Dynamic size
* Easy insert/delete

### Structure

```
[data | next]
```

Variants:

* Singly Linked List
* Doubly Linked List
* Circular Linked List

### Tradeoff

* O(N) access
* Extra pointer memory

Used when:

* Frequent insert/delete
* No need for random access

---

## 12. Stack (LIFO)

### Core Rule

```
Last In, First Out
```

### Think of:

* Function calls
* Undo operations
* Backtracking

### Operations

* push
* pop
* top

### Implemented using:

* Array
* Linked List

---

## 13. Queue (FIFO)

### Core Rule

```
First In, First Out
```

### Used in:

* Scheduling
* BFS
* Real-time systems

### Variants

* Simple Queue
* Circular Queue
* Deque (double-ended queue)
* Priority Queue

---

## 14. Priority Queue (Heap)

This is **NOT** normal queue.

### Rule

* Highest priority element comes first

### Implemented using:

* Heap (Binary Heap)

### Operations

* insert → O(log N)
* extract-max/min → O(log N)

Used in:

* Scheduling
* Dijkstra
* Top K problems

---

## 15. Non-Linear Data Structures

Data is **not sequential**.

```
Non-Linear
├── Tree
└── Graph
```

Used to represent **hierarchies and networks**.

---

## 16. Tree (Hierarchical Data)

### What

* Parent → child relationship
* No cycles

### Common Types

* Binary Tree
* Binary Search Tree (BST)
* Heap
* Trie
* Segment Tree

### Why Trees Exist

* Faster search than arrays
* Ordered structure
* Hierarchical modeling

---

## 17. Binary Search Tree (BST)

### Property

```
Left < Root < Right
```

### Operations

* Insert/Search/Delete → O(log N) average
* Worst case → O(N)

Balanced BSTs exist to fix this.

---

## 18. Balanced Trees (Advanced)

To avoid skewed trees:

Examples:

* AVL Tree
* Red-Black Tree

Used internally by:

* `map`
* `set`

Guarantee:

```
O(log N) in all cases
```

---

## 19. Heap (Special Tree)

### Property

* Max Heap → parent ≥ children
* Min Heap → parent ≤ children

### Not sorted

### Only top element is guaranteed

Used in:

* Priority Queue
* Scheduling
* Top K problems

---

## 20. Trie (Prefix Tree)

### Used for:

* Dictionary
* Autocomplete
* Prefix search

### Strength

* Search time depends on word length, not size

---

## 21. Graph (Network Structure)

### What

* Nodes + edges

### Types

* Directed / Undirected
* Weighted / Unweighted
* Cyclic / Acyclic

### Traversals

* BFS
* DFS

Used in:

* Maps
* Social networks
* Dependencies
* Pathfinding

---

## 22. Hashing (Fast Lookup Structure)

### Core Idea

```
Key → Hash Function → Index
```

### Strength

* Average O(1)

### Weakness

* Collisions
* No order

Structures:

* unordered_map
* unordered_set

---

## 23. Collision Handling (Conceptual)

Because:

* Infinite keys
* Finite table

Solutions:

* Chaining
* Open addressing

Handled internally in STL.

---

## 24. Abstract Data Types (ADT)

ADT defines:

* What operations are allowed
* Not how they are implemented

Examples:

* Stack
* Queue
* Map
* Set

Multiple implementations possible.

---

## 25. Advanced / Specialized Structures

These are **built using basics**:

* Segment Tree → Tree
* Fenwick Tree → Tree + array
* Disjoint Set (DSU) → Array + tree logic
* LRU Cache → Hash Map + Doubly Linked List

No new category. Just **composition**.

---

## 26. How Experts Choose Data Structures

They think like this:

```
What operations dominate?
What is input size?
Is ordering required?
Is memory tight?
```

Then choose.

---

## 27. Master Mental Model (MOST IMPORTANT)

```
Problem
↓
Operations
↓
Constraints
↓
Data Structure
↓
Algorithm
```

This is the **DSA mindset**.

---

## 28. One-Paragraph Summary


Data Structures are systematic ways to store and organize data so that operations like search, insert, delete, and update can be performed efficiently. Different problems demand different tradeoffs between time, space, order, and flexibility, which is why no single data structure fits all cases. Mastery of data structures is not about memorizing them, but about understanding **why a structure exists, what problem it solves, and when it should be chosen over others**. All advanced data structures are built by combining a small set of core ideas: arrays, pointers, trees, graphs, and hashing.

---

### High-Level Classification Table

| Category      | Description            | Examples                 |
| ------------- | ---------------------- | ------------------------ |
| Primitive     | Stores single values   | int, char, float, bool   |
| Non-Primitive | Stores multiple values | Array, List, Tree, Graph |

---

### Non-Primitive Data Structures Breakdown

| Type       | Arrangement            | Examples                         | Core Use                  |
| ---------- | ---------------------- | -------------------------------- | ------------------------- |
| Linear     | Sequential             | Array, Linked List, Stack, Queue | Ordered processing        |
| Non-Linear | Hierarchical / Network | Tree, Graph                      | Relationships & hierarchy |

---

### Linear Data Structures Comparison

| Structure   | Access | Insert/Delete  | Size    | Use When               |
| ----------- | ------ | -------------- | ------- | ---------------------- |
| Array       | O(1)   | O(N)           | Fixed   | Fast indexed access    |
| Vector      | O(1)   | Amortized O(1) | Dynamic | General purpose        |
| Linked List | O(N)   | O(1)           | Dynamic | Frequent insert/delete |
| Stack       | O(1)   | O(1)           | Dynamic | LIFO logic             |
| Queue       | O(1)   | O(1)           | Dynamic | FIFO logic             |

---

### Non-Linear Data Structures Comparison

| Structure | Core Property       | Strength              | Used For     |
| --------- | ------------------- | --------------------- | ------------ |
| Tree      | Hierarchical        | Ordered search        | Files, DBs   |
| BST       | Left < Root < Right | Fast search           | Sorted data  |
| Heap      | Priority-based      | Fast max/min          | Scheduling   |
| Trie      | Prefix-based        | Fast string ops       | Autocomplete |
| Graph     | Nodes + edges       | Relationship modeling | Networks     |

---

### Abstract Data Types (ADT)

| ADT   | Defines         | Implementation Examples |
| ----- | --------------- | ----------------------- |
| Stack | LIFO behavior   | Array, Linked List      |
| Queue | FIFO behavior   | Array, Deque            |
| Map   | Key-value ops   | map, unordered_map      |
| Set   | Unique elements | set, unordered_set      |

---

### Advanced Structures → Built From Basics

| Advanced Structure | Built Using                   |
| ------------------ | ----------------------------- |
| Segment Tree       | Tree + Array                  |
| Fenwick Tree       | Tree + Array                  |
| DSU                | Array + Tree logic            |
| LRU Cache          | Hash Map + Doubly Linked List |

Key idea:
**No advanced structure is new — all are compositions.**

---

### One-Line Decision Chart (MOST IMPORTANT)

```
Problem → Required Operations → Constraints → Data Structure → Algorithm
```

---

### Final Takeaway

* Data structures are tools, not answers
* Choosing the right one is a reasoning skill
* Advanced DSA = smart combinations of basics
* If you understand **why**, implementation becomes easy
