# ALGORITHMS — FROM ABSOLUTE BASICS (CLEAN & CORRECT)

This section explains:

* What algorithms really are
* How they are classified **properly**
* Where *brute / better / optimal* actually fit
* How to think like a DSA problem solver

---

## 1. What Is an Algorithm? (True Definition)

An **algorithm** is:

> A **finite sequence of unambiguous steps** that transforms input into output and **guarantees termination**.

In simple words:

```
Algorithm = Clear + Correct + Finite steps to solve a problem
```

Key points (very important):

* Language independent
* Logic first, code later
* Must always finish

---

## 2. What an Algorithm Is NOT

An algorithm is **NOT**:

* C++ code
* A loop
* A trick
* A library function

Code is only an **implementation** of an algorithm.

---

## 3. Why Algorithms Exist (Correct Reason)

Because:

* Computers are fast
* But **not infinite**
* And **resources are limited**

So we need:

* Correctness
* Efficiency
* Scalability

That is the **only reason algorithms exist**.

---

## 4. Relationship: Data Structure vs Algorithm

This must be crystal clear:

| Role           | Answers               |
| -------------- | --------------------- |
| Data Structure | How data is stored    |
| Algorithm      | How data is processed |

Real rule:

```
Every problem = Data Structure + Algorithm
```

Neither works alone.

---

## 5. Algorithm vs Optimization Level (IMPORTANT DISTINCTION)

Now we fix the confusion.

### ❌ WRONG THINKING

> Brute force is an algorithm
> Optimal is an algorithm

### ✅ CORRECT THINKING

> Brute / Better / Optimal are **levels of efficiency**, not algorithm types

Example:

* Sorting is an algorithmic problem
* Bubble Sort, Merge Sort are algorithms
* O(N²) vs O(N log N) is **efficiency**, not category

---

## 6. Then What Are “Brute / Better / Optimal”?

They describe **how much thinking has been applied**, not *what* algorithm it is.

| Term        | Meaning                          |
| ----------- | -------------------------------- |
| Brute Force | Straightforward, no optimization |
| Better      | Partial optimization             |
| Optimal     | Best known solution              |

They exist in **every paradigm**.

Example:

* Brute force DP
* Optimized DP
* Optimal DP

So never call them algorithm types.

---

## 7. Proper Classification of Algorithms (FORMAL)

Algorithms are classified by **how they solve problems**, not by speed.

### The REAL algorithm categories:

```
Algorithm Paradigms
├── Iterative
├── Recursive
├── Divide and Conquer
├── Greedy
├── Dynamic Programming
├── Backtracking
├── Graph Algorithms
├── Randomized Algorithms
```

This is the **correct list**.

---

## 8. Iterative Algorithms

### Definition

Algorithms that use **loops** to repeat steps.

### Characteristics

* Uses for / while
* No function self-calls
* Low memory

### Example Problems

* Linear search
* Iterative binary search
* Prefix sum loops

Used when:

* Logic is sequential
* No recursive structure

---

## 9. Recursive Algorithms

### Definition

Algorithms that solve a problem by calling themselves on smaller input.

### Key rule

```
Problem(n) → Problem(n-1)
```

### Requirements

* Base case
* Recursive relation

### Examples

* Factorial
* Tree traversal
* DFS

Recursion is a **technique**, not a category of problems.

---

## 10. Divide and Conquer (FORMAL PARADIGM)

### Definition

Split problem → solve subproblems → combine results

### Core structure

```
Divide
↓
Conquer
↓
Combine
```

### Examples

* Merge Sort
* Quick Sort
* Binary Search

This is a **true algorithm paradigm**.

---

## 11. Greedy Algorithms (FORMAL PARADIGM)

### Definition

Make the **best local choice**, hoping it leads to global optimum.

### Key property

```
Local optimal → Global optimal
```

### When it works

* Problem has greedy-choice property

### Examples

* Activity selection
* Minimum coins (not always)
* Interval scheduling

Greedy is **fast**, but **not always correct**.

---

## 12. Dynamic Programming (FORMAL PARADIGM)

### Why DP Exists

Because recursion can repeat work.

DP applies when:

1. Overlapping subproblems
2. Optimal substructure

### Core idea

```
Store results → reuse later
```

### Examples

* Fibonacci
* Knapsack
* LIS

DP is **optimized recursion**.

---

## 13. Backtracking (FORMAL PARADIGM)

### Definition

Explore all possibilities, but **undo choices when invalid**.

### Pattern

```
Choose
Explore
Un-choose
```

### Examples

* N-Queens
* Sudoku
* Permutations

Used when:

* Search space is large
* Constraints prune possibilities

---

## 14. Graph Algorithms (DOMAIN-SPECIFIC)

Graphs introduce **special algorithms**, but still use paradigms above.

Examples:

* BFS → iterative / queue-based
* DFS → recursive / stack-based
* Dijkstra → greedy + heap
* Kruskal → greedy + DSU

Graph algorithms are **compositions**, not new paradigms.

---

## 15. Time Complexity (What It Really Means)

Time complexity describes:

> How runtime grows with input size

It does **NOT** measure:

* Actual seconds
* Machine speed

It measures **growth trend**.

---

## 16. Space Complexity (Correct Meaning)

Space complexity counts:

* Extra memory
* Recursion stack
* Auxiliary data structures

Not input size itself.

---

## 17. How “Brute → Optimal” Actually Fits

Now the correct placement:

```
Problem
↓
Choose algorithm paradigm
↓
Brute implementation
↓
Optimize
↓
Best possible solution
```

So optimization is a **phase**, not a category.

---

## 18. Correct Problem-Solving Mental Model

This is the **DSA mindset** you must keep:

```
Understand problem
↓
Identify structure (array, tree, graph)
↓
Identify paradigm (DP, greedy, etc.)
↓
Write brute logic
↓
Optimize
↓
Analyze complexity
↓
Code
```

---

## 19. Common Beginner Mistake (You Avoided It)

Mistake:

* Thinking brute/optimal are algorithms

Correct thinking:

* They are **levels of refinement**

You identified this — that’s a **senior-level realization**.

---

## 20. Final Truth (Very Important)

* Algorithms are **ways of thinking**
* Paradigms are **mental tools**
* Optimization is **experience**
* Coding is **translation**

If you get the thinking right, code becomes mechanical.

---