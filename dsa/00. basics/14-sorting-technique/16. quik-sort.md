
# QUICK SORT (Recursion Concept)

## 1. What is Quick Sort?

Quick Sort is a **divide and conquer** sorting algorithm.

Goal:

* Sort an array in **non-decreasing order**
* Do it **in-place** (no extra array)

Key idea:

* Pick one element (pivot)
* Place it at its **correct sorted position**
* Recursively sort the left and right parts

---

## 2. Three Core Steps of Quick Sort

### Step 1: Pivot Selection

* Choose a â€œpivotâ€ element
* Common choices:

  * First element
  * Last element
  * Random element

ðŸ‘‰ In this explanation, we **always choose the last element as pivot**

---

### Step 2: Partition

Rearrange the array such that:

* All elements **â‰¤ pivot** are on the left
* All elements **> pivot** are on the right
* Pivot reaches its **final correct index**

After partition:

* Pivot is **fixed forever**
* It will never move again

---

### Step 3: Recursive Calls

Apply the same process to:

* Left subarray
* Right subarray

This is where **recursion** comes in.

---

## 3. Recursion Story (Very Important)

We write:

```
quickSort(arr, low, high)
```

### Story inside the function:

1. **Base Case**

   ```
   if (low >= high) return;
   ```

   * One or zero elements
   * Already sorted

2. **Partition**

   ```
   pivotIndex = partition(arr, low, high)
   ```

   * Pivot reaches correct position

3. **Trust Recursion**

   ```
   quickSort(arr, low, pivotIndex - 1)
   quickSort(arr, pivotIndex + 1, high)
   ```

Thatâ€™s it.
Just **three steps**.

---

## 4. Why Partition Works

After partition:

* Pivot is at correct index
* All elements left of pivot are smaller
* All elements right of pivot are larger

So:

* Sorting left and right parts **cannot disturb pivot**
* Sorting happens safely **inside the same array**

This is why Quick Sort is **in-place**

---

## 5. Partition Logic (Derived, Not Memorized)

We use **Lomuto Partition Scheme**.

### Variables

* `pivot = arr[high]`
* `pi = low` â†’ assumed pivot position

### Logic

For `i = low â†’ high - 1`:

* If `arr[i] <= pivot`

  * Swap `arr[i]` and `arr[pi]`
  * Increment `pi`

After loop:

* Swap `arr[pi]` and `arr[high]`
* Return `pi`

Now pivot is at correct position.

---

## 6. Complete C++ Code (Clean + Commented)

```cpp
#include <iostream>
#include <vector>
using namespace std;

/*
Partition function
Places pivot at correct position
Returns pivot index
*/
int partition(vector<int>& arr, int low, int high)
{
    int pivot = arr[high];   // Pivot element
    int pi = low;            // Pivot index

    for (int i = low; i < high; i++)
    {
        if (arr[i] <= pivot)
        {
            swap(arr[i], arr[pi]);
            pi++;
        }
    }

    // Place pivot at its correct position
    swap(arr[pi], arr[high]);
    return pi;
}

/*
Quick Sort using recursion
*/
void quickSort(vector<int>& arr, int low, int high)
{
    // Base case
    if (low >= high)
        return;

    // Partition the array
    int pivotIndex = partition(arr, low, high);

    // Recursively sort left and right parts
    quickSort(arr, low, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, high);
}

int main()
{
    vector<int> arr = {8, 3, 2, 7, 9, 6, 4, 5};

    quickSort(arr, 0, arr.size() - 1);

    for (int x : arr)
        cout << x << " ";

    return 0;
}
```

---

## 7. Dry Run (Short)

Input:

```
[8, 3, 2, 7, 9, 6, 4, 5]
```

* Pivot = 5
* After partition:

```
[3, 2, 4, 5, 9, 6, 8, 7]
```

Pivot `5` fixed.

Recursive calls:

* Left: `[3,2,4]`
* Right: `[9,6,8,7]`

Same steps repeat.

---

## 8. Time Complexity

### Best Case

* Pivot divides array into two equal halves

```
O(n log n)
```

### Average Case

```
O(n log n)
```

### Worst Case

* Pivot always smallest or largest
* Array reduces by 1 each time

```
O(nÂ²)
```

---

## 9. Space Complexity

* No extra array â†’ **In-place**
* Recursion stack:

  * Best case: `O(log n)`
  * Worst case: `O(n)`

---

## 10. Key Interview Takeaways

* In-place sorting algorithm
* Faster than merge sort in practice
* Worst case can be avoided using random pivot
* Recursion depth depends on partition quality

---