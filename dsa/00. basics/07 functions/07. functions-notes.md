# TOPIC 7 – FUNCTIONS IN C++

## (Pass by Value & Pass by Reference – COMPLETE)

Functions make your code:
• Reusable
• Clean
• Modular
• Easy to debug

Without functions → large unmanageable programs.

## 1. What is a Function?

A function is a block of code that:

* Performs a specific task
* Can be called multiple times

### Real-life analogy:

Remote button → performs task when pressed
Function → performs task when called

---

## 2. Why Functions are Needed?

Without function:
Same code repeated again and again.

With function:
Write once → use everywhere.

Benefits:
• Code reuse
• Easy maintenance
• Structure
• Testing becomes easier

## 3. Basic Function Structure

```cpp
returnType functionName(parameters) {
    // logic
    return value;
}
```

### Example:

```cpp
int add(int a, int b) {
    return a + b;
}
```

Calling:

```cpp
int result = add(5, 3);
```

---

## 4. Types of Functions

1. Function with return & parameters
2. Function without return
3. Function without parameters

### Example Types:

```cpp
void greet() {
   cout << "Hello";
}

int square(int x){
   return x*x;
}
```

# 5. PASS BY VALUE

### Concept:

Copy of variable is passed to function, original remains unchanged.

Example:

```cpp
void change(int x) {
    x = 100;
}
```

Main:

```cpp
int a = 10;
change(a);
cout << a;
```

Output:

```
10
```

Because:
a is copied into x
Changes happen only on copy.

---

### Memory View:

```
a = 10
x = 10 (copy)

x changes → a unaffected
```

# 6. PASS BY REFERENCE

### Concept:

Actual variable is passed, changes reflect outside function.

Uses & symbol.

Example:

```cpp
void change(int &x) {
    x = 100;
}
```

Main:

```cpp
int a = 10;
change(a);
cout << a;
```

Output:

```
100
```

Because:
x is alias of a
Same memory location

---

### Memory View:

```
a -------\
          ---> same memory
x -------/
```

# 7. COMPARISON

| Pass by Value          | Pass by Reference |
| ---------------------- | ----------------- |
| Copy created           | No copy           |
| Safer                  | Faster            |
| Cannot modify original | Modifies original |
| Uses no &              | Uses &            |

# 8. DRY RUN EXAMPLE

### Code:

```cpp
void test(int x) {
    x = 50;
}

int main(){
  int a = 10;
  test(a);
  cout << a;
}
```

Dry Run:
a = 10
x = 10
x = 50
a unchanged
Output = 10

---

### Reference version:

```cpp
void test(int &x) {
    x = 50;
}
```

Now:
a = 10
x refers to a
x = 50
a becomes 50
Output = 50

# 9. Function Calling Process

Steps:

1. Function call occurs
2. Parameters transferred
3. Function executes
4. Return value sent back

---

## 10. Real Life Example

### Swap using pass by value (FAIL):

```cpp
void swap(int a, int b){
   int temp = a;
   a = b;
   b = temp;
}
```

a and b change only inside.

### Swap using pass by reference (WORKS):

```cpp
void swap(int &a, int &b){
   int temp = a;
   a = b;
   b = temp;
}
```

# 11. When to Use What?

Use pass by value when:
• No need to change original
• Safety important

Use pass by reference when:
• Need to modify value
• Large data to avoid copying

# MINI PRACTICE

1. Write function to square a number
2. Swap two variables using reference
3. Function to check even or odd
4. Function to find max of 2 numbers

# INTERVIEW QUICK POINTS

• Function = reusable block
• Pass by value = copy
• Pass by reference = original
• & symbol links to same memory
• Reference faster for large objects
