# Search Insert Position

---

### 1. Problem Statement

**English**:
Given a **sorted array** (non-decreasing order) and a target value `x`:

* If `x` exists → return its index
* If `x` does NOT exist → return the index where it should be **inserted**
  so that the array remains sorted.

**Hinglish**:
Agar `x` array mein hai → uska index return karo.
Agar nahi hai → batao `x` ko kahan insert karein taaki array sorted rahe.

**LeetCode**: [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)
**Key Insight**: This problem is **exactly the same as Lower Bound**.

---

### 2. Examples (Must Know)

| Example | Array           | x  | Answer | Why                 |
| ------- | --------------- | -- | ------ | ------------------- |
| 1       | `[2,4,7,10,15]` | 7  | 2      | already present     |
| 2       | `[2,4,7,10,15]` | 9  | 3      | insert before 10    |
| 3       | `[2,4,7,10,15]` | 1  | 0      | insert at beginning |
| 4       | `[2,4,7,10,15]` | 20 | 5      | insert at end       |
| 5       | `[2,4,4,4,9]`   | 4  | 1      | first occurrence    |
| 6       | `[]`            | 5  | 0      | empty array         |

---

### 3. Brute Force (Just for Understanding)

```cpp
for(int i = 0; i < n; i++){
    if(arr[i] >= x)
        return i;
}
return n;
```

---

#### Intuition

The idea is very simple and natural:

* Start from the **beginning of the array**
* Check each element **one by one**
* The moment you find an element that is **greater than or equal to `x`**, return its index
* If no such element exists, return `n` (meaning `x` should be placed at the end)

This mimics how a human would search **without using any optimization**.

---

#### Algorithm (Step-by-Step)

1. Loop through the array from index `0` to `n - 1`
2. For each index `i`:

   * If `arr[i] >= x`, return `i`
3. If the loop finishes without finding such an element:

   * Return `n`

---

#### What This Code Is Actually Doing

* It finds the **first position** where `x` can be inserted **without breaking the sorted order**
* Functionally, this behaves like a **manual version of `lower_bound`**
* It does **not** use binary search, so it checks **every element if needed**

---

#### Time and Space Complexity

* **Time Complexity:** `O(N)`
  Worst case → `x` is greater than all elements or array is large

* **Space Complexity:** `O(1)`
  No extra space is used

---

#### Why This Is ❌ Not Acceptable in Interviews

* The array is **sorted**, so scanning linearly wastes that property
* Interviewers expect you to use **binary search** (`O(log N)`)
* For large inputs, this approach is too slow

---

#### When This Approach Is Still Useful

* Understanding the **problem requirement**
* Validating binary search logic
* Very small input sizes
* Explaining intuition before optimization

---

#### Key Interview Insight

> “This brute-force solution helps understand the problem, but since the array is sorted, we should optimize it using binary search or `lower_bound`.”


---
### 4. Optimal Approach 

#### Intuition (Why this works)

The **Search Insert Position** problem is exactly the definition of **Lower Bound**.

Lower Bound means:

> **Find the first index `i` such that `arr[i] >= x`**

Now connect this with the problem:

* If `x` **exists** in the array
  → the first `>= x` will be the **first occurrence of `x`**

* If `x` **does not exist**
  → the first `>= x` is the **correct position to insert `x`**
  (array remains sorted)

That is why:

> **Search Insert Position = Lower Bound**

---

#### Problem Reduction (Very Important)

Instead of thinking in terms of:

* “find index”
* “check existence”

We reduce the problem to **one clean condition**:

> **Find the first index where `arr[index] >= x`**

Once you think this way, binary search becomes natural.

---

#### Algorithm (Binary Search – Lower Bound Logic)

```text
low = 0, high = n-1
ans = n

while(low <= high){
    mid = low + (high-low)/2

    if(arr[mid] >= x){
        ans = mid
        high = mid - 1
    }
    else{
        low = mid + 1
    }
}
return ans
```

---

#### Key Thinking (Binary Search Mindset)

* When `arr[mid] >= x`:

  * Either `x` is found
  * Or `x` should be inserted **at mid**

* But there might be a **better (smaller) index** on the left

* So:

  * Store the answer → `ans = mid`
  * Move **left** → `high = mid - 1`

* When `arr[mid] < x`:

  * `x` cannot be at `mid` or left of it
  * Move **right** → `low = mid + 1`

---

#### Why `ans` Is Initialized to `n`

* If all elements are `< x`
* Binary search never updates `ans`
* Correct insertion position is **at the end**
* So returning `n` is correct

---

#### Time & Space Complexity

* **Time:** `O(log n)`
* **Space:** `O(1)`

---

#### Common Interview Mistakes

1. Forgetting to move **left** after finding a valid answer
2. Returning `mid` directly instead of tracking `ans`
3. Using `>` instead of `>=`
4. Not explaining why this is **lower bound**

---

#### Interview One-Liner (Very Powerful)

> “Search Insert Position is a direct application of Lower Bound — first index where `arr[i] >= x`.”

---

### 6. Dry Run

`arr = [2,4,7,10,15], x = 9`

| Step | low | high | mid | arr[mid] | >=9? | Action        | ans |
| ---- | --- | ---- | --- | -------- | ---- | ------------- | --- |
| 1    | 0   | 4    | 2   | 7        | No   | low = 3       | 5   |
| 2    | 3   | 4    | 3   | 10       | Yes  | ans=3, high=2 | 3   |
| End  | 3   | 2    | -   | -        | -    | return ans    | 3   |

✅ Correct insert position is index `3`.

---
Below is your **same code**, **same logic**, **same structure** —
only **proper, interview-grade comments** added for **clarity, intuition, and “why”**.
Nothing optimized, nothing changed.

---

### 7. Full Working Code

#### C++

```cpp
class Solution {
public:
    int searchInsert(vector<int>& arr, int x) {

        // Number of elements in the array
        int n = arr.size();

        // low  -> start of current search space
        // high -> end of current search space
        int low = 0, high = n - 1;

        // ans stores the best possible insertion index
        // Initialized to n (insert at end if no element >= x is found)
        int ans = n;

        // Standard binary search loop
        // Using <= ensures single-element search space is handled
        while (low <= high) {

            // Safe mid calculation to avoid integer overflow
            int mid = low + (high - low) / 2;

            // If current element is greater than or equal to x
            // → this index is a valid answer
            // → but there might be a smaller valid index on the left
            if (arr[mid] >= x) {

                // Store current index as potential answer
                ans = mid;

                // Move left to find first occurrence / correct insert position
                high = mid - 1;
            }
            else {
                // If arr[mid] < x, x cannot be at mid or left of it
                // So discard left half and search in right half
                low = mid + 1;
            }
        }

        // ans now contains:
        // - index of first element >= x (if exists)
        // - or n if x is greater than all elements
        return ans;
    }
};
```

---

#### JavaScript

```js
function searchInsert(arr, x) {

    // Length of the array
    let n = arr.length;

    // low  -> starting index of search range
    // high -> ending index of search range
    let low = 0, high = n - 1;

    // Default insertion position is at the end
    let ans = n;

    // Binary search loop
    while (low <= high) {

        // Calculate mid index
        // Math.floor is required because JS division returns decimal values
        let mid = low + Math.floor((high - low) / 2);

        // If arr[mid] is greater than or equal to x
        // → valid insertion point found
        if (arr[mid] >= x) {

            // Save index as possible answer
            ans = mid;

            // Try to find a smaller valid index on the left
            high = mid - 1;
        }
        else {
            // If arr[mid] < x, move to the right half
            low = mid + 1;
        }
    }

    // Return the final insertion index
    return ans;
}

// Tests
console.log(searchInsert([2,4,7,10,15], 9));  // 3
console.log(searchInsert([2,4,7,10,15], 7));  // 2
console.log(searchInsert([2,4,7,10,15], 1));  // 0
```

---

### 8. STL Shortcut (Pro Tip – Commented)

```cpp
// lower_bound returns an iterator to the FIRST element >= x
// Subtracting arr.begin() converts iterator to index
int idx = lower_bound(arr.begin(), arr.end(), x) - arr.begin();
```

#### Why this works

* `lower_bound` internally uses **binary search**
* Time complexity: `O(log n)`
* This is **exactly the same logic** as the manual implementation above

---

### 9. Edge Cases Covered

| Case               | Output                    |
| ------------------ | ------------------------- |
| x smaller than all | 0                         |
| x greater than all | n                         |
| x exists           | index of first occurrence |
| Duplicates         | first index               |
| Empty array        | 0                         |
| Negative values    | handled                   |

---

### 10. Complexity Analysis

| Approach          | Time         | Space    | Verdict |
| ----------------- | ------------ | -------- | ------- |
| Linear Search     | O(N)         | O(1)     | ❌       |
| **Binary Search** | **O(log N)** | **O(1)** | ✅       |
| STL               | O(log N)     | O(1)     | ✅       |

---

### 11. Interview Connections (Very Important)

1. **Relation with Lower Bound**

```
Search Insert Position = lower_bound(arr, x)
```

2. **Dynamic insertion**

```
pos = lower_bound(arr, x)
arr.insert(arr.begin() + pos, x)
```

3. **Counting duplicates**

```
count = upper_bound(x) - lower_bound(x)
```

4. **Difference vs normal binary search**

* Normal BS → returns `-1` if not found
* Search Insert → always returns a valid index `[0, n]`

---

### Final Notes

1. **Search Insert Position = Lower Bound**
2. Condition → `arr[mid] >= x`
3. Default answer → `n`
4. Very common interview problem
5. Foundation for many advanced Binary Search patterns

---
