# Last Occurrence in a Sorted Array

---

## 1. Problem Statement

**English**:
Given a **sorted array** (non-decreasing order) of `n` integers and a `target`,
find the **index of the last occurrence** of the target.

If the target does not exist → return `-1`.

**Hinglish**:
Sorted array diya hai → target ka **last (rightmost) index** nikaalo.
Agar target nahi mila → `-1` return karo.

**Note**:

* **0-based indexing**
* Array is **sorted**

---

## 2. Examples (Must Know)

| Example | Array                  | Target | Output | Why                |
| ------- | ---------------------- | ------ | ------ | ------------------ |
| 1       | `[3,4,13,13,13,20,40]` | 13     | 4      | Last 13 at index 4 |
| 2       | `[3,4,13,13,13,20,40]` | 60     | -1     | Not present        |
| 3       | `[1,2,3,4,5]`          | 3      | 2      | Single occurrence  |
| 4       | `[2,2,2,2]`            | 2      | 3      | Rightmost index    |
| 5       | `[5,6,7]`              | 1      | -1     | Smaller than all   |
| 6       | `[]`                   | 10     | -1     | Empty array        |

---

## 3. Brute Force Approach (For Understanding)

### Intuition

> Agar last occurrence chahiye →
> **array ko right se left scan karo**

---

### Algorithm

```text
for i from n-1 to 0:
    if arr[i] == target:
        return i
return -1
```

---

### C++ Code (Brute)

```cpp
int lastOccurrenceBrute(vector<int>& arr, int target) {
    int n = arr.size();

    // Scan from rightmost side
    for (int i = n - 1; i >= 0; i--) {
        if (arr[i] == target)
            return i;
    }
    return -1;
}
```

---

### Complexity

| Metric | Value |
| ------ | ----- |
| Time   | O(N)  |
| Space  | O(1)  |

❌ **Not acceptable in interviews** (array is sorted, so Binary Search expected)

---

## 4. Core Intuition (Binary Search Thinking)

> **Last Occurrence is a Binary Search variation**, not a new problem.

### What do we want?

> **Rightmost index where `arr[index] == target`**

---

### Key Binary Search Insight

When `arr[mid] == target`:

* This **can be an answer**
* But there **may be another occurrence on the RIGHT**
* So:

  * store index
  * **move right**

---

### Relation with Known Patterns

| Pattern             | Condition   | Move on success |
| ------------------- | ----------- | --------------- |
| First Occurrence    | `== target` | LEFT            |
| **Last Occurrence** | `== target` | **RIGHT**       |
| Lower Bound         | `>= x`      | LEFT            |
| Upper Bound         | `> x`       | LEFT            |

---

### One-Line Rule (Very Important)

```
First occurrence → LEFT
Last occurrence  → RIGHT
```

---

## 5. Algorithm (Binary Search – Optimal)

```text
low = 0, high = n-1
ans = -1

while(low <= high){
    mid = low + (high-low)/2

    if(arr[mid] == target){
        ans = mid
        low = mid + 1        // move RIGHT
    }
    else if(arr[mid] > target){
        high = mid - 1
    }
    else{
        low = mid + 1
    }
}
return ans
```

---

## 6. Dry Run

`arr = [3,4,13,13,13,20,40], target = 13`

| Step | low | high | mid | arr[mid] | Action             | ans   |
| ---- | --- | ---- | --- | -------- | ------------------ | ----- |
| 1    | 0   | 6    | 3   | 13       | found → move right | 3     |
| 2    | 4   | 6    | 5   | 20       | too big → left     | 3     |
| 3    | 4   | 4    | 4   | 13       | found → move right | 4     |
| End  | 5   | 4    | -   | -        | stop               | **4** |

---

## 7. Full Working Code

### C++ (Interview Preferred)

```cpp
int lastOccurrenceBinary(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    int ans = -1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == target) {
            ans = mid;          // possible answer
            low = mid + 1;      // move right for last occurrence
        }
        else if (arr[mid] > target) {
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return ans;
}
```

---

### JavaScript

```js
function lastOccurrence(arr, target) {
    let low = 0, high = arr.length - 1;
    let ans = -1;

    while (low <= high) {
        let mid = low + Math.floor((high - low) / 2);

        if (arr[mid] === target) {
            ans = mid;
            low = mid + 1;      // move right
        }
        else if (arr[mid] > target) {
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return ans;
}
```

---

## 8. Edge Cases Covered

| Case                      | Output     |
| ------------------------- | ---------- |
| Target not present        | -1         |
| Target appears once       | index      |
| Target appears many times | last index |
| Empty array               | -1         |
| All elements same         | last index |

---

## 9. Complexity Analysis

| Approach          | Time         | Space    |
| ----------------- | ------------ | -------- |
| Brute Force       | O(N)         | O(1)     |
| **Binary Search** | **O(log N)** | **O(1)** |

---

## 10. Interview Connections (Very Important)

1. **Last occurrence using upper bound**

```
last = upper_bound(x) - 1
(check validity)
```

2. **Count occurrences**

```
count = lastOccurrence - firstOccurrence + 1
```

3. **Foundation for range queries**

* Frequency
* Range of duplicates

---

## Final Notes (Yaad Rakhna)

1. Array **must be sorted**
2. On match:

   * **store index**
   * **move right**
3. Default answer = `-1`
4. Very common interview question

---