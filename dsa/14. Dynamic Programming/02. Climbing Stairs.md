# PROBLEM (Original Statement)

You are climbing a staircase.
It takes `n` steps to reach the top.

Each time, you can either climb:

- `1` step, or
- `2` steps.

Return the **number of distinct ways** to reach the top.

---

## BREAKDOWN PROBLEM

### What is being asked?

- Count **how many different ways** to reach step `n`.

### What is input?

- Integer `n` (number of steps)

### What is output?

- Integer → total number of ways

---

## CONSTRAINT UNDERSTANDING

Typical constraints:

- `1 <= n <= 45` (LeetCode)

Why constraints matter:

- Number of ways grows fast
- Brute force recursion will repeat work
- We must optimize

---

# BRUTE FORCE APPROACH

## First Thought Intuition (HOW MY BRAIN STARTS)

> “I can take 1 step or 2 steps.
> So from step `n`, I must have come from:

- `n-1` (1 step)
- `n-2` (2 steps)”

This **immediately smells like recursion**.

---

## Thought Process (Step-wise – Thinking Out Loud)

1. If I am at step `n`
2. Total ways =
   - ways to reach `n-1`
   - - ways to reach `n-2`

3. Base cases:
   - If `n == 0` → 1 way (do nothing)
   - If `n == 1` → 1 way

This looks **exactly like Fibonacci**.

---

## Pseudocode

```
ways(n):
    if n == 0 or n == 1:
        return 1
    return ways(n-1) + ways(n-2)
```

---

## Algorithm

1. Use recursion
2. Add results of previous two states
3. Return total

---

## CODE (C++)

### V1 (Only Required Function)

```cpp
int climbStairs(int n)
{
    // Base case:
    // If there are 0 or 1 steps, there is exactly 1 way to climb
    if (n <= 1)
        return 1;

    // Recursive case:
    // Ways to reach step n =
    // ways to reach step n-1 + ways to reach step n-2
    return climbStairs(n - 1) + climbStairs(n - 2);
}
```

---

## Time and Space Complexity

- **Time Complexity:** `O(2^n)`
- **Space Complexity:** `O(n)` (recursion stack)

---

## Dry Run (n = 3)

```
climb(3)
 → climb(2) + climb(1)
 → (climb(1) + climb(0)) + 1
 → (1 + 1) + 1 = 3
```

---

## Edge Cases

- `n = 1` → 1
- `n = 2` → 2
- Large `n` → TLE

---

## Does This Approach Fail?

**YES**

### Why it fails

- Same subproblems repeated
- Exponential growth

➡️ **My next thought:**
“Why am I recalculating the same steps again and again?”

---

# BETTER APPROACH

## Recursive + Memoization (Top-Down DP)

---

## First Thought Intuition (HOW I SWITCH)

> “This is Fibonacci-like with overlapping subproblems.
> So I should **store results**.”

---

## Thought Process (Step-wise)

1. Create a `dp` array
2. Before computing, check if already solved
3. Store and reuse

---

## Pseudocode

```
ways(n):
    if n <= 1: return 1
    if dp[n] exists: return dp[n]
    dp[n] = ways(n-1) + ways(n-2)
    return dp[n]
```

---

## CODE (C++)

### V1 (Only Required Function)

```cpp
int solve(int n, vector<int> &dp)
{
    // Base case
    if (n <= 1)
        return 1;

    // If already computed, return stored value
    if (dp[n] != -1)
        return dp[n];

    // Compute, store, and return
    dp[n] = solve(n - 1, dp) + solve(n - 2, dp);
    return dp[n];
}

int climbStairs(int n)
{
    // DP array initialized with -1
    vector<int> dp(n + 1, -1);

    return solve(n, dp);
}
```

---

## Time and Space Complexity

- **Time Complexity:** `O(n)`
- **Space Complexity:** `O(n)` (dp + recursion stack)

---

## Dry Run (n = 5)

```
solve(5)
 → computed once
 → reused later
```

---

## Does This Approach Fail?

**NO**, but…

### My next thought:

> “Why am I still using recursion if order is fixed?”

➡️ Let’s go **bottom-up**.

---

# OPTIMAL APPROACH

## Bottom-Up DP (Tabulation)

---

## First Thought Intuition

> “Ways for step `i` depend only on `i-1` and `i-2`.
> So I can build from 0 → n.”

---

## Thought Process (Step-wise)

1. Create `dp[]`
2. Initialize base cases
3. Fill array iteratively

---

## CODE (C++)

### V1 (Only Required Function)

```cpp
int climbStairs(int n)
{
    // If only 0 or 1 step, only one way
    if (n <= 1)
        return 1;

    // DP array where dp[i] = number of ways to reach step i
    vector<int> dp(n + 1, 0);

    // Base cases
    dp[0] = 1;
    dp[1] = 1;

    // Fill DP table
    for (int i = 2; i <= n; i++)
    {
        // Ways come from previous two steps
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

---

## Time and Space Complexity

- **Time Complexity:** `O(n)`
- **Space Complexity:** `O(n)`

---

## Can We Do Better?

## YES → Space Optimization

---

## OPTIMAL (Best Possible)

### Key Thinking

> “I only need last two values.
> Why store the entire array?”

---

### CODE (C++ – Space Optimized)

```cpp
int climbStairs(int n)
{
    // Base case
    if (n <= 1)
        return 1;

    // prev2 = ways to reach step 0
    int prev2 = 1;

    // prev1 = ways to reach step 1
    int prev1 = 1;

    // Build from step 2 to n
    for (int i = 2; i <= n; i++)
    {
        // Current ways = sum of previous two
        int curr = prev1 + prev2;

        // Shift values for next iteration
        prev2 = prev1;
        prev1 = curr;
    }

    // prev1 now holds answer for step n
    return prev1;
}
```

---

## Time and Space Complexity

- **Time Complexity:** `O(n)`
- **Space Complexity:** `O(1)`

---

## Why This Is Optimal

- Linear time
- Constant space
- No recursion
- Handles large `n`

---

# PATTERN RECOGNITION & THINKING MINDSET (MOST IMPORTANT)

### When you see:

- “Number of ways”
- “1 or 2 choices”
- “Reach step n”

### Immediately think:

> “Ways(n) = Ways(n-1) + Ways(n-2)”

### This is:

- Fibonacci pattern
- DP with overlapping subproblems
- Can be optimized to O(1) space

### Mental Rule:

> If current state depends on **fixed previous states**,
> try **space optimization**.

---
