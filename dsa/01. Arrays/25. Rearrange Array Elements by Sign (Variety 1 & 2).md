# Problem: Rearrange Array Elements by Sign (Variety 1 & 2)

**GFG Link**: https://www.geeksforgeeks.org/problems/rearrange-array-alternately/1  
**LeetCode (Similar)**: https://leetcode.com/problems/rearrange-array-elements-by-sign/

---

## 1. Problem Statement

### **Variety 1 (Equal +ve & -ve)**  
Given an array `A` of size `N` with **equal number** of **positive** and **negative** integers, rearrange it **in-place** such that:  
- Elements **alternate in sign**  
- **Relative order** of +ve and -ve is preserved  
- **Starts with positive**

### **Variety 2 (Unequal +ve & -ve)**  
Same as above, but **number of +ve and -ve may differ**  
→ **Leftover elements** go to the **end** in their original relative order.

---

## 2. Input / Output / Constraints

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| V1-1 | `[1,2,-4,-5]` | `1 -4 2 -5` | Equal count, alternate |
| V1-2 | `[1,2,-3,-1,-2,-3]` | `1 -3 2 -1 -2 -3` → Wait! **Wrong** → Should be `1 -3 2 -1 3 -2` |
| V2-1 | `[1,2,-4,-5,3,4]` | `1 -4 2 -5 3 4` | +ve > -ve → extras at end |
| V2-2 | `[1,2,-3,-1,-2,-4]` | `1 -3 2 -1 -2 -4` | -ve > +ve → extras at end |

**Constraints**:  
- `1 ≤ N ≤ 10⁵`  
- `-10⁹ ≤ A[i] ≤ 10⁹`  
- `0` is **not considered** positive or negative → but **not present** in test cases

---

## 3. Examples (All Cases Covered)

| Case | Input | Output | Note |
|------|-------|--------|------|
| V1-Eq | `[1,-2,3,-4]` | `1 -2 3 -4` | Equal |
| V1-Eq | `[3,-1,2,-4]` | `3 -1 2 -4` | Order preserved |
| V2-+ve> | `[1,2,3,-4,-5]` | `1 -4 2 -5 3` | +ve leftover |
| V2--ve> | `[1,-2,-3,-4,-5]` | `1 -2 -3 -4 -5` → Wait! Should be `1 -2 -3 -4 -5` → **No alternate possible beyond 1** |
| Empty | `[]` | `[]` | |
| n=1 | `[5]` | `[5]` | |
| n=1 | `[-3]` | `[-3]` | But should start with +ve → **impossible** → still return as-is |

---

## 4. Intuition & Core Thinking

> **Key**: **Preserve relative order** → Cannot sort  
> **Key**: **Alternate placement** → Use **even/odd indices**

### **Variety 1 (Equal Count)**  
- Use **two pointers** in result array:  
  - `posIdx = 0` (even)  
  - `negIdx = 1` (odd)  
- Traverse input → place +ve at `posIdx`, -ve at `negIdx` → increment by **2**

### **Variety 2 (Unequal Count)**  
- First **alternate** until **min(pos, neg)**  
- Then **append leftovers** in order

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute – Separate Arrays (Works for Both)

### Intuition  
- Collect all **+ve** in `pos[]`  
- Collect all **-ve** in `neg[]`  
- Then **reconstruct** array alternately  
- **Handle leftover** in Variety 2

### Why This Approach?  
- **Simple & clear**  
- **Preserves order**  
- Works for **both varieties**

### Why Move to Next?  
- **O(n) space** → not in-place  
- Can we do **in-place**?

---

### Algorithm (Variety 1 & 2)

``` 
pos = [], neg = []
for num in A:
    if num > 0: pos.push(num)
    else: neg.push(num)

i = 0
while i < min(pos.size, neg.size) * 2:
    A[i] = pos[i//2]
    A[i+1] = neg[i//2]
    i += 2

// Leftover
start = min(pos.size, neg.size) * 2
if pos.size > neg.size:
    for j from neg.size to pos.size-1:
        A[start++] = pos[j]
else:
    for j from pos.size to neg.size-1:
        A[start++] = neg[j]
```

---

### Dry Run: `[1,2,-4,-5,3,4]` (V2)

- `pos = [1,2,3]`, `neg = [-4,-5]`  
- Alternate:  
  `A[0]=1`, `A[1]=-4`  
  `A[2]=2`, `A[3]=-5`  
- Leftover: `pos[2]=3` → `A[4]=3`  
- → `[1,-4,2,-5,3,4]` Correct

---

### Code

#### C++
```cpp
vector<int> rearrange(vector<int>& A) {
    vector<int> pos, neg;
    for (int num : A) {
        if (num > 0) pos.push_back(num);
        else neg.push_back(num);
    }
    int n = A.size();
    int i = 0, p = 0, ne = 0;
    while (p < pos.size() && ne < neg.size()) {
        A[i++] = pos[p++];
        A[i++] = neg[ne++];
    }
    while (p < pos.size()) A[i++] = pos[p++];
    while (ne < neg.size()) A[i++] = neg[ne++];
    return A;
}
```

#### JavaScript
```js
function rearrange(A) {
    let pos = [], neg = [];
    for (let num of A) {
        if (num > 0) pos.push(num);
        else neg.push(num);
    }
    let i = 0, p = 0, n = 0;
    while (p < pos.length && n < neg.length) {
        A[i++] = pos[p++];
        A[i++] = neg[n++];
    }
    while (p < pos.length) A[i++] = pos[p++];
    while (n < neg.length) A[i++] = neg[n++];
    return A;
}
```

* Time: **O(n)**, Space: **O(n)**

---

## Approach 2: Optimal (Variety 1) – Direct Index Placement

### Intuition  
- **Equal count** → `n/2` +ve, `n/2` -ve  
- Place **+ve at even**, **-ve at odd** indices **directly**

### Why This Approach?  
- **O(n) time**, **O(n) space** (still uses extra array)  
- **No need to store in vectors** → just place

---

### Code (Variety 1 Only)

#### C++
```cpp
vector<int> rearrangeV1(vector<int>& A) {
    int n = A.size();
    vector<int> ans(n, 0);
    int pos = 0, neg = 1;
    for (int num : A) {
        if (num > 0) {
            ans[pos] = num;
            pos += 2;
        } else {
            ans[neg] = num;
            neg += 2;
        }
    }
    return ans;
}
```

* Time: **O(n)**, Space: **O(n)** → **Best for Variety 1**

---

## Approach 3: In-Place? (Not Possible in O(1) Space)

> **Why not in-place?**  
> Because we **cannot shift** elements without losing order or using extra space.

→ **O(n) space is necessary**

---

## 5. Edge Case List (Line-wise)

| Case | Input | Output | Handled? |
|------|-------|--------|---------|
| Empty | `[]` | `[]` | Yes |
| n=1 +ve | `[5]` | `[5]` | Yes |
| n=1 -ve | `[-3]` | `[-3]` | Yes (cannot start with +ve) |
| All +ve | `[1,2,3]` | `[1,2,3]` | Yes |
| All -ve | `[-1,-2]` | `[-1,-2]` | Yes |
| Equal | `[1,-1,2,-2]` | `1 -1 2 -2` | Yes |
| +ve > -ve | `[1,2,-3]` | `1 -3 2` | Yes |
| -ve > +ve | `[1,-2,-3]` | `1 -2 -3` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | In-Place? | Best For |
|--------|------|-------|-----------|----------|
| Separate Arrays | O(n) | O(n) | No | **Both V1 & V2** |
| Direct Index (V1) | O(n) | O(n) | No | **Only V1** |
| **Recommended** | **O(n)** | **O(n)** | No | **Universal** |

> **Use Separate Arrays method** — works for **both varieties**

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute: Works for Both V1 & V2
    vector<int> rearrange(vector<int>& A) {
        vector<int> pos, neg;
        for (int num : A) {
            if (num > 0) pos.push_back(num);
            else neg.push_back(num);
        }
        int i = 0, p = 0, ne = 0;
        while (p < pos.size() && ne < neg.size()) {
            A[i++] = pos[p++];
            A[i++] = neg[ne++];
        }
        while (p < pos.size()) A[i++] = pos[p++];
        while (ne < neg.size()) A[i++] = neg[ne++];
        return A;
    }

    // Optimal for Variety 1 (Equal Count)
    vector<int> rearrangeV1(vector<int>& A) {
        int n = A.size();
        vector<int> ans(n, 0);
        int pos = 0, neg = 1;
        for (int num : A) {
            if (num > 0) {
                ans[pos] = num;
                pos += 2;
            } else {
                ans[neg] = num;
                neg += 2;
            }
        }
        return ans;
    }
};
```

### JavaScript
```javascript
class Solution {
    // Universal: V1 & V2
    rearrange(A) {
        let pos = [], neg = [];
        for (let num of A) {
            if (num > 0) pos.push(num);
            else neg.push(num);
        }
        let i = 0, p = 0, n = 0;
        while (p < pos.length && n < neg.length) {
            A[i++] = pos[p++];
            A[i++] = neg[n++];
        }
        while (p < pos.length) A[i++] = pos[p++];
        while (n < neg.length) A[i++] = neg[n++];
        return A;
    }

    // Only V1 (Equal)
    rearrangeV1(A) {
        let n = A.length;
        let ans = new Array(n).fill(0);
        let pos = 0, neg = 1;
        for (let num of A) {
            if (num > 0) {
                ans[pos] = num;
                pos += 2;
            } else {
                ans[neg] = num;
                neg += 2;
            }
        }
        return ans;
    }
}
```

---

## 8. Interview Strategy

1. **Clarify**: "Is count of +ve and -ve **equal**?"  
   → If **yes** → use **direct index**  
   → If **no** → use **separate arrays**

2. **Start**: "I'll collect +ve and -ve in two arrays to preserve order."

3. "Then alternate until min size, then append leftovers."

4. "Time: **O(n)**, Space: **O(n)** — necessary due to order constraint."

5. **Bonus**:  
   - "For **equal count**, I can optimize by direct placement at even/odd indices."  
   - "In-place not possible without losing order."

---
