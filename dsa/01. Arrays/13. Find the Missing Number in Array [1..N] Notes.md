# Problem: Find the Missing Number in Array [1..N]

**GFG Link**: https://www.geeksforgeeks.org/problems/missing-number-in-array/1  
**LeetCode Link**: https://leetcode.com/problems/missing-number/

---

## 1. Problem Statement

**English**:  
Given an array of size `N-1` containing **distinct numbers** from `1` to `N`, find the **missing number**.

**Hinglish**:  
Array mein `N-1` numbers hain, `1` se `N` tak, ek missing hai. **Woh number dhundho.**

---

## 2. Input / Output / Constraints

**Input Example**:  
`N = 5`, `arr = [1, 2, 4, 5]`  
**Output Expected**: `3`

**Constraints**:  
- `1 ≤ N ≤ 10⁵`  
- Array contains **distinct** numbers from `1` to `N`, one missing  
- Array size = `N-1`

---

## 3. Examples (All Cases Covered)

| Example | N | Array | Missing | Why |
|--------|----|--------|--------|-----|
| 1 | 5 | `[1,2,4,5]` | `3` | Normal |
| 2 | 3 | `[1,3]` | `2` | Small |
| 3 | 2 | `[1]` | `2` | N=2 |
| 4 | 1 | `[]` | `1` | Edge |
| 5 | 100000 | `[1,2,...,99999]` | `100000` | Large N |

---

## 4. Intuition & Core Thinking

> **There are N numbers from 1 to N. One is missing. Find it efficiently.**

Key Insight:  
We **know** what should be there → **compare expected vs actual**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Linear Search for Each Number

### Intuition  
For each `i` from `1` to `N`, search if it exists in array.

### Why This Approach?  
- Simple  
- Teaches nested loops

### Why Move to Next?  
- **O(N²)** time → too slow  
- Not acceptable

---

### Code
```cpp
int brute(vector<int>& arr, int N) {
    for (int i = 1; i <= N; i++) {
        bool found = false;
        for (int x : arr) {
            if (x == i) {
                found = true;
                break;
            }
        }
        if (!found) return i;
    }
    return -1;
}
```

* Time: **O(N²)**, Space: **O(1)** → **Poor**

---

## Approach 2: Better – Hashing (Frequency Array)

### Intuition  
Use array `hash[1..N]` → mark presence → find `0`.

### Why This?  
- **O(N)** time  
- Easy to understand

### Why Move to Next?  
- **O(N)** space → not optimal

---

### Code
```cpp
int hashing(vector<int>& arr, int N) {
    vector<int> hash(N+1, 0);
    for (int x : arr) hash[x] = 1;
    for (int i = 1; i <= N; i++) {
        if (hash[i] == 0) return i;
    }
    return -1;
}
```

* Time: **O(N)**, Space: **O(N)** → **Good, but not best**

---

## Approach 3: Optimal 1 – Summation Formula

### Intuition  
> **Expected sum** = `1 + 2 + ... + N = N*(N+1)/2`  
> **Actual sum** = sum of array  
> **Missing** = Expected − Actual

### Why This?  
- **O(N)** time  
- **O(1)** space  
- **Math trick**

### Warning  
> **Overflow risk**: `N*(N+1)/2` may exceed `int` for large `N` (e.g. `N=10⁵`)

---

### Code (Safe)
```cpp
int summation(vector<int>& arr, int N) {
    long long expected = (long long)N * (N + 1) / 2;
    long long actual = 0;
    for (int x : arr) actual += x;
    return expected - actual;
}
```

* Time: **O(N)**, Space: **O(1)** → **Great, but overflow risk**

---

## Approach 4: Optimal 2 – XOR Trick (BEST)

### Intuition  
> **XOR all numbers from 1 to N** → `xor1`  
> **XOR all array elements** → `xor2`  
> **xor1 ^ xor2 = missing number**

**Why?**  
- `a ^ a = 0`  
- `0 ^ x = x`  
- All present numbers cancel out → only missing remains

### Why This is Final?  
- **O(N)** time  
- **O(1)** space  
- **No overflow**  
- **Interview favorite**

---

### Algorithm  
``` 
xor1 = 0
for i from 1 to N:
    xor1 ^= i

xor2 = 0
for x in arr:
    xor2 ^= x

return xor1 ^ xor2
```

---

### Dry Run: N=5, arr=[1,2,4,5]

| Step | xor1 | xor2 |
|------|------|------|
| i=1 | 0^1 = 1 | |
| i=2 | 1^2 = 3 | |
| i=3 | 3^3 = 0 | |
| i=4 | 0^4 = 4 | |
| i=5 | 4^5 = 1 | |
| arr[0]=1 | | 0^1 = 1 |
| arr[1]=2 | | 1^2 = 3 |
| arr[2]=4 | | 3^4 = 7 |
| arr[3]=5 | | 7^5 = 2 |

**Final**: `xor1 = 1`, `xor2 = 2` → `1 ^ 2 = 3` → **Correct!**

---

### Code

#### C++ (LeetCode Style)
```cpp
class Solution {
public:
    int missingNumber(vector<int>& arr) {
        int N = arr.size() + 1;
        int xor1 = 0, xor2 = 0;
        for (int i = 1; i <= N; i++) {
            xor1 ^= i;
            if (i-1 < arr.size()) xor2 ^= arr[i-1];
        }
        return xor1 ^ xor2;
    }
};
```

#### Clean Version
```cpp
int xorApproach(vector<int>& arr, int N) {
    int xor1 = 0, xor2 = 0;
    for (int i = 0; i < N-1; i++) {
        xor1 ^= (i+1);
        xor2 ^= arr[i];
    }
    xor1 ^= N;  // include N
    return xor1 ^ xor2;
}
```

* Time: **O(N)**, Space: **O(1)** → **BEST**

---

## 5. Edge Case List (Line-wise)

| Edge Case | N | Array | Expected | Handled? |
|---------|----|--------|----------|---------|
| N=1 | 1 | `[]` | `1` | Yes |
| N=2 | 2 | `[1]` | `2` | Yes |
| Missing at start | 5 | `[2,3,4,5]` | `1` | Yes |
| Missing at end | 5 | `[1,2,3,4]` | `5` | Yes |
| Large N | 100000 | ... | Correct | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute | O(N²) | O(1) | Learning |
| Hashing | O(N) | O(N) | Good |
| Summation | O(N) | O(1) | Great (risk overflow) |
| **XOR** | **O(N)** | **O(1)** | **Interviews (BEST)** |

---

## 7. Final Consolidated Code

### C++ (All Approaches)
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute
    int brute(vector<int>& arr, int N) {
        for (int i = 1; i <= N; i++) {
            bool found = false;
            for (int x : arr) {
                if (x == i) {
                    found = true;
                    break;
                }
            }
            if (!found) return i;
        }
        return -1;
    }

    // Hashing
    int hashing(vector<int>& arr, int N) {
        vector<int> hash(N+1, 0);
        for (int x : arr) hash[x] = 1;
        for (int i = 1; i <= N; i++) {
            if (hash[i] == 0) return i;
        }
        return -1;
    }

    // Summation (Safe)
    int summation(vector<int>& arr, int N) {
        long long expected = (long long)N * (N + 1) / 2;
        long long actual = 0;
        for (int x : arr) actual += x;
        return expected - actual;
    }

    // XOR (BEST)
    int missingNumber(vector<int>& arr) {
        int N = arr.size() + 1;
        int xor1 = 0, xor2 = 0;
        for (int i = 0; i < N-1; i++) {
            xor1 ^= (i+1);
            xor2 ^= arr[i];
        }
        xor1 ^= N;
        return xor1 ^ xor2;
    }
};
```

### JavaScript
```javascript
class Solution {
    // XOR Approach
    missingNumber(arr, N) {
        let xor1 = 0, xor2 = 0;
        for (let i = 0; i < N-1; i++) {
            xor1 ^= (i+1);
            xor2 ^= arr[i];
        }
        xor1 ^= N;
        return xor1 ^ xor2;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I’ll use **XOR** — **O(N) time**, **O(1) space**, **no overflow**."  
2. "XOR all numbers from 1 to N, and all array elements. The result is the missing number."  
3. "Because `a ^ a = 0`, all present numbers cancel out."  
4. "Edge cases: N=1, missing at start/end → handled."  
5. **Bonus**: "Summation risks overflow. XOR is **safest and best**."

---