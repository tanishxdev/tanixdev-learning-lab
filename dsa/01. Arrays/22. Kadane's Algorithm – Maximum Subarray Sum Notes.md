# Problem: Kadane's Algorithm – Maximum Subarray Sum

**GFG Link**: https://www.geeksforgeeks.org/problems/kadanes-algorithm-1587115620/1  
**LeetCode (Same)**: https://leetcode.com/problems/maximum-subarray/

---

## 1. Problem Statement

**English**:  
Given an array of integers, find the **contiguous subarray** (with at least one element) that has the **largest sum** and return its **sum**.  
*Follow-up*: Also **print the subarray**.

**Hinglish**:  
Array diya hai — sabse bada sum wala **contiguous subarray** dhundho aur uska **sum** return karo.  
*Bonus*: Subarray bhi print karo.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`  
**Output Expected**:  
`6`  
*Subarray: [4, -1, 2, 1]*

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- Array may contain **negative**, **zero**, **positive** numbers

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Subarray | Why |
|-------|-------|--------|----------|-----|
| 1 | `[-2,1,-3,4,-1,2,1,-5,4]` | `6` | `[42,1]` or `[4,-1,2,1]` | Max sum |
| 2 | `[1]` | `1` | `[1]` | Single element |
| 3 | `[-1]` | `-1` | `[-1]` | Must take at least one |
| 4 | `[-2,-1]` | `-1` | `[-1]` | Least negative |
| 5 | `[5,4,-1,7,8]` | `23` | `[5,4,-1,7,8]` | Whole array |
| 6 | `[-2,-3,-1,-4]` | `-1` | `[-1]` | All negative |

---

## 4. Intuition & Core Thinking

> **"If a subarray has negative sum → discard it."**

**Key Insight**:  
A **negative prefix** will never help in forming a larger sum.  
→ So, **reset** the current sum to `0` when it becomes negative.

Like climbing a mountain:  
- Keep going as long as you're gaining height  
- If you start going down (negative sum), **start fresh** from next point

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Three Nested Loops

### Intuition  
Check **every possible subarray** → compute sum → track max.

### Why This Approach?  
- Most intuitive  
- Covers all cases  
- Teaches subarray logic

### Why Move to Next?  
- **O(n³)** → TLE for n = 10⁵  
- Redundant sum calculations

---

### Algorithm  
``` 
for i from 0 to n-1:
    for j from i to n-1:
        sum = 0
        for k from i to j:
            sum += arr[k]
        maxSum = max(maxSum, sum)
```

---

### Dry Run: [-2,1,-3,4]  
- `[4]` → sum = 4 → max = 4  
- `[4,-1]` → sum = 3  
- `[4,-1,2]` → sum = 5 → **max = 5**

---

### Code

#### C++
```cpp
int brute(vector<int>& arr) {
    int n = arr.size(), maxSum = INT_MIN;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int sum = 0;
            for (int k = i; k <= j; k++) {
                sum += arr[k];
            }
            maxSum = max(maxSum, sum);
        }
    }
    return maxSum;
}
```

* Time: **O(n³)**, Space: **O(1)** → **TLE**

---

## Approach 2: Better – Two Loops (Prefix Optimization)

### Intuition  
> **Current sum = previous sum + arr[j]**

No need for third loop — maintain running sum while expanding `j`.

---

### Algorithm  
``` 
for i from 0 to n-1:
    sum = 0
    for j from i to n-1:
        sum += arr[j]
        maxSum = max(maxSum, sum)
```

---

### Dry Run: [4, -1, 2, 1]  
- i=3:  
  j=3: sum=4 → max=4  
  j=4: sum=3  
  j=5: sum=5 → max=5  
  j=6: sum=6 → **max=6**

---

### Code

#### C++
```cpp
int better(vector<int>& arr) {
    int n = arr.size(), maxSum = INT_MIN;
    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = i; j < n; j++) {
            sum += arr[j];
            maxSum = max(maxSum, sum);
        }
    }
    return maxSum;
}
```

* Time: **O(n²)**, Space: **O(1)** → **Still slow**

---

## Approach 3: Optimal – Kadane's Algorithm (One Pass)

### Intuition  
> **"Never carry forward a negative sum."**

**Core Idea**:
- `currSum += arr[i]`
- If `currSum < 0` → **reset** to `0`
- Else → `maxSum = max(maxSum, currSum)`

> **Why reset to 0?**  
> A negative sum will only decrease future sums → better to start fresh.

---

### Algorithm  
``` 
maxSum = INT_MIN, currSum = 0
for i from 0 to n-1:
    currSum += arr[i]
    maxSum = max(maxSum, currSum)
    if currSum < 0:
        currSum = 0
return maxSum
```

> **Note**: If **empty subarray allowed**, return `max(0, maxSum)`

---

### Dry Run: [-2, 1, -3, 4, -1, 2, 1, -5, 4]

| i | arr[i] | currSum | maxSum | Action |
|---|--------|---------|--------|--------|
| 0 | -2 | -2 | -2 | <0 → reset |
| 1 | 1 | 1 | 1 | |
| 2 | -3 | -2 | 1 | <0 → reset |
| 3 | 4 | 4 | 4 | |
| 4 | -1 | 3 | 4 | |
| 5 | 2 | 5 | **5** | |
| 6 | 1 | 6 | **6** | |
| 7 | -5 | 1 | 6 | |
| 8 | 4 | 5 | 6 | |

→ Answer: `6`

---

### Code (Sum Only)

#### C++
```cpp
long long kadane(vector<int>& arr) {
    long long maxSum = LLONG_MIN, currSum = 0;
    for (int num : arr) {
        currSum += num;
        maxSum = max(maxSum, currSum);
        if (currSum < 0) currSum = 0;
    }
    return maxSum;
}
```

#### JavaScript
```js
function kadane(arr) {
    let maxSum = -Infinity, currSum = 0;
    for (let num of arr) {
        currSum += num;
        maxSum = Math.max(maxSum, currSum);
        if (currSum < 0) currSum = 0;
    }
    return maxSum;
}
```

* Time: **O(n)**, Space: **O(1)**

---

## Approach 4: Kadane + Print Subarray (Follow-up)

### Intuition  
Track **start** and **end** indices when `maxSum` is updated.

- `start` → set when `currSum == 0` (new subarray starts)
- When `currSum > maxSum` → update `ansStart`, `ansEnd`

---

### Code

#### C++
```cpp
pair<long long, vector<int>> kadaneWithSubarray(vector<int>& arr) {
    long long maxSum = LLONG_MIN, currSum = 0;
    int start = 0, ansStart = -1, ansEnd = -1;
    
    for (int i = 0; i < arr.size(); i++) {
        if (currSum == 0) start = i;
        
        currSum += arr[i];
        
        if (currSum > maxSum) {
            maxSum = currSum;
            ansStart = start;
            ansEnd = i;
        }
        
        if (currSum < 0) currSum = 0;
    }
    
    vector<int> subarray;
    if (ansStart != -1) {
        for (int i = ansStart; i <= ansEnd; i++) {
            subarray.push_back(arr[i]);
        }
    }
    return {maxSum, subarray};
}
```

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|---------|-------|----------|---------|
| All negative | `[-2,-1,-3]` | `-1` | Yes |
| Single element | `[5]` | `5` | Yes |
| Empty array | `[]` | `0` or `-1` | Handle explicitly |
| All positive | `[1,2,3]` | `6` | Yes |
| Zero included | `[1,0,-1,2]` | `3` | Yes |
| Max at start | `[10,1,2]` | `13` | Yes |

> **Note**: If **empty subarray allowed** → return `max(0, maxSum)`

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute (3 loops) | O(n³) | O(1) | Learning |
| Better (2 loops) | O(n²) | O(1) | Understanding |
| **Kadane** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| + Print Subarray | O(n) | O(1) | Follow-up |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute Force - O(n^3)
    long long brute(vector<int>& arr) {
        int n = arr.size();
        long long maxSum = LLONG_MIN;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                long long sum = 0;
                for (int k = i; k <= j; k++) {
                    sum += arr[k];
                }
                maxSum = max(maxSum, sum);
            }
        }
        return maxSum;
    }

    // 2. Better - O(n^2)
    long long better(vector<int>& arr) {
        int n = arr.size();
        long long maxSum = LLONG_MIN;
        for (int i = 0; i < n; i++) {
            long long sum = 0;
            for (int j = i; j < n; j++) {
                sum += arr[j];
                maxSum = max(maxSum, sum);
            }
        }
        return maxSum;
    }

    // 3. Optimal: Kadane's Algorithm
    long long kadane(vector<int>& arr) {
        long long maxSum = LLONG_MIN, currSum = 0;
        for (int num : arr) {
            currSum += num;
            maxSum = max(maxSum, currSum);
            if (currSum < 0) currSum = 0;
        }
        return maxSum;
    }

    // 4. Kadane + Print Subarray
    pair<long long, vector<int>> kadanePrint(vector<int>& arr) {
        long long maxSum = LLONG_MIN, currSum = 0;
        int start = 0, ansStart = -1, ansEnd = -1;
        for (int i = 0; i < arr.size(); i++) {
            if (currSum == 0) start = i;
            currSum += arr[i];
            if (currSum > maxSum) {
                maxSum = currSum;
                ansStart = start;
                ansEnd = i;
            }
            if (currSum < 0) currSum = 0;
        }
        vector<int> subarray;
        if (ansStart != -1) {
            for (int i = ansStart; i <= ansEnd; i++) {
                subarray.push_back(arr[i]);
            }
        }
        return {maxSum, subarray};
    }
};
```

### JavaScript
```javascript
class Solution {
    // Brute Force
    brute(arr) {
        let n = arr.length, maxSum = -Infinity;
        for (let i = 0; i < n; i++) {
            for (let j = i; j < n; j++) {
                let sum = 0;
                for (let k = i; k <= j; k++) {
                    sum += arr[k];
                }
                maxSum = Math.max(maxSum, sum);
            }
        }
        return maxSum;
    }

    // Optimal: Kadane
    kadane(arr) {
        let maxSum = -Infinity, currSum = 0;
        for (let num of arr) {
            currSum += num;
            maxSum = Math.max(maxSum, currSum);
            if (currSum < 0) currSum = 0;
        }
        return maxSum;
    }

    // Kadane + Subarray
    kadanePrint(arr) {
        let maxSum = -Infinity, currSum = 0;
        let start = 0, ansStart = -1, ansEnd = -1;
        for (let i = 0; i < arr.length; i++) {
            if (currSum === 0) start = i;
            currSum += arr[i];
            if (currSum > maxSum) {
                maxSum = currSum;
                ansStart = start;
                ansEnd = i;
            }
            if (currSum < 0) currSum = 0;
        }
        let subarray = arr.slice(ansStart, ansEnd + 1);
        return { sum: maxSum, subarray };
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I'll use **Kadane's Algorithm** in **O(n)** time."
2. "Maintain `currSum`. If it becomes negative → reset to 0."
3. "Update `maxSum` at every step."
4. "Edge case: all negative → return largest negative."
5. **Bonus**: "To print subarray → track start when `currSum == 0`, update `ansStart`, `ansEnd` when `maxSum` updates."

---
