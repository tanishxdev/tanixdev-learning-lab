# Problem: Check if an Array is Sorted (Non-decreasing)

**GFG Link**: https://www.geeksforgeeks.org/problems/check-if-an-array-is-sorted0701/1

---

## 1. Problem Statement

**English**:  
Given an array of integers, check if it is sorted in **non-decreasing order** (i.e., each element ≤ next element).  
Return `true` if sorted, `false` otherwise.  
**Equal consecutive elements are allowed.**

**Hinglish**:  
Array check karo — kya har element apne se next wale se **chhota ya barabar** hai?  
Agar haan → `true`, warna `false`.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [1, 2, 3, 4, 5]`  
**Output Expected**: `true`

**Constraints**:  
- `0 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- Array may be **empty**, **single element**, or **have duplicates**

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[1,2,3,4,5]` | `true` | Strictly increasing |
| 2 | `[5,4,6,7,8]` | `false` | 5 > 4 → violation |
| 3 | `[1,1,1,1]` | `true` | All equal → non-decreasing |
| 4 | `[]` | `true` | Empty → trivially sorted |
| 5 | `[10]` | `true` | Single element |
| 6 | `[1,3,2,4]` | `false` | 3 > 2 |

---

## 4. Intuition & Core Thinking

> **"Non-decreasing" = Every element ≤ its next neighbor.**

Think of it like:  
> "I'm walking up a staircase. I should never go down."

Key Insight:  
- Just **compare each pair**: `arr[i] <= arr[i+1]`  
- If **any violation** → `false`  
- If **all pass** → `true`  
- **No need to look ahead more than 1 step**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Compare with All Future Elements

### Intuition  
For each element at `i`, check **all elements after it** → if any is smaller → not sorted.

### Why This Approach?  
- Matches literal definition  
- Easy to think  
- Teaches nested loops

### Why Move to Next?  
- **O(n²)** → TLE for large n  
- **Redundant comparisons**  
- **Overkill**

---

### Algorithm  
1. For `i` from 0 to n-2:  
  For `j` from i+1 to n-1:  
   If `arr[j] < arr[i]` → return `false`  
2. Return `true`

---

### Pseudocode  
``` 
function brute(arr):  
    for i from 0 to n-2:  
        for j from i+1 to n-1:  
            if arr[j] < arr[i]:  
                return false  
    return true
```

---

### Dry Run: [1, 3, 2]  
- i=0: j=1 → 3 ≥ 1, j=2 → 2 < 1 → **false**

---

### Code

#### C++
```cpp
bool brute(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[i]) return false;
        }
    }
    return true;
}
```

#### JavaScript
```js
function brute(arr) {
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[i]) return false;
        }
    }
    return true;
}
```

* Time Complexity: **O(n²)**  
* Space Complexity: **O(1)**

---

## Approach 2: Optimal – Single Traversal (Check Adjacent Pairs)

### Intuition  
> **You only need to check consecutive elements!**

If `arr[i] <= arr[i+1]` for all `i`, then the whole array is sorted.

### Why This Approach?  
- **O(n) time**  
- **O(1) space**  
- **Minimal comparisons**  
- **Interview favorite**

### Why This is Final?  
- **Optimal** — cannot do better than O(n)  
- **Simple & clean**  
- Handles **all edge cases**

---

### Algorithm  
1. If `n <= 1` → return `true`  
2. For `i` from 1 to n-1:  
  If `arr[i] < arr[i-1]` → return `false`  
3. Return `true`

---

### Pseudocode  
``` 
function isSorted(arr):  
    n = arr.length  
    if n <= 1: return true  
    for i from 1 to n-1:  
        if arr[i] < arr[i-1]:  
            return false  
    return true
```

---

### Dry Run: [1, 3, 2, 4]  
| i | arr[i] | arr[i-1] | arr[i] < arr[i-1]? |
|---|--------|----------|---------------------|
| 1 | 3      | 1        | No                  |
| 2 | 2      | 3        | Yes → **false**     |

---

### Code

#### C++
```cpp
bool optimal(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        if (arr[i] < arr[i - 1]) {
            return false;
        }
    }
    return true;
}
```

#### JavaScript
```js
function optimal(arr) {
    let n = arr.length;
    for (let i = 1; i < n; i++) {
        if (arr[i] < arr[i - 1]) {
            return false;
        }
    }
    return true;
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)**

---

## Approach 3: Using STL `is_sorted` (Production)

### Intuition  
Use language’s **optimized** built-in check.

### Why This?  
- **One-liner**  
- **Highly optimized**  
- **Real-world code**

### Why Not Always?  
- Interviewers want **logic**  
- May ask to implement manually

---

### Code

#### C++
```cpp
#include <algorithm>
bool stlApproach(vector<int>& arr) {
    return is_sorted(arr.begin(), arr.end());
}
```

#### JavaScript (No built-in → use reduce or loop)
```js
function reduceApproach(arr) {
    return arr.slice(1).every((val, i) => val >= arr[i]);
}
```

* Time: **O(n)**, Space: **O(1)**

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|---------|-------|----------|---------|
| Empty array | `[]` | `true` | Yes |
| Single element | `[5]` | `true` | Yes |
| All equal | `[2,2,2]` | `true` | Yes |
| Strictly increasing | `[1,2,3]` | `true` | Yes |
| Decreasing | `[3,2,1]` | `false` | Yes |
| One dip | `[1,3,2,4]` | `false` | Yes |
| Large numbers | `[1e9, 1e9]` | `true` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute (Nested) | O(n²) | O(1) | Learning |
| **Adjacent Check** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| STL / Built-in | O(n) | O(1) | Production |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute Force
    bool brute(vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[i]) return false;
            }
        }
        return true;
    }

    // Optimal: Single Pass
    bool optimal(vector<int>& arr) {
        int n = arr.size();
        for (int i = 1; i < n; i++) {
            if (arr[i] < arr[i - 1]) return false;
        }
        return true;
    }

    // STL
    bool stlApproach(vector<int>& arr) {
        return is_sorted(arr.begin(), arr.end());
    }
};
```

### JavaScript
```javascript
class Solution {
    // Brute
    brute(arr) {
        let n = arr.length;
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                if (arr[j] < arr[i]) return false;
            }
        }
        return true;
    }

    // Optimal
    optimal(arr) {
        let n = arr.length;
        for (let i = 1; i < n; i++) {
            if (arr[i] < arr[i - 1]) return false;
        }
        return true;
    }

    // Functional
    functional(arr) {
        return arr.slice(1).every((val, i) => val >= arr[i]);
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I'll check if the array is **non-decreasing** in **O(n) time**."  
2. "I'll loop from index 1 to n-1 and check if `arr[i] >= arr[i-1]`."  
3. "If any violation → return `false`. Else `true`."  
4. "Edge cases: empty or single element → `true`."  
5. **Bonus**: "Brute force is O(n²) — unnecessary. This is **optimal**."
