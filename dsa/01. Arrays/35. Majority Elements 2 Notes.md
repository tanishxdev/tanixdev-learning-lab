# Problem: Majority Elements (> N/3 times)  
**Find all elements that appear more than `N/3` times**

**GFG Link**: https://www.geeksforgeeks.org/problems/majority-element-1587115620/1  
**LeetCode**: https://leetcode.com/problems/majority-element-ii/

---

## 1. Problem Statement

**English**:  
Given an array of `N` integers, return **all elements** that appear **more than `N/3` times**.  
There can be **at most 2** such elements.

**Hinglish**:  
Array mein jo numbers `N/3` se zyada baar aaye ho, unko return karo.  
Max 2 hi ho sakte hain aise numbers.

---

## 2. Input / Output / Constraints

**Example 1**  
Input: `arr = [1,2,2,3,2]`  
Output: `[2]`

**Example 2**  
Input: `arr = [11,33,33,11,33,11]`  
Output: `[11, 33]`

**Constraints**:  
- `1 ≤ N ≤ 5*10⁴`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`

---

## 3. Examples (All Cases Covered)

| Input | Output | Why |
|------|--------|-----|
| `[1,2,2,3,2]` | `[2]` | 2 appears 3 times > 5/3=1 |
| `[11,33,33,11,33,11]` | `[11,33]` | both appear 3 times > 6/3=2 |
| `[1,1,1,1]` | `[1]` | 1 appears 4 times > 4/3=1 |
| `[1,2,3,4]` | `[]` | no element > 4/3 |
| `[2,2]` | `[]` | 2 appears 2 times == 2/3 → not greater |
| `[3,3,3,3,3]` | `[3]` | obvious |

---

# APPROACHES (Brute → Optimal) — All 3 with Full Commented Code

---

## Approach 1: Brute Force – Double Loop

### Intuition  
For every element → count its frequency → if > N/3 → add to answer

### Why This?  
- Easy to understand  
- Works always

### Why Move On?  
- O(N²) → TLE for large N

```cpp
// Brute Force - O(N²) Time, O(1) Space
vector<int> majorityElementBrute(vector<int>& arr) {
    int n = arr.size();
    vector<int> ans;
    vector<bool> visited(n, false);  // to avoid duplicates

    for (int i = 0; i < n; i++) {
        if (visited[i]) continue;

        int count = 0;
        for (int j = 0; j < n; j++) {
            if (arr[j] == arr[i]) {
                count++;
                visited[j] = true;  // mark all occurrences
            }
        }

        if (count > n / 3) {
            ans.push_back(arr[i]);
        }
    }
    return ans;
}
```

*Time: O(N²)*  
*Space: O(1)*

---

## Approach 2: Better – Using HashMap (Most Practical)

### Intuition  
Use a map to count frequency → then check who has count > N/3

### Why This?  
- Clean, readable  
- Works in O(N) average  
- Great for interviews when clarity matters

```cpp
// Better Approach - HashMap - O(N) Time, O(N) Space
vector<int> majorityElementBetter(vector<int>& arr) {
    int n = arr.size();
    unordered_map<int, int> freq;
    vector<int> ans;

    // Step 1: Count frequency of each element
    for (int num : arr) {
        freq[num]++;
    }

    // Step 2: Check who appears > N/3 times
    for (auto& it : freq) {
        if (it.second > n / 3) {
            ans.push_back(it.first);
        }
    }

    return ans;
}
```

*Time: O(N)*  
*Space: O(N)* → worst case all unique

---

## Approach 3: Optimal – Extended Boyer-Moore Voting Algorithm (Best)

### Intuition  
**At most 2 elements** can appear > N/3 times → maintain **2 candidates**

Like voting:  
- Same candidate → vote++  
- Different → cancel votes

After voting → manually verify the candidates

### Why This is Final?  
- **O(N) time**  
- **O(1) space**  
- **Genius algorithm** → Interview favorite

```cpp
// Optimal - Extended Boyer Moore Voting - O(N) Time, O(1) Space
vector<int> majorityElementOptimal(vector<int>& arr) {
    int n = arr.size();
    
    int cnt1 = 0, cnt2 = 0;     // vote counters
    int el1 = INT_MIN;          // candidate 1
    int el2 = INT_MIN;          // candidate 2

    // Phase 1: Find potential candidates
    for (int i = 0; i < n; i++) {
        if (cnt1 == 0 && el2 != arr[i]) {
            // cnt1 is zero → el1 is free to take new candidate
            cnt1 = 1;
            el1 = arr[i];
        }
        else if (cnt2 == 0 && el1 != arr[i]) {
            // cnt2 is zero → el2 can take new candidate
            cnt2 = 1;
            el2 = arr[i];
        }
        else if (arr[i] == el1) {
            cnt1++;                 // same as candidate 1 → vote++
        }
        else if (arr[i] == el2) {
            cnt2++;                 // same as candidate 2 → vote++
        }
        else {
            cnt1--;                 // different from both → cancel one vote each
            cnt2--;
        }
    }

    // Phase 2: Manually verify the candidates
    vector<int> ans;
    int actual_cnt1 = 0, actual_cnt2 = 0;

    for (int num : arr) {
        if (num == el1) actual_cnt1++;
        if (num == el2) actual_cnt2++;
    }

    int threshold = n / 3;
    if (actual_cnt1 > threshold) ans.push_back(el1);
    if (actual_cnt2 > threshold) ans.push_back(el2);

    return ans;
}
```

*Time: O(N)*  
*Space: O(1)* → **True optimal**

---

## 5. Edge Case List

| Case | Input | Expected | Handled? |
|------|------|----------|---------|
| No majority | `[1,2,3]` | `[]` | Yes |
| Exactly N/3+1 | `[2,2]` (N=5) | `[]` | Yes (`2` appears 2 ≤ 5/3) |
| Two candidates | `[1,1,1,2,2,2]` | `[1,2]` | Yes |
| Same candidate twice | `[1,1,1,1]` | `[1]` | Yes |
| Negative numbers | `[-1,-1,-1,2]` | `[-1]` | Yes |
| All same | `[5,5,5,5]` | `[5]` | Yes |

---

## 6. Complexity Summary

| Approach               | Time     | Space    | Best For |
|------------------------|----------|----------|----------|
| Brute (Double Loop)    | O(N²)    | O(1)     | Learning |
| HashMap (Better)       | O(N)     | O(N)     | Clean code |
| **Boyer-Moore (Optimal)** | **O(N)** | **O(1)** | **Interviews** |

**Use Boyer-Moore in interviews**  
**Use HashMap in production**

---

## 7. Final Consolidated Code (All 3 Approaches with Comments)

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute Force - O(N²)
    vector<int> brute(vector<int>& arr) {
        int n = arr.size();
        vector<int> ans;
        vector<bool> visited(n, false);

        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            int count = 0;
            for (int j = 0; j < n; j++) {
                if (arr[j] == arr[i]) {
                    count++;
                    visited[j] = true;
                }
            }
            if (count > n / 3) ans.push_back(arr[i]);
        }
        return ans;
    }

    // 2. Better - HashMap
    vector<int> better(vector<int>& arr) {
        int n = arr.size();
        unordered_map<int, int> freq;
        vector<int> ans;

        for (int num : arr) freq[num]++;

        for (auto& p : freq) {
            if (p.second > n / 3) {
                ans.push_back(p.first);
            }
        }
        return ans;
    }

    // 3. Optimal - Extended Boyer Moore Voting Algorithm
    vector<int> optimal(vector<int>& arr) {
        int n = arr.size();
        int cnt1 = 0, cnt2 = 0;
        int el1 = INT_MIN, el2 = INT_MIN;

        // Voting phase
        for (int num : arr) {
            if (cnt1 == 0 && el2 != num) {
                cnt1 = 1; el1 = num;
            }
            else if (cnt2 == 0 && el1 != num) {
                cnt2 = 1; el2 = num;
            }
            else if (num == el1) cnt1++;
            else if (num == el2) cnt2++;
            else { cnt1--; cnt2--; }
        }

        // Verification phase
        int c1 = 0, c2 = 0;
        for (int num : arr) {
            if (num == el1) c1++;
            if (num == el2) c2++;
        }

        vector<int> ans;
        if (c1 > n/3) ans.push_back(el1);
        if (c2 > n/3) ans.push_back(el2);

        return ans;
    }
};
```

### JavaScript
```javascript
class Solution {
    // Brute Force
    brute(arr) {
        let n = arr.length;
        let ans = [];
        let visited = new Array(n).fill(false);

        for (let i = 0; i < n; i++) {
            if (visited[i]) continue;
            let count = 0;
            for (let j = 0; j < n; j++) {
                if (arr[j] === arr[i]) {
                    count++;
                    visited[j] = true;
                }
            }
            if (count > Math.floor(n / 3)) ans.push(arr[i]);
        }
        return ans;
    }

    // HashMap
    better(arr) {
        let freq = new Map();
        let ans = [];

        for (let num of arr) {
            freq.set(num, (freq.get(num) || 0) + 1);
        }

        for (let [num, count] of freq) {
            if (count > Math.floor(arr.length / 3)) {
                ans.push(num);
            }
        }
        return ans;
    }

    // Optimal - Boyer Moore
    optimal(arr) {
        let n = arr.length;
        let cnt1 = 0, cnt2 = 0;
        let el1 = null, el2 = null;

        for (let num of arr) {
            if (cnt1 === 0 && el2 !== num) { cnt1 = 1; el1 = num; }
            else if (cnt2 === 0 && el1 !== num) { cnt2 = 1; el2 = num; }
            else if (num === el1) cnt1++;
            else if (num === el2) cnt2++;
            else { cnt1--; cnt2--; }
        }

        let c1 = 0, c2 = 0;
        for (let num of arr) {
            if (num === el1) c1++;
            if (num === el2) c2++;
        }

        let ans = [];
        if (c1 > n/3) ans.push(el1);
        if (c2 > n/3) ans.push(el2);
        return ans;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since at most 2 elements can appear > N/3 times, I’ll use **Extended Boyer-Moore** in O(N) time and O(1) space."
2. "We maintain two candidates and cancel votes."
3. "After voting, we verify manually — because voting can give false positives."
4. "HashMap is simpler but uses O(N) space."
5. "Brute is O(N²) — avoid."

**Boom. Full marks.**

---