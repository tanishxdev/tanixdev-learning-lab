# Problem: 4Sum – Find Unique Quadruplets That Sum to Target

**LeetCode**: https://leetcode.com/problems/4sum/  
**GFG**: https://www.geeksforgeeks.org/find-four-numbers-sum-x/

---

## 1. Problem Statement

**English**:  
Given an array of integers and a target value, return **all unique quadruplets** `[a,b,c,d]` such that:  
- `a + b + c + d == target`  
- Indices are **distinct**  
- No duplicate quadruplets (order doesn't matter)

**Hinglish**:  
Array + target diya hai → woh saare unique 4 numbers dhundho jinka sum target bane.  
Same quad baar-baar nahi aana chahiye.

---

## 2. Input / Output / Constraints

**Example 1**  
Input: `nums = [1,0,-1,0,-2,2]`, `target = 0`  
Output: `[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]`

**Example 2**  
Input: `nums = [2,2,2,2,2]`, `target = 8`  
Output: `[[2,2,2,2]]`

**Constraints**  
- `1 ≤ nums.length ≤ 200`  
- `-10⁹ ≤ nums[i], target ≤ 10⁹` → **Overflow risk!**

---

## 3. Examples (All Cases Covered)

| Input | Target | Output |
|------|--------|--------|
| `[1,0,-1,0,-2,2]` | 0 | 3 quads |
| `[1000000000,1000000000,1000000000,1000000000]` | -294967296 | `[]` (overflow case) |
| `[0,0,0,0]` | 0 | `[[0,0,0,0]]` |
| `[1,2,3,4,5]` | 10 | `[[1,2,3,4]]` |
| Duplicates heavy | `[4,3,3,4,4,2,1,2,1,1]` → 9 | `[[1,1,3,4],[1,2,2,4],[1,2,3,3]]` |

---

# APPROACHES (Brute → Optimal) – All 3 with Full Commented Code

---

## Approach 1: Brute Force – 4 Nested Loops + Set

```cpp
// Brute - O(N⁴) Time
vector<vector<int>> fourSumBrute(vector<int>& nums, int target) {
    int n = nums.size();
    set<vector<int>> st;

    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            for (int k = j+1; k < n; k++) {
                for (int l = k+1; l < n; l++) {
                    long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];
                    if (sum == target) {
                        vector<int> quad = {nums[i], nums[j], nums[k], nums[l]};
                        sort(quad.begin(), quad.end());
                        st.insert(quad);
                    }
                }
            }
        }
    }
    return vector<vector<int>>(st.begin(), st.end());
}
```

*Time: O(N⁴)* → TLE for large N

---

## Approach 2: Better – 3 Loops + HashSet

```cpp
// Better - O(N³) Time, O(N) Space
vector<vector<int>> fourSumBetter(vector<int>& nums, int target) {
    int n = nums.size();
    set<vector<int>> st;

    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            unordered_set<long long> seen;
            for (int k = j+1; k < n; k++) {
                long long required = (long long)target - nums[i] - nums[j] - nums[k];
                if (seen.count(required)) {
                    vector<int> quad = {nums[i], nums[j], nums[k], (int)required};
                    sort(quad.begin(), quad.end());
                    st.insert(quad);
                }
                seen.insert(nums[k]);
            }
        }
    }
    return vector<vector<int>>(st.begin(), st.end());
}
```

*Time: O(N³)*  
*Space: O(N)*

---

## Approach 3: Optimal – Sorting + Two Pointers (BEST)

```cpp
// Optimal - O(N³) Time, O(1) Extra Space
vector<vector<int>> fourSumOptimal(vector<int>& nums, int target) {
    int n = nums.size();
    vector<vector<int>> ans;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < n; i++) {
        if (i > 0 && nums[i] == nums[i-1]) continue;  // skip duplicate i

        for (int j = i+1; j < n; j++) {
            if (j > i+1 && nums[j] == nums[j-1]) continue;  // skip duplicate j

            int k = j + 1;
            int l = n - 1;

            while (k < l) {
                long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];

                if (sum == target) {
                    ans.push_back({nums[i], nums[j], nums[k], nums[l]});
                    
                    // skip duplicates for k and l
                    while (k < l && nums[k] == nums[k+1]) k++;
                    while (k < l && nums[l] == nums[l-1]) l--;

                    k++; l--;
                }
                else if (sum < target) k++;
                else l--;
            }
        }
    }
    return ans;
}
```

*Time: O(N³)*  
*Space: O(1)* → **True optimal**

---

## 5. Edge Case List

| Case | Handled? |
|------|--------|
| Overflow (`10⁹ + 10⁹ + ...`) | Use `long long` for sum |
| All same numbers | Skip duplicates properly |
| Negative target | Works |
| Zero target | Works |
| Large array (n=200) | Optimal passes |

---

## 6. Complexity Summary

| Approach | Time | Space | Verdict |
|--------|------|-------|-------|
| Brute (4 loops) | O(N⁴) | O(M) | TLE |
| Better (HashSet) | O(N³) | O(N) | AC |
| **Optimal (2Ptr)** | **O(N³)** | **O(1)** | **Best** |

**Always use Optimal in interviews**

---

## 7. Final Consolidated Code (All 3 – Fully Commented)

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute Force - 4 loops
    vector<vector<int>> brute(vector<int>& nums, int target) {
        int n = nums.size();
        set<vector<int>> st;

        for (int i = 0; i < n; i++)
            for (int j = i+1; j < n; j++)
                for (int k = j+1; k < n; k++)
                    for (int l = k+1; l < n; l++) {
                        long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];
                        if (sum == target) {
                            vector<int> q = {nums[i], nums[j], nums[k], nums[l]};
                            sort(q.begin(), q.end());
                            st.insert(q);
                        }
                    }
        return vector<vector<int>>(st.begin(), st.end());
    }

    // 2. Better - 3 loops + HashSet
    vector<vector<int>> better(vector<int>& nums, int target) {
        int n = nums.size();
        set<vector<int>> st;

        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                unordered_set<long long> seen;
                for (int k = j+1; k < n; k++) {
                    long long req = (long long)target - nums[i] - nums[j] - nums[k];
                    if (seen.count(req)) {
                        vector<int> q = {nums[i], nums[j], nums[k], (int)req};
                        sort(q.begin(), q.end());
                        st.insert(q);
                    }
                    seen.insert(nums[k]);
                }
            }
        }
        return vector<vector<int>>(st.begin(), st.end());
    }

    // 3. Optimal - Sorting + Two Pointers (BEST)
    vector<vector<int>> optimal(vector<int>& nums, int target) {
        vector<vector<int>> ans;
        int n = nums.size();
        sort(nums.begin(), nums.end());

        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i-1]) continue;

            for (int j = i+1; j < n; j++) {
                if (j > i+1 && nums[j] == nums[j-1]) continue;

                int k = j + 1;
                int l = n - 1;

                while (k < l) {
                    long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];

                    if (sum == target) {
                        ans.push_back({nums[i], nums[j], nums[k], nums[l]});
                        while (k < l && nums[k] == nums[k+1]) k++;
                        while (k < l && nums[l] == nums[l-1]) l--;
                        k++; l--;
                    }
                    else if (sum < target) k++;
                    else l--;
                }
            }
        }
        return ans;
    }
};
```

### JavaScript
```js
class Solution {
    optimal(nums, target) {
        nums.sort((a, b) => a - b);
        let ans = [];
        let n = nums.length;

        for (let i = 0; i < n; i++) {
            if (i > 0 && nums[i] === nums[i-1]) continue;

            for (let j = i+1; j < n; j++) {
                if (j > i+1 && nums[j] === nums[j-1]) continue;

                let k = j + 1;
                let l = n - 1;

                while (k < l) {
                    let sum = nums[i] + nums[j] + nums[k] + nums[l];

                    if (sum === target) {
                        ans.push([nums[i], nums[j], nums[k], nums[l]]);
                        while (k < l && nums[k] === nums[k+1]) k++;
                        while (k < l && nums[l] === nums[l-1]) l--;
                        k++; l--;
                    }
                    else if (sum < target) k++;
                    else l--;
                }
            }
        }
        return ans;
    }
}
```

---