# Problem: Longest Subarray with Sum K (Positives + Negatives)

**GFG Link**: https://www.geeksforgeeks.org/problems/longest-sub-array-with-sum-k/1  
**LeetCode (Similar)**: https://leetcode.com/problems/subarray-sum-equals-k/

---

## 1. Problem Statement

**English**:  
Given an array of **integers (positive + negative)** and a target sum `K`, find the **length of the longest subarray** whose sum equals `K`.

**Hinglish**:  
Array mein **positive aur negative** dono hain. **Sabse lamba subarray** dhundho jiska sum **K** ho.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [-1, 1, 1]`, `K = 1`  
**Output Expected**: `3` → `[-1,1,1]`

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- `-10¹⁴ ≤ K ≤ 10¹⁴`  
- **Elements can be negative, zero, or positive**

---

## 3. Examples (All Cases Covered)

| Example | Array | K | Output | Subarray |
|--------|-------|----|--------|----------|
| 1 | `[2,3,5]` | 5 | `2` | `[2,3]` |
| 2 | `[-1,1,1]` | 1 | `3` | `[-1,1,1]` |
| 3 | `[1,2,3]` | 10 | `0` | Not possible |
| 4 | `[0,0,0]` | 0 | `3` | Whole array |
| 5 | `[-5,8,3]` | 3 | `2` | `[8,3]` |
| 6 | `[1]` | 1 | `1` | `[1]` |

---

## 4. Intuition & Core Thinking

> **Two Pointers won't work** because **negative numbers** can **decrease sum** → no monotonicity.

Key Insight:  
Use **Prefix Sum + HashMap**  
- `prefixSum[i]` = sum from `0` to `i`  
- For subarray `[l+1, r]`:  
  `prefixSum[r] - prefixSum[l] = K`  
  → `prefixSum[l] = prefixSum[r] - K`

So, **store first occurrence** of each prefix sum in a map.

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Three Nested Loops

### Intuition  
Generate all subarrays → compute sum → track max length.

### Why This?  
- Easy  
- Covers all

### Why Move to Next?  
- **O(N³)** → too slow

---

### Code
```cpp
int brute(vector<int>& arr, int k) {
    int n = arr.size(), maxLen = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int sum = 0;
            for (int l = i; l <= j; l++) sum += arr[l];
            if (sum == k) maxLen = max(maxLen, j - i + 1);
        }
    }
    return maxLen;
}
```

* Time: **O(N³)**, Space: **O(1)** → **Poor**

---

## Approach 2: Better – Two Loops (Cumulative Sum)

### Intuition  
For each `i`, start `j = i`, keep adding → check sum.

### Why This?  
- **O(N²)**  
- Better than brute

### Why Move to Next?  
- Still slow  
- Can be optimized

---

### Code
```cpp
int better(vector<int>& arr, int k) {
    int n = arr.size(), maxLen = 0;
    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = i; j < n; j++) {
            sum += arr[j];
            if (sum == k) maxLen = max(maxLen, j - i + 1);
        }
    }
    return maxLen;
}
```

* Time: **O(N²)**, Space: **O(1)** → **Acceptable, not best**

---

## Approach 3: Optimal – Prefix Sum + HashMap

### Intuition  
> **Store first index** where each prefix sum occurs.

```text
If prefix[r] - prefix[l] = K
→ prefix[l] = prefix[r] - K
```

So:
- Compute `prefixSum` as we go  
- If `prefixSum - K` exists in map → `len = i - map[prefixSum - K]`

### Why This is Final?  
- **O(N)** time  
- **O(N)** space  
- **Works with negatives**  
- **Interview favorite**

---

### Algorithm  
``` 
map<prefixSum, firstIndex>
sum = 0, maxLen = 0

for i from 0 to n-1:
    sum += arr[i]
    
    if sum == k:
        maxLen = i + 1
    
    if (sum - k) in map:
        maxLen = max(maxLen, i - map[sum - k])
    
    if sum not in map:
        map[sum] = i
```

> **Only insert if not present** → to get **earliest index** → **maximum length**

---

### Dry Run: [-1, 1, 1], K=1

| i | arr[i] | sum | sum==1? | rem=sum-K | map[rem]? | len | map |
|---|--------|-----|--------|-----------|-----------|-----|-----|
| 0 | -1     | -1  | No     | -2        | No        | 0   | {-1:0} |
| 1 | 1      | 0   | No     | -1        | Yes (0)   | 1-0=1 | — |
| 2 | 1      | 1   | Yes    | 0         | Yes (1)   | 2-1=1 → **maxLen=3** | — |

**Final**: `3` → Correct!

---

### Edge Case: Why not update map?

```text
arr = [2, 0, 0, 3], K=3
```

| i | sum | rem | map[rem] | len |
|---|-----|-----|----------|-----|
| 0 | 2   | -1  | No       | — |
| 1 | 2   | -1  | No       | — | ← **Don't update** `2` again
| 2 | 2   | -1  | No       | — |
| 3 | 5   | 2   | Yes (0)  | 3-0=3 → Correct!

If updated → would get `3-2=1` → **Wrong!**

---

### Code

#### C++ (Optimal)
```cpp
int getLongestSubarray(vector<int>& arr, int k) {
    int n = arr.size();
    unordered_map<int, int> prefixMap;
    int sum = 0, maxLen = 0;

    for (int i = 0; i < n; i++) {
        sum += arr[i];

        // Case 1: sum == k
        if (sum == k) {
            maxLen = max(maxLen, i + 1);
        }

        // Case 2: sum - k exists
        int rem = sum - k;
        if (prefixMap.count(rem)) {
            maxLen = max(maxLen, i - prefixMap[rem]);
        }

        // Insert only if not present
        if (prefixMap.find(sum) == prefixMap.end()) {
            prefixMap[sum] = i;
        }
    }

    return maxLen;
}
```

#### JavaScript
```js
function longestSubarrayWithSumK(arr, k) {
    let n = arr.length;
    let prefixMap = new Map();
    let sum = 0;
    let maxLen = 0;

    for (let i = 0; i < n; i++) {
        sum += arr[i];

        if (sum === k) {
            maxLen = Math.max(maxLen, i + 1);
        }

        let rem = sum - k;
        if (prefixMap.has(rem)) {
            maxLen = Math.max(maxLen, i - prefixMap.get(rem));
        }

        if (!prefixMap.has(sum)) {
            prefixMap.set(sum, i);
        }
    }

    return maxLen;
}
```

* Time: **O(N)**, Space: **O(N)** → **BEST**

---

## 5. Edge Case List (Line-wise)

| Edge Case | Array | K | Expected | Handled? |
|---------|-------|----|----------|---------|
| All zeros | `[0,0,0]` | 0 | `3` | Yes |
| Negative only | `[-2,-1]` | -3 | `2` | Yes |
| No subarray | `[1,2]` | 10 | `0` | Yes |
| Single element | `[5]` | 5 | `1` | Yes |
| Repeated prefix | `[2,0,0,3]` | 3 | `3` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| 3 Loops | O(N³) | O(1) | Learning |
| 2 Loops | O(N²) | O(1) | Good |
| **Prefix + Map** | **O(N)** | **O(N)** | **Interviews (BEST)** |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute
    int brute(vector<int>& arr, int k) {
        int n = arr.size(), maxLen = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int sum = 0;
                for (int l = i; l <= j; l++) sum += arr[l];
                if (sum == k) maxLen = max(maxLen, j - i + 1);
            }
        }
        return maxLen;
    }

    // Better
    int better(vector<int>& arr, int k) {
        int n = arr.size(), maxLen = 0;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += arr[j];
                if (sum == k) maxLen = max(maxLen, j - i + 1);
            }
        }
        return maxLen;
    }

    // Optimal: Prefix Sum + Map
    int longestSubarrayWithSumK(vector<int>& arr, int k) {
        int n = arr.size();
        unordered_map<int, int> prefixMap;
        int sum = 0, maxLen = 0;

        for (int i = 0; i < n; i++) {
            sum += arr[i];

            if (sum == k) {
                maxLen = max(maxLen, i + 1);
            }

            int rem = sum - k;
            if (prefixMap.count(rem)) {
                maxLen = max(maxLen, i - prefixMap[rem]);
            }

            if (prefixMap.find(sum) == prefixMap.end()) {
                prefixMap[sum] = i;
            }
        }

        return maxLen;
    }
};
```

### JavaScript
```javascript
class Solution {
    // Optimal
    longestSubarrayWithSumK(arr, k) {
        let n = arr.length;
        let prefixMap = new Map();
        let sum = 0;
        let maxLen = 0;

        for (let i = 0; i < n; i++) {
            sum += arr[i];

            if (sum === k) {
                maxLen = Math.max(maxLen, i + 1);
            }

            let rem = sum - k;
            if (prefixMap.has(rem)) {
                maxLen = Math.max(maxLen, i - prefixMap.get(rem));
            }

            if (!prefixMap.has(sum)) {
                prefixMap.set(sum, i);
            }
        }

        return maxLen;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since array has **negatives**, Two Pointers won't work. I’ll use **Prefix Sum + HashMap** — **O(N) time**, **O(N) space**."  
2. "I store **first occurrence** of each prefix sum."  
3. "For current sum `x`, check if `x - K` exists → if yes, `len = i - map[x-K]`."  
4. "Edge case: repeated prefix sums → **only store first index** to maximize length."  
5. **Bonus**: "Brute is O(N³), Better is O(N²). This is **optimal**."

---
