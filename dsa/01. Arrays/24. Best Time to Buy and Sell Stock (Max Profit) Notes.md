# Problem: Best Time to Buy and Sell Stock (Max Profit)

**GFG Link**: https://www.geeksforgeeks.org/problems/stock-buy-and-sell-1587115621/1  
**LeetCode (Same)**: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

---

## 1. Problem Statement

**English**:  
Given an array `prices` where `prices[i]` is the price of a stock on the `i-th` day, find the **maximum profit** by **buying on one day** and **selling on a later day**.  
Return `0` if no profit is possible.

**Hinglish**:  
Stock ke prices diye hain — ek din **buy** karo, ek future din **sell** karo → **max profit** chahiye. Loss ho to `0` return karo.

---

## 2. Input / Output / Constraints

**Input Example**:  
`prices = [7, 1, 5, 3, 6, 4]`  
**Output Expected**: `5`  
*(Buy at 1, sell at 6 → 6-1 = 5)*

**Constraints**:  
- `1 ≤ prices.length ≤ 10⁵`  
- `0 ≤ prices[i] ≤ 10⁴`

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[7,1,5,3,6,4]` | `5` | Buy at 1, sell at 6 |
| 2 | `[7,6,4,3,1]` | `0` | Decreasing → no profit |
| 3 | `[1]` | `0` | Only one day |
| 4 | `[2,4,1]` | `2` | Buy at 2, sell at 4 |
| 5 | `[3,3,3]` | `0` | No change |
| 6 | `[1,2,3,4,5]` | `4` | Buy at 1, sell at 5 |

---

## 4. Intuition & Core Thinking

> **"To maximize profit, buy at the lowest price before selling at the highest."**

But we **must sell after buying** → so we track:
- **Lowest price seen so far**
- **Max profit = current price − min price so far**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Check All Pairs

### Intuition  
Try **every possible buy and sell pair** where `i < j`.

### Why This Approach?  
- Natural thinking  
- Covers all possibilities  
- Easy to code

### Why Move to Next?  
- **O(n²)** → TLE for large `n`  
- Redundant comparisons  
- **Not scalable**

---

### Algorithm  
1. `maxProfit = 0`  
2. For `i` from `0` to `n-2`:  
  For `j` from `i+1` to `n-1`:  
   if `prices[j] > prices[i]`:  
    `maxProfit = max(maxProfit, prices[j] - prices[i])`  
3. Return `maxProfit`

---

### Pseudocode  
``` 
function brute(prices):  
    maxP = 0  
    for i from 0 to n-2:  
        for j from i+1 to n-1:  
            if prices[j] > prices[i]:  
                maxP = max(maxP, prices[j] - prices[i])  
    return maxP
```

---

### Dry Run: [7,1,5,3,6,4]  
- i=0 (7): j=1 to 5 → no profit  
- i=1 (1): j=2(5)→4, j=3(3)→2, j=4(6)→**5**, j=5(4)→3 → max = 5  
- i=2 (5): j=3(3)→no, j=4(6)→1, j=5(4)→no  
→ Final: `5`

---

### Code

#### C++
```cpp
int brute(vector<int>& prices) {
    int maxP = 0;
    int n = prices.size();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (prices[j] > prices[i]) {
                maxP = max(maxP, prices[j] - prices[i]);
            }
        }
    }
    return maxP;
}
```

#### JavaScript
```js
function brute(prices) {
    let maxP = 0;
    for (let i = 0; i < prices.length; i++) {
        for (let j = i + 1; j < prices.length; j++) {
            if (prices[j] > prices[i]) {
                maxP = Math.max(maxP, prices[j] - prices[i]);
            }
        }
    }
    return maxP;
}
```

* Time: **O(n²)**, Space: **O(1)**

---

## Approach 2: Optimal – One Pass (Track Min Price)

### Intuition  
> **"The best time to sell today is if I had bought at the lowest price in the past."**

So:
- Keep track of **minimum price seen so far**
- At each day, compute `profit = price[i] - minPrice`
- Update `maxProfit` if better

### Why This Approach?  
- **O(n) time**  
- **O(1) space**  
- **Single pass**  
- **Greedy & elegant**

### Why This is Final?  
- **Cannot do better than O(n)** — must scan all prices  
- **Handles all cases**  
- **Interview favorite**

---

### Algorithm  
1. `minPrice = INT_MAX`, `maxProfit = 0`  
2. For each `price` in `prices`:  
  `minPrice = min(minPrice, price)`  
  `maxProfit = max(maxProfit, price - minPrice)`  
3. Return `maxProfit`

---

### Pseudocode  
``` 
function optimal(prices):  
    minPrice = INF  
    maxProfit = 0  
    for price in prices:  
        minPrice = min(minPrice, price)  
        maxProfit = max(maxProfit, price - minPrice)  
    return maxProfit
```

---

### Dry Run: [7,1,5,3,6,4]

| Day | Price | minPrice | Profit (price - min) | maxProfit |
|-----|-------|----------|----------------------|-----------|
| 0 | 7 | 7 | 0 | 0 |
| 1 | 1 | **1** | 0 | 0 |
| 2 | 5 | 1 | 4 | **4** |
| 3 | 3 | 1 | 2 | 4 |
| 4 | 6 | 1 | **5** | **5** |
| 5 | 4 | 1 | 3 | 5 |

→ Final Answer: `5`

---

### Code

#### C++
```cpp
int optimal(vector<int>& prices) {
    int minPrice = INT_MAX;
    int maxProfit = 0;
    for (int price : prices) {
        minPrice = min(minPrice, price);
        maxProfit = max(maxProfit, price - minPrice);
    }
    return maxProfit;
}
```

#### JavaScript
```js
function optimal(prices) {
    let minPrice = Infinity;
    let maxProfit = 0;
    for (let price of prices) {
        minPrice = Math.min(minPrice, price);
        maxProfit = Math.max(maxProfit, price - minPrice);
    }
    return maxProfit;
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)**

---

## Approach 3: STL / Built-in (Not Needed)

No direct STL for this. Custom loop is **cleanest**.

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|---------|-------|----------|---------|
| Empty array | `[]` | `0` | Yes (loop skipped) |
| n = 1 | `[5]` | `0` | Yes |
| Decreasing | `[7,6,4,3,1]` | `0` | Yes |
| Increasing | `[1,2,3,4,5]` | `4` | Yes |
| Profit at end | `[1,2,3,10]` | `9` | Yes |
| Profit early | `[10,1,2]` | `1` | Yes |
| All same | `[3,3,3]` | `0` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute Force | O(n²) | O(1) | Learning |
| **One Pass (Min Tracking)** | **O(n)** | **O(1)** | **Interviews (Optimal)** |

**Use One Pass Greedy Approach**

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute Force
    int brute(vector<int>& prices) {
        int maxP = 0;
        int n = prices.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (prices[j] > prices[i]) {
                    maxP = max(maxP, prices[j] - prices[i]);
                }
            }
        }
        return maxP;
    }

    // 2. Optimal: One Pass
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int maxProfit = 0;
        for (int price : prices) {
            minPrice = min(minPrice, price);
            maxProfit = max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
};
```

### JavaScript
```javascript
class Solution {
    // 1. Brute
    brute(prices) {
        let maxP = 0;
        for (let i = 0; i < prices.length; i++) {
            for (let j = i + 1; j < prices.length; j++) {
                if (prices[j] > prices[i]) {
                    maxP = Math.max(maxP, prices[j] - prices[i]);
                }
            }
        }
        return maxP;
    }

    // 2. Optimal
    maxProfit(prices) {
        let minPrice = Infinity;
        let maxProfit = 0;
        for (let price of prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I’ll use a **single pass** to track the **minimum price seen so far**."
2. "At each day, compute `profit = price - minPrice`, update `maxProfit`."
3. "Also update `minPrice` if current price is lower."
4. "Time: **O(n)**, Space: **O(1)** — optimal."
5. **Bonus**:  
   - "This is **greedy** — we don't need to know when to buy/sell exactly."  
   - "Brute force is O(n²) — unnecessary."  
   - "Same logic extends to **multiple transactions** later."
