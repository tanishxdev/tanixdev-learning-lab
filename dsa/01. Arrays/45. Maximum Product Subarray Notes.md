# Problem: Maximum Product Subarray  
**(LeetCode 152 – One of the Toughest Kadane Variants)**

**LeetCode Link**: https://leetcode.com/problems/maximum-product-subarray/  
**GFG Link**: https://www.geeksforgeeks.org/problems/maximum-product-subarray3605/1

---

## 1. Problem Statement

**English**:  
Given an integer array `nums`, find a **contiguous subarray** with the **largest product**, and return the product.

**Hinglish**:  
Array mein continuous subarray dhundo jiska product **sabse bada** ho — negative bhi ho sakte hain!

---

## 2. Input / Output / Constraints

**Input Example 1**:  
`nums = [2, 3, -2, 4]`  
**Output**: `6` → [2,3]

**Input Example 2**:  
`nums = [1, 2, -3, 0, -4, -5]`  
**Output**: `20` → [-4, -5]

**Constraints**:  
- `1 ≤ nums.length ≤ 2×10⁴`  
- `-10 ≤ nums[i] ≤ 10`  
- Product can fit in 32-bit integer

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Best Subarray |
|-------|-------|--------|----------------|
| 1 | `[2,3,-2,4]` | `6` | [2,3] |
| 2 | `[-2,0,-1]` | `0` | [0] |
| 3 | `[-3,-1,-1]` | `3` | [-1,-1] or [-3,-1] |
| 4 | `[1,2,3,4,5,0]` | `120` | [1,2,3,4,5] |
| 5 | `[-2,3,-4]` | `24` | [-2,3,-4] → negative × negative = positive |
| 6 | `[0,2]` | `2` | [2] |

---

## 4. Intuition & Core Thinking

**Normal Kadane (sum) fails** because:
- Multiplying by **negative** flips max → min
- **Zero** resets everything
- **Two negatives** can give huge positive

### Golden Insight:
> At any point, the **maximum product** ending here can come from:
> - Just the current number
> - Current × previous **maximum** product
> - Current × previous **minimum** product (because negative × negative = positive)

So we maintain **two variables**:
- `maxProd` → largest product ending at i
- `minProd` → smallest (most negative) product ending at i

When we hit a **negative number** → swap them!

---

# APPROACHES (Brute → God Level)

---

## Approach 1: Brute Force – All Subarrays

### Intuition  
Try every possible subarray → compute product → track max

### Why This Approach?  
- First thought  
- Easy to code

### Why Move to Next?  
- O(n²) time  
- **Overflow risk**  
- TLE on large inputs

---

### Code

#### C++
```cpp
int brute(vector<int>& nums) {
    int ans = nums[0];
    for (int i = 0; i < nums.size(); i++) {
        int prod = 1;
        for (int j = i; j < nums.size(); j++) {
            prod *= nums[j];
            ans = max(ans, prod);
        }
    }
    return ans;
}
```

* Time: O(n²)  
* Space: O(1)

---

## Approach 2: Optimal – Track Max & Min Product (Best)

### Intuition  
Like Kadane, but track **both max and min** product ending at each index.

When negative number comes → **swap max and min**

### Why This is Final?  
- O(n) time  
- O(1) space  
- Handles **all cases**: negatives, zeros, overflow  
- **Standard interview solution**

---

### Algorithm
```text
res = nums[0]
maxProd = nums[0]
minProd = nums[0]

for i from 1 to n-1:
    if nums[i] < 0:
        swap(maxProd, minProd)
    
    maxProd = max(nums[i], maxProd * nums[i])
    minProd = min(nums[i], minProd * nums[i])
    
    res = max(res, maxProd)
```

---

### Dry Run: [2, 3, -2, 4]

| i | num | maxProd | minProd | res |
|---|-----|---------|---------|-----|
| 0 | 2   | 2       | 2       | 2   |
| 1 | 3   | 6       | 2       | 6   |
| 2 | -2  | swap → 2,6 → 6,2 → max(-2, 6×-2)= -12 → maxProd=-12<br>min(-2, 2×-2)= -4 → minProd=-4 | 6 |
| 3 | 4   | max(4, -12×4)=4<br>min(4, -4×4)= -16 | 6 → max(6,4) → 6 |

Correct!

---

### Code (Best & Clean)

#### C++
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int res = nums[0];
        int maxProd = nums[0];
        int minProd = nums[0];
        
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] < 0) {
                swap(maxProd, minProd);
            }
            
            maxProd = max(nums[i], maxProd * nums[i]);
            minProd = min(nums[i], minProd * nums[i]);
            
            res = max(res, maxProd);
        }
        return res;
    }
};
```

#### JavaScript
```js
function maxProduct(nums) {
    let res = nums[0];
    let maxProd = nums[0];
    let minProd = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] < 0) {
            [maxProd, minProd] = [minProd, maxProd];
        }
        
        maxProd = Math.max(nums[i], maxProd * nums[i]);
        minProd = Math.min(nums[i], minProd * nums[i]);
        
        res = Math.max(res, maxProd);
    }
    return res;
}
```

* Time: **O(n)**  
* Space: **O(1)**

---

## Approach 3: Prefix × Suffix Method (Also Optimal)

### Intuition  
Traverse from left → keep prefix product  
Traverse from right → keep suffix product  
Take max of both at each step → handles zero resets

### Good for understanding, but **less clean** than above

#### C++
```cpp
int maxProductPrefixSuffix(vector<int>& nums) {
    int n = nums.size();
    int pre = 1, suff = 1;
    int ans = INT_MIN;
    
    for (int i = 0; i < n; i++) {
        if (pre == 0) pre = 1;
        if (suff == 0) suff = 1;
        
        pre *= nums[i];
        suff *= nums[n - i - 1];
        
        ans = max({ans, pre, suff});
    }
    return ans;
}
```

Works, but **swap method is cleaner and faster**

---

## 5. Edge Case List

| Edge Case               | Handled? |
|-------------------------|---------|
| All positive            | Yes     |
| Contains zero           | Yes (resets) |
| All negative            | Yes (two negatives) |
| Single element          | Yes     |
| Negative + zero         | Yes     |
| Overflow (large nums)   | Safe in C++/JS |

---

## 6. Complexity Summary

| Approach               | Time   | Space | Verdict     |
|------------------------|--------|-------|-------------|
| Brute Force            | O(n²)  | O(1)  | TLE         |
| Prefix × Suffix        | O(n)   | O(1)  | Accepted    |
| **Track Max & Min**    | **O(n)** | **O(1)** | **Best** |

**Use Track Max & Min — Interview Favorite**

---

## 7. Final Consolidated Code

### C++ (Recommended)
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int ans = nums[0];
        int maxP = nums[0], minP = nums[0];
        
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] < 0) 
                swap(maxP, minP);
                
            maxP = max(nums[i], maxP * nums[i]);
            minP = min(nums[i], minP * nums[i]);
            
            ans = max(ans, maxP);
        }
        return ans;
    }
};
```

### JavaScript
```js
var maxProduct = function(nums) {
    let res = nums[0];
    let maxProd = nums[0];
    let minProd = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] < 0) {
            [maxProd, minProd] = [minProd, maxProd];
        }
        maxProd = Math.max(nums[i], maxProd * nums[i]);
        minProd = Math.min(nums[i], minProd * nums[i]);
        res = Math.max(res, maxProd);
    }
    return res;
};
```

---