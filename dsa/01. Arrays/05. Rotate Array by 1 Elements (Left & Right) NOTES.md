#include <bits/stdc++.h>
using namespace std;

// ðŸ§  Problem : 
// Example : 
// Constraint : 

// ðŸ”´ Approach 1 Brute Force : 
// Intuition :
// Algo :
// TC :
// SC :
// Edge cases :
void leftRotateBrute(vector<int>& arr) {
    int n = arr.size();

    // If the array has 0 or 1 elements, rotation has no effect
    if (n <= 1) return;

    // Temporary array to store the rotated result
    vector<int> temp(n);

    // Shift elements one position to the left
    // arr[1] â†’ temp[0]
    // arr[2] â†’ temp[1]
    // ...
    for (int i = 1; i < n; i++) {
        temp[i - 1] = arr[i];
    }

    // The first element moves to the last position
    temp[n - 1] = arr[0];

    // Copy the rotated array back to the original array
    arr = temp;
}

void rightRotateBrute(vector<int>& arr) {
    int n = arr.size();

    // If the array has 0 or 1 elements, rotation has no effect
    if (n <= 1) return;

    // Temporary array to store the rotated result
    vector<int> temp(n);

    // Shift elements one position to the right
    // arr[n-2] â†’ temp[n-1]
    // arr[n-3] â†’ temp[n-2]
    // ...
    // arr[0]   â†’ temp[1]
    for (int i = n - 2; i >= 0; i--) {
        temp[i + 1] = arr[i];
    }

    // The last element moves to the first position
    temp[0] = arr[n - 1];

    // Copy the rotated array back to the original array
    arr = temp;
}
// ðŸ”µ Approach 2 Better : 
// Intuition :
// Algo :
// TC :
// SC :
// Edge cases :
void leftRotateBetter(vector<int>& arr) {
    int n = arr.size();

    // If array has 0 or 1 elements, rotation does nothing
    if (n <= 1) return;

    // Store the first element because it will move to the end
    int first = arr[0];

    // Shift every element one position to the left
    // arr[1] â†’ arr[0]
    // arr[2] â†’ arr[1]
    // ...
    for (int i = 0; i < n - 1; i++) {
        arr[i] = arr[i + 1];
    }

    // Place the original first element at the end
    arr[n - 1] = first;
}

void rightRotateBetter(vector<int>& arr) {
    int n = arr.size();

    // If array has 0 or 1 elements, rotation does nothing
    if (n <= 1) return;

    // Store the last element because it will move to the front
    int last = arr[n - 1];

    // Shift elements one position to the right
    // arr[n-2] â†’ arr[n-1]
    // arr[n-3] â†’ arr[n-2]
    // ...
    for (int i = n - 1; i > 0; i--) {
        arr[i] = arr[i - 1];
    }

    // Place the original last element at the front
    arr[0] = last;
}

// ðŸŸ¢ Approach 3 Optimal: --> Reverse Algorithm

// Intuition :
// For Left Rotation by 1:

// Reverse first 1 element
// Reverse remaining n-1
// Reverse the whole array

// For Right Rotation by 1:

// Reverse last 1 element
// Reverse first n-1
// Reverse whole array

// This method works for any k, not just 1.

// Algo :
// TC : O(n)
// SC : O(1)
// Edge cases :
int main()
{
    vector<int> arr1 = {10, 20, 30, 40, 50};
    vector<int> arr2 = {10, 20, 30, 40, 50};

    cout << "Original Array: ";
    for (int x : arr1) cout << x << " ";
    cout << endl;

    // Approach 1
    
    // LEFT ROTATION
    leftRotateBrute(arr1);
    cout << "Array after LEFT rotation: ";
    for (int x : arr1) cout << x << " ";
    cout << endl;
    
    // RIGHT ROTATION
    rightRotateBrute(arr2);
    cout << "Array after RIGHT rotation: ";
    for (int x : arr2) cout << x << " ";
    cout << endl;
    
    // Approach 2 
    
    vector<int> arr3 = {10, 20, 30, 40, 50};
    vector<int> arr4 = {10, 20, 30, 40, 50};

    // LEFT ROTATION (Better)
    leftRotateBetter(arr3);
    cout << "Array after LEFT rotation (Better): ";
    for (int x : arr3) cout << x << " ";
    cout << endl;
    
    // RIGHT ROTATION (Better)
    rightRotateBetter(arr4);
    cout << "Array after RIGHT rotation (Better): ";
    for (int x : arr4) cout << x << " ";
    cout << endl;
    
    // Approach 3 Optimal
    
    vector<int> arr5 = {10, 20, 30, 40, 50};
    vector<int> arr6 = {10, 20, 30, 40, 50};
    cout << endl;
}