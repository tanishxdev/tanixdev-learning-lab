# Problem: Count Inversions in an Array  
**(Striver’s Favorite – Merge Sort Magic)**

**GFG Link**: https://www.geeksforgeeks.org/problems/inversion-of-array/1  
**LeetCode Similar**: Count of Smaller Numbers After Self (Hard)

---

## 1. Problem Statement

**English**:  
Given an array of `N` integers, count the **number of inversions**.  
An inversion is a pair `(i, j)` where:  
`i < j` and `arr[i] > arr[j]`

**Hinglish**:  
Array mein kitne pairs hain jahan bada element pehle hai aur chhota baad mein → unko count karo.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [5, 3, 2, 1, 4]`  
**Output Expected**: `7`  
Pairs: (5,3), (5,2), (5,1), (5,4), (3,2), (3,1), (2,1)

**Constraints**:  
- `1 ≤ N ≤ 10⁵`  
- `1 ≤ arr[i] ≤ 10⁹`

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[1,2,3,4,5]` | `0` | Sorted → no inversion |
| 2 | `[5,4,3,2,1]` | `10` | Reverse sorted → max inversions = n*(n-1)/2 |
| 3 | `[5,3,2,1,4]` | `7` | As above |
| 4 | `[2,4,1,3,5]` | `3` | (2,1), (4,1), (4,3) |
| 5 | `[1]` | `0` | Single element |
| 6 | `[10,10,10]` | `0` | Equal elements → no inversion |

---

## 4. Intuition & Core Thinking

> **Brute force is O(n²)** → too slow for n = 10⁵  
> But **Merge Sort** can count inversions **while sorting**!

### Golden Insight:
During merge step:  
When we take an element from **right half** before **left half** →  
→ **All remaining elements in left half** form inversion with this right element!

So instead of counting 1 by 1 → we count **whole block** in one go!

---

# APPROACHES (Brute → God Level)

---

## Approach 1: Brute Force – Two Nested Loops

### Intuition  
Check every pair `(i,j)` where `i < j` → if `arr[i] > arr[j]` → count++

### Why This Approach?  
- First thing that comes to mind  
- Easy to code

### Why Move to Next?  
- O(N²) → **TLE** for N = 10⁵  
- Not acceptable

---

### Algorithm  
```text
count = 0
for i from 0 to n-1:
    for j from i+1 to n-1:
        if arr[i] > arr[j]:
            count++
return count
```

---

### Dry Run: [5,3,2]  
- i=0 (5): j=1(3) → yes, j=2(2) → yes → +2  
- i=1 (3): j=2(2) → yes → +1  
→ Total = 3

---

### Code

#### C++
```cpp
long long brute(vector<int>& arr) {
    int n = arr.size();
    long long cnt = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] > arr[j]) cnt++;
        }
    }
    return cnt;
}
```

#### JavaScript
```js
function brute(arr) {
    let cnt = 0;
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] > arr[j]) cnt++;
        }
    }
    return cnt;
}
```

* Time: O(N²)  
* Space: O(1)

---

## Approach 2: Optimal – Modified Merge Sort (The Real Deal)

### Intuition  
Use **merge sort** but **count inversions during merge**!

When merging two sorted halves:  
→ If we pick `right` element first → all remaining `left` elements > this → add `(mid - left + 1)`

### Why This Approach?  
- O(N log N)  
- Uses divide & conquer  
- **Interviewers LOVE this**

### Why This is Final?  
- **Only optimal solution**  
- Used in real applications  
- Shows deep understanding

---

### Algorithm (Modified Merge)

```text
merge(arr, low, mid, high):
    temp = []
    left = low, right = mid+1
    cnt = 0

    while left <= mid and right <= high:
        if arr[left] <= arr[right]:
            temp.push(arr[left++])
        else:
            temp.push(arr[right++])
            cnt += (mid - left + 1)   // MAGIC LINE
    // copy remaining
    return cnt

mergeSort(arr, low, high):
    if low >= high return 0
    mid = (low + high) / 2
    cnt = mergeSort(left) + mergeSort(right) + merge(low,mid,high)
    return cnt
```

---

### Dry Run: [5,3,2,1,4]

```
Split → [5,3,2] | [1,4]
Split → [5] | [3,2]     [1] | [4]
Split → [3] | [2]

Merge [3,2]:
   3 > 2 → take 2 → cnt += (1-0+1) = 1 → [2,3]

Merge [5] + [2,3]:
   5 > 2 → take 2 → cnt += 1 = 1
   5 > 3 → take 3 → cnt += 1 = 2 → [2,3,5]

Merge [2,3,5] + [1,4]:
   2 > 1 → take 1 → cnt += 3 = 3
   3 > 1 → already taken
   5 > 1 → already taken
   5 > 4 → take 4 → cnt += 1 = 4 → [1,2,3,4,5]
Total = 1 (from [3,2]) + 2 (from [5,3,2]) + 4 = 7
```

---

### Code (Full Working)

#### C++
```cpp
class Solution {
private:
    long long merge(vector<int>& arr, int low, int mid, int high) {
        vector<int> temp;
        int left = low, right = mid + 1;
        long long cnt = 0;

        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.push_back(arr[left++]);
            } else {
                temp.push_back(arr[right++]);
                cnt += (mid - left + 1);  // All remaining in left > current right
            }
        }
        while (left <= mid) temp.push_back(arr[left++]);
        while (right <= high) temp.push_back(arr[right++]);

        for (int i = low; i <= high; i++) {
            arr[i] = temp[i - low];
        }
        return cnt;
    }

    long long mergeSort(vector<int>& arr, int low, int high) {
        if (low >= high) return 0;
        int mid = (low + high) / 2;
        long long cnt = 0;
        cnt += mergeSort(arr, low, mid);
        cnt += mergeSort(arr, mid + 1, high);
        cnt += merge(arr, low, mid, high);
        return cnt;
    }

public:
    long long countInversions(vector<int>& arr) {
        return mergeSort(arr, 0, arr.size() - 1);
    }
};
```

#### JavaScript
```js
function merge(arr, low, mid, high, temp) {
    let left = low, right = mid + 1;
    let cnt = 0;

    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push(arr[left++]);
        } else {
            temp.push(arr[right++]);
            cnt += (mid - left + 1);
        }
    }
    while (left <= mid) temp.push(arr[left++]);
    while (right <= high) temp.push(arr[right++]);

    for (let i = low; i <= high; i++) {
        arr[i] = temp[i - low];
    }
    return cnt;
}

function mergeSort(arr, low, high, temp) {
    if (low >= high) return 0;
    let mid = Math.floor((low + high) / 2);
    let cnt = 0;
    cnt += mergeSort(arr, low, mid, temp);
    cnt += mergeSort(arr, mid + 1, high, temp);
    cnt += merge(arr, low, mid, high, temp);
    return cnt;
}

function countInversions(arr) {
    let temp = [];
    return mergeSort(arr, 0, arr.length - 1, temp);
}
```

* Time Complexity: **O(N log N)**  
* Space Complexity: **O(N)** (temp array)

---

## 5. Edge Case List

| Edge Case | Handled? |
|---------|---------|
| Already sorted | Yes (0) |
| Reverse sorted | Yes (max = n*(n-1)/2) |
| Duplicates | Yes (`<=` used → equals not counted) |
| n = 1 | Yes |
| Large numbers | Use `long long` for count |

---

## 6. Complexity Summary

| Approach       | Time         | Space   | Best For           |
|----------------|--------------|---------|--------------------|
| Brute Force    | O(N²)        | O(1)    | Learning           |
| **Merge Sort** | **O(N log N)** | **O(N)** | **Interviews (Only way)** |

**Only Merge Sort is acceptable**

---

## 7. Final Consolidated Code

### C++
```cpp
class Solution {
public:
    long long merge(vector<int>& arr, int low, int mid, int high) {
        vector<int> temp;
        int left = low, right = mid + 1;
        long long cnt = 0;

        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.push_back(arr[left++]);
            } else {
                temp.push_back(arr[right++]);
                cnt += (mid - left + 1);
            }
        }
        while (left <= mid) temp.push_back(arr[left++]);
        while (right <= high) temp.push_back(arr[right++]);

        for (int i = low; i <= high; i++) arr[i] = temp[i - low];
        return cnt;
    }

    long long mergeSort(vector<int>& arr, int low, int high) {
        if (low >= high) return 0;
        int mid = (low + high) / 2;
        long long cnt = mergeSort(arr, low, mid);
        cnt += mergeSort(arr, mid + 1, high);
        cnt += merge(arr, low, mid, high);
        return cnt;
    }

    long long countInversions(vector<int>& arr) {
        return mergeSort(arr, 0, arr.size() - 1);
    }
};
```

### JavaScript
```js
function countInversions(arr) {
    function merge(low, mid, high) {
        let left = low, right = mid + 1;
        let temp = [], cnt = 0;

        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.push(arr[left++]);
            } else {
                temp.push(arr[right++]);
                cnt += (mid - left + 1);
            }
        }
        while (left <= mid) temp.push(arr[left++]);
        while (right <= high) temp.push(arr[right++]);

        for (let i = low; i <= high; i++) arr[i] = temp[i - low];
        return cnt;
    }

    function mergeSort(low, high) {
        if (low >= high) return 0;
        let mid = Math.floor((low + high) / 2);
        let cnt = mergeSort(low, mid);
        cnt += mergeSort(mid + 1, high);
        cnt += merge(low, mid, high);
        return cnt;
    }

    return mergeSort(0, arr.length - 1);
}
```

---
