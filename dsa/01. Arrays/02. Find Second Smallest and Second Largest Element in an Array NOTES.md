# Problem: Find Second Smallest and Second Largest Element in an Array

**GFG Link**: https://www.geeksforgeeks.org/problems/second-smallest-and-second-largest-element-in-an-array/1  
**LeetCode (Similar)**: N/A (Custom Problem)

---

## 1. Problem Statement

**English**:  
Given an array of integers, find the **second smallest** and **second largest** elements.  
If either does **not exist**, return `-1` for that part.

**Hinglish**:  
Array mein **dusra sabse chhota** aur **dusra sabse bada** number dhundho. Agar nahi hai to `-1` return karo.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [1, 2, 4, 7, 7, 5]`  
**Output Expected**:  
```
Second Smallest: 2
Second Largest: 5
```

**Constraints**:  
- `0 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- Array may have **duplicates**, **negatives**, **zeros**

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[1,2,4,7,7,5]` | `2`, `5` | Normal case with duplicates |
| 2 | `[1]` | `-1`, `-1` | Only one element |
| 3 | `[]` | `-1`, `-1` | Empty array |
| 4 | `[5,5,5]` | `-1`, `-1` | All same → no second |
| 5 | `[1,2]` | `2`, `1` | Small array |
| 6 | `[-1, -5, -3]` | `-3`, `-1` | All negative |

---

## 4. Intuition & Core Thinking

> **Goal**: Find **second** extreme values → need to **track two largest and two smallest** in **one pass**.

Think like:  
> "I'm walking through numbers. I keep updating the **king** and **prince** of small and large."

Key Insight:  
- **One traversal** → O(n)  
- Handle **duplicates** → skip if equal to current min/max  
- Initialize smartly: `small = ∞`, `second_small = ∞`

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Sorting

### Intuition  
Sort → second smallest = `arr[1]`, second largest = `arr[n-2]`

### Why This Approach?  
- Super easy  
- Works always  
- Teaches indexing

### Why Move to Next?  
- **O(n log n)** → slow  
- **Modifies array**  
- **Overkill** for just 2 values

---

### Algorithm  
1. If `n < 2` → return `-1, -1`  
2. Sort array  
3. Return `arr[1]`, `arr[n-2]`

---

### Pseudocode  
``` 
function sortApproach(arr):  
    if arr.length < 2: return -1, -1  
    sort(arr)  
    return arr[1], arr[arr.length-2]
```

---

### Dry Run: [1,2,4,7,7,5]  
→ Sort: [1,2,4,5,7,7]  
→ Second Smallest: `2`, Second Largest: `7` → **Wrong!** (should be 5)

> **Fails with duplicates!**

---

### Code (Flawed)

#### C++
```cpp
pair<int,int> sortApproach(vector<int>& arr) {
    if (arr.size() < 2) return {-1, -1};
    sort(arr.begin(), arr.end());
    return {arr[1], arr[arr.size()-2]}; // Wrong if duplicates
}
```

* Time: O(n log n), Space: O(1)  
**Fails on duplicates**

---

## Approach 2: Two-Pass Linear Scan (Better)

### Intuition  
1. First pass: Find `min` and `max`  
2. Second pass: Find number **strictly > min** and **strictly < max**

### Why This Approach?  
- Handles **duplicates**  
- O(n) time  
- Clear logic

### Why Move to Next?  
- **Two passes** → can be done in **one**

---

### Algorithm  
1. Find `small`, `large`  
2. Traverse again:  
  `second_small` = min of (x where x > small)  
  `second_large` = max of (x where x < large)

---

### Code

#### C++
```cpp
pair<int,int> twoPass(vector<int>& arr) {
    int n = arr.size();
    if (n < 2) return {-1, -1};

    int small = INT_MAX, large = INT_MIN;
    for (int x : arr) {
        small = min(small, x);
        large = max(large, x);
    }

    int second_small = INT_MAX, second_large = INT_MIN;
    for (int x : arr) {
        if (x > small) second_small = min(second_small, x);
        if (x < large) second_large = max(second_large, x);
    }

    if (second_small == INT_MAX) second_small = -1;
    if (second_large == INT_MIN) second_large = -1;

    return {second_small, second_large};
}
```

* Time: **O(n)**, Space: **O(1)**

---

## Approach 3: Single-Pass (Optimal)

### Intuition  
Update **both** second_small and second_large **on the fly**.

**For Second Smallest**:  
- If `x < small` → `second_small = small`, `small = x`  
- Else if `x < second_small` and `x != small` → `second_small = x`

**For Second Largest**: Same logic with `>`

### Why This Approach?  
- **O(n) time**, **O(1) space**  
- **One traversal**  
- **Handles duplicates**  
- **Interview favorite**

### Why This is Final?  
- **Optimal**  
- Elegant comparisons  
- Production-ready

---

### Algorithm  
``` 
second_small = ∞, small = ∞
second_large = -∞, large = -∞

for each x in arr:
    // Second Smallest
    if x < small:
        second_small = small
        small = x
    else if x < second_small && x != small:
        second_small = x

    // Second Largest
    if x > large:
        second_large = large
        large = x
    else if x > second_large && x != large:
        second_large = x

Return second_small (or -1), second_large (or -1)
```

---

### Dry Run: [1,2,4,7,7,5]

| x | small | second_small | large | second_large |
|---|-------|---------------|-------|---------------|
| 1 | 1     | ∞             | 1     | -∞            |
| 2 | 1     | 2             | 2     | 1             |
| 4 | 1     | 2             | 4     | 2             |
| 7 | 1     | 2             | 7     | 4             |
| 7 | 1     | 2             | 7     | 4             |
| 5 | 1     | 2             | 7     | 5             |

**Final**: `2`, `5`

---

### Code

#### C++
```cpp
pair<int,int> optimal(vector<int>& arr) {
    int n = arr.size();
    if (n < 2) return {-1, -1};

    int small = INT_MAX, second_small = INT_MAX;
    int large = INT_MIN, second_large = INT_MIN;

    for (int x : arr) {
        // Second Smallest
        if (x < small) {
            second_small = small;
            small = x;
        } else if (x < second_small && x != small) {
            second_small = x;
        }

        // Second Largest
        if (x > large) {
            second_large = large;
            large = x;
        } else if (x > second_large && x != large) {
            second_large = x;
        }
    }

    if (second_small == INT_MAX) second_small = -1;
    if (second_large == INT_MIN) second_large = -1;

    return {second_small, second_large};
}
```

#### JavaScript
```js
function optimal(arr) {
    let n = arr.length;
    if (n < 2) return [-1, -1];

    let small = Infinity, second_small = Infinity;
    let large = -Infinity, second_large = -Infinity;

    for (let x of arr) {
        if (x < small) {
            second_small = small;
            small = x;
        } else if (x < second_small && x !== small) {
            second_small = x;
        }

        if (x > large) {
            second_large = large;
            large = x;
        } else if (x > second_large && x !== large) {
            second_large = x;
        }
    }

    return [
        second_small === Infinity ? -1 : second_small,
        second_large === -Infinity ? -1 : second_large
    ];
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)**

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|---------|-------|----------|---------|
| Empty | `[]` | `-1,-1` | Yes |
| n=1 | `[5]` | `-1,-1` | Yes |
| All same | `[3,3,3]` | `-1,-1` | Yes |
| Duplicates | `[1,2,2,3]` | `2,2` | Yes |
| Negative | `[-5,-1,-3]` | `-3,-1` | Yes |
| Max at start | `[10,1,2]` | `2,2` | Yes |
| Min at end | `[3,2,1]` | `2,2` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Sorting | O(n log n) | O(1) | Learning |
| Two-Pass | O(n) | O(1) | Clarity |
| **Single-Pass** | **O(n)** | **O(1)** | **Interviews (Optimal)** |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Sorting (Flawed with duplicates)
    pair<int,int> sortApproach(vector<int>& arr) {
        if (arr.size() < 2) return {-1, -1};
        sort(arr.begin(), arr.end());
        return {arr[1], arr[arr.size()-2]}; // Wrong if duplicates
    }

    // Two-Pass
    pair<int,int> twoPass(vector<int>& arr) {
        int n = arr.size();
        if (n < 2) return {-1, -1};

        int small = INT_MAX, large = INT_MIN;
        for (int x : arr) {
            small = min(small, x);
            large = max(large, x);
        }

        int ss = INT_MAX, sl = INT_MIN;
        for (int x : arr) {
            if (x > small) ss = min(ss, x);
            if (x < large) sl = max(sl, x);
        }

        return {ss == INT_MAX ? -1 : ss, sl == INT_MIN ? -1 : sl};
    }

    // Optimal: Single Pass
    pair<int,int> optimal(vector<int>& arr) {
        int n = arr.size();
        if (n < 2) return {-1, -1};

        int small = INT_MAX, second_small = INT_MAX;
        int large = INT_MIN, second_large = INT_MIN;

        for (int x : arr) {
            if (x < small) {
                second_small = small;
                small = x;
            } else if (x < second_small && x != small) {
                second_small = x;
            }

            if (x > large) {
                second_large = large;
                large = x;
            } else if (x > second_large && x != large) {
                second_large = x;
            }
        }

        return {
            second_small == INT_MAX ? -1 : second_small,
            second_large == INT_MIN ? -1 : second_large
        };
    }
};
```

### JavaScript
```javascript
class Solution {
    // Sorting (Flawed)
    sortApproach(arr) {
        if (arr.length < 2) return [-1, -1];
        arr.sort((a,b) => a-b);
        return [arr[1], arr[arr.length-2]];
    }

    // Optimal: Single Pass
    optimal(arr) {
        let n = arr.length;
        if (n < 2) return [-1, -1];

        let small = Infinity, second_small = Infinity;
        let large = -Infinity, second_large = -Infinity;

        for (let x of arr) {
            if (x < small) {
                second_small = small;
                small = x;
            } else if (x < second_small && x !== small) {
                second_small = x;
            }

            if (x > large) {
                second_large = large;
                large = x;
            } else if (x > second_large && x !== large) {
                second_large = x;
            }
        }

        return [
            second_small === Infinity ? -1 : second_small,
            second_large === -Infinity ? -1 : second_large
        ];
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I’ll solve this in **O(n) time, O(1) space** using **single traversal**."  
2. "I’ll maintain 4 variables: `small`, `second_small`, `large`, `second_large`."  
3. "Update them using smart comparisons — skip if equal to current min/max."  
4. "Edge cases: n < 2, all duplicates → return `-1`."  
5. **Bonus**: "Sorting fails with duplicates. Two-pass works but single-pass is optimal."

---