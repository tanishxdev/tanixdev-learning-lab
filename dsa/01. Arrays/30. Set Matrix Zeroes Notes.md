# Problem: Set Matrix Zeroes  
**(If an element is 0, set its entire row and column to 0)**

**LeetCode**: https://leetcode.com/problems/set-matrix-zeroes/  
**GFG**: https://www.geeksforgeeks.org/problems/make-matrix-zeroes/1

---

## 1. Problem Statement

**English**:  
Given an `m x n` integer matrix, if `matrix[i][j] == 0`, set the **entire row i** and **entire column j** to `0`. Do it **in-place**.

**Hinglish**:  
Matrix mein agar koi cell 0 hai → uski poori row aur poori column ko 0 kar do. **Extra space nahi chahiye!**

---

## 2. Input / Output / Constraints

**Input Example**:  
```
matrix = [
  [1, 1, 1],
  [1, 0, 1],
  [1, 1, 1]
]
```
**Output Expected**:
```
[
  [1, 0, 1],
  [0, 0, 0],
  [1, 0, 1]
]
```

**Constraints**:  
- `1 ≤ m, n ≤ 200`  
- `-2³¹ ≤ matrix[i][j] ≤ 2³¹ - 1`

---

## 3. Examples (All Cases Covered)

| Example | Input Matrix | Output Matrix | Why |
|-------|--------------|----------------|-----|
| 1 | `[[1,1,1],[1,0,1],[1,1,1]]` | `[[1,0,1],[0,0,0],[1,0,1]]` | Standard case |
| 2 | `[[0,1,2,0],[3,4,5,2],[1,3,1,5]]` | `[[0,0,0,0],[0,4,5,0],[0,3,1,0]]` | Multiple zeros |
| 3 | `[[1,2,3],[4,5,6],[7,8,9]]` | Same | No zero |
| 4 | `[[0]]` | `[[0]]` | 1×1 with zero |
| 5 | `[[1]]` | `[[1]]` | 1×1 no zero |
| 6 | First row has zero | → Entire first row becomes 0 | Critical edge |

---

## 4. Intuition & Core Thinking

> **Challenge**: We cannot mark cells immediately with 0 (it will affect later decisions)  
> **Solution**: Use the matrix **itself** as memory to track which rows/columns need to be zeroed.

Think of the matrix like a **flag board**:
- Use **first row** → to mark columns that need to be zero
- Use **first column** → to mark rows that need to be zero
- Use a **separate flag `col0`** for the first column (because `matrix[0][0]` is shared)

**Order matters!** Process inner matrix first → then first row → then first column.

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Mark with -1 (When No Negatives)

### Intuition  
Find 0 → mark entire row & column with `-1` → finally convert all `-1` to `0`.

### Why This Approach?  
- Easy to understand  
- Follows problem logic directly

### Why Move to Next?  
- **O((N×M)×(N+M))** → Too slow  
- Fails if matrix has negative numbers

---

### Code (C++)
```cpp
void markRow(vector<vector<int>>& mat, int i, int m) {
    for (int j = 0; j < m; j++)
        if (mat[i][j] != 0) mat[i][j] = -1;
}
void markCol(vector<vector<int>>& mat, int j, int n) {
    for (int i = 0; i < n; i++)
        if (mat[i][j] != 0) mat[i][j] = -1;
}

void brute(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat[i][j] == 0) {
                markRow(mat, i, m);
                markCol(mat, j, n);
            }
        }
    }
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (mat[i][j] == -1) mat[i][j] = 0;
}
```

* Time: **O((N×M)×(N+M)) + O(N×M)** → Very slow  
* Space: **O(1)**

---

## Approach 2: Better – Two Extra Arrays (row[], col[])

### Intuition  
Use two boolean arrays:
- `row[i] = true` → row i must be zero
- `col[j] = true` → column j must be zero

### Why Move to Next?  
- Still uses **O(n + m)** extra space  
- Can be optimized further

---

### Code (C++)
```cpp
void better(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    vector<int> row(n, 0), col(m, 0);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (mat[i][j] == 0) {
                row[i] = 1;
                col[j] = 1;
            }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (row[i] || col[j])
                mat[i][j] = 0;
}
```

* Time: **O(2×N×M)**  
* Space: **O(N + M)**

---

## Approach 3: Optimal – O(1) Space Using Matrix Itself

### Intuition  
**Use first row & first column as flags**  
- `matrix[i][0] = 0` → row i should be zero  
- `matrix[0][j] = 0` → column j should be zero  
- Use `col0` variable for first column (since `matrix[0][0]` is shared)

**Crucial Order**:
1. Mark flags in first row/col
2. Zero out inner matrix `(1,1)` to `(n-1,m-1)`
3. Zero out first row (using `matrix[0][0]`)
4. Zero out first column (using `col0`)

### Why This is Final?  
- **O(1) space**  
- **O(N×M)** time  
- **LeetCode accepted**  
- **Interview gold standard**

---

### Dry Run: `[[1,1,1],[1,0,1],[1,1,1]]`

| Step | Action | Matrix |
|------|------|--------|
| Start | Find 0 at (1,1) → mark `mat[1][0]=0`, `mat[0][1]=0` | `[[1,0,1],[0,0,1],[1,1,1]]` |
| Inner fill | For each cell (i≥1,j≥1): if `mat[i][0]==0 or mat[0][j]==0` → set 0 | Done |
| First row | `mat[0][0]==0` → set entire row 0 to 0 | `[[0,0,0],[0,0,0],[0,0,0]]` wait no! Wrong order! |
| Correct: First inner → then row → then col | Final correct result | See code |

---

### Code (Optimal)

#### C++
```cpp
void setZeroes(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    int col0 = 1;  // Tracks if first column needs zero

    // Step 1: Mark first row & col (use col0 for first col)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat[i][j] == 0) {
                mat[i][0] = 0;           // Mark row
                if (j != 0)
                    mat[0][j] = 0;       // Mark col
                else
                    col0 = 0;
            }
        }
    }

    // Step 2: Fill inner matrix (1,1) to (n-1,m-1)
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            if (mat[i][0] == 0 || mat[0][j] == 0) {
                mat[i][j] = 0;
            }
        }
    }

    // Step 3: Fill first row (if needed)
    if (mat[0][0] == 0) {
        for (int j = 0; j < m; j++) mat[0][j] = 0;
    }

    // Step 4: Fill first column (if needed)
    if (col0 == 0) {
        for (int i = 0; i < n; i++) mat[i][0] = 0;
    }
}
```

#### JavaScript
```js
function setZeroes(mat) {
    let n = mat.length, m = mat[0].length;
    let col0 = 1;

    // Step 1: Mark flags
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (mat[i][j] === 0) {
                mat[i][0] = 0;
                if (j !== 0) mat[0][j] = 0;
                else col0 = 0;
            }
        }
    }

    // Step 2: Zero inner cells
    for (let i = 1; i < n; i++) {
        for (let j = 1; j < m; j++) {
            if (mat[i][0] === 0 || mat[0][j] === 0) {
                mat[i][j] = 0;
            }
        }
    }

    // Step 3: Zero first row
    if (mat[0][0] === 0) {
        for (let j = 0; j < m; j++) mat[0][j] = 0;
    }

    // Step 4: Zero first col
    if (col0 === 0) {
        for (let i = 0; i < n; i++) mat[i][0] = 0;
    }
}
```

* Time Complexity: **O(N × M)**  
* Space Complexity: **O(1)** → Truly in-place!

---

## 5. Edge Case List

| Edge Case | Handled? |
|---------|--------|
| Matrix has 0 in first row/col | Yes (`col0` flag) |
| Multiple 0s | Yes |
| No 0s | Yes |
| 1×1 matrix | Yes |
| All zeros | Yes |
| Only one row or one column | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute (-1 marking) | O((N×M)×(N+M)) | O(1) | Learning only |
| Two arrays | O(2×N×M) | O(N+M) | Good |
| **O(1) Space (Optimal)** | **O(2×N×M)** | **O(1)** | **Interviews + Production** |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute
    void brute(vector<vector<int>>& mat) { /* as above */ }

    // Better
    void better(vector<vector<int>>& mat) { /* as above */ }

    // Optimal O(1) Space
    void setZeroes(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        int col0 = 1;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == 0) {
                    mat[i][0] = 0;
                    if (j != 0) mat[0][j] = 0;
                    else col0 = 0;
                }
            }
        }

        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (mat[i][0] == 0 || mat[0][j] == 0)
                    mat[i][j] = 0;
            }
        }

        if (mat[0][0] == 0)
            for (int j = 0; j < m; j++) mat[0][j] = 0;
        if (col0 == 0)
            for (int i = 0; i < n; i++) mat[i][0] = 0;
    }
};
```

### JavaScript
```javascript
class Solution {
    optimal(mat) {
        let n = mat.length, m = mat[0].length;
        let col0 = 1;

        for (let i = 0; i < n; i++) {
            for (let j = 0; j < m; j++) {
                if (mat[i][j] === 0) {
                    mat[i][0] = 0;
                    if (j !== 0) mat[0][j] = 0;
                    else col0 = 0;
                }
            }
        }

        for (let i = 1; i < n; i++) {
            for (let j = 1; j < m; j++) {
                if (mat[i][0] === 0 || mat[0][j] === 0)
                    mat[i][j] = 0;
            }
        }

        if (mat[0][0] === 0)
            for (let j = 0; j < m; j++) mat[0][j] = 0;
        if (col0 === 0)
            for (let i = 0; i < n; i++) mat[i][0] = 0;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "We need **in-place**, so O(1) space. I’ll use the first row and first column as flags."
2. "But `matrix[0][0]` is shared → so I’ll use a `col0` variable."
3. "First, mark flags while scanning."
4. "Then zero inner matrix `(1,1)` → `(n-1,m-1)`"
5. "Finally zero first row and first column in correct order."
6. "Time: O(N×M), Space: O(1) — **optimal**."
