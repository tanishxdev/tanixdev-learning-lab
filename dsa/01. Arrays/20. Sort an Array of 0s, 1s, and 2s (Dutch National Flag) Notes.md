# Problem: Sort an Array of 0s, 1s, and 2s (Dutch National Flag)

**GFG Link**: https://www.geeksforgeeks.org/problems/sort-an-array-of-0s-1s-and-2s/1  
**LeetCode (Same)**: https://leetcode.com/problems/sort-colors/

---

## 1. Problem Statement

**English**:  
Given an array containing only `0`, `1`, and `2`, sort it **in-place** in **single pass** using **constant space**.

**Hinglish**:  
Sirf 0, 1, 2 wala array hai — ek hi pass mein sort karo, extra space nahi, in-place karo.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [2, 0, 2, 1, 1, 0]`  
**Output Expected**: `[0, 0, 1, 1, 2, 2]`

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `arr[i] ∈ {0, 1, 2}`

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[2,0,2,1,1,0]` | `[0,0,1,1,2,2]` | Standard case |
| 2 | `[0,1,2]` | `[0,1,2]` | Already sorted |
| 3 | `[2,2,2]` | `[2,2,2]` | All same |
| 4 | `[1]` | `[1]` | n = 1 |
| 5 | `[0,0,0,1,1,1,2,2,2]` | `[0,0,0,1,1,1,2,2,2]` | Large groups |
| 6 | `[1,0,2,1,0,2]` | `[0,0,1,1,2,2]` | Mixed |

---

## 4. Intuition & Core Thinking

> **Think of it like organizing red, white, blue balls — Dutch National Flag!**

We use **3 pointers**:
- `low` → boundary for `0`s
- `mid` → current element under consideration
- `high` → boundary for `2`s

**Rules**:
- `arr[0..low-1]` → all `0`s
- `arr[low..mid-1]` → all `1`s
- `arr[high+1..n-1]` → all `2`s
- `arr[mid..high]` → unsorted (we scan this)

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Sorting

### Intuition  
Use built-in sort — it will arrange in order.

### Why This Approach?  
- Simple  
- Works for any values  
- Good for learning

### Why Move to Next?  
- **O(n log n)** → not single pass  
- Uses **sorting algorithm internally**  
- **Fails expected constraint**

---

### Code

#### C++
```cpp
void brute(vector<int>& arr) {
    sort(arr.begin(), arr.end());
}
```

* Time: **O(n log n)**, Space: **O(1)** → **Not allowed**

---

## Approach 2: Better – Count Frequency (Two Pass)

### Intuition  
Count how many `0`, `1`, `2` → then **overwrite** array in order.

### Why This Approach?  
- **O(n) time**  
- **O(1) space**  
- Easy to understand  
- **Two passes**

### Why Move to Next?  
- **Not single pass**  
- Can be done in **one pass** → more efficient

---

### Algorithm  
1. Count `cnt0`, `cnt1`, `cnt2`  
2. Fill first `cnt0` positions with `0`  
3. Next `cnt1` with `1`  
4. Rest with `2`

---

### Pseudocode  
``` 
function countSort(arr):  
    cnt0 = cnt1 = cnt2 = 0  
    for num in arr:  
        if num == 0: cnt0++  
        else if num == 1: cnt1++  
        else: cnt2++  
    i = 0  
    while cnt0--: arr[i++] = 0  
    while cnt1--: arr[i++] = 1  
    while cnt2--: arr[i++] = 2
```

---

### Dry Run: [2,0,1,2,0,1]  
- Count: `cnt0=2`, `cnt1=2`, `cnt2=2`  
- Fill:  
  `i=0,1 → 0`  
  `i=2,3 → 1`  
  `i=4,5 → 2`  
→ `[0,0,1,1,2,2]`

---

### Code

#### C++
```cpp
void countSort(vector<int>& arr) {
    int cnt0 = 0, cnt1 = 0, cnt2 = 0;
    for (int num : arr) {
        if (num == 0) cnt0++;
        else if (num == 1) cnt1++;
        else cnt2++;
    }
    int i = 0;
    while (cnt0--) arr[i++] = 0;
    while (cnt1--) arr[i++] = 1;
    while (cnt2--) arr[i++] = 2;
}
```

#### JavaScript
```js
function countSort(arr) {
    let cnt0 = 0, cnt1 = 0, cnt2 = 0;
    for (let num of arr) {
        if (num === 0) cnt0++;
        else if (num === 1) cnt1++;
        else cnt2++;
    }
    let i = 0;
    while (cnt0--) arr[i++] = 0;
    while (cnt1--) arr[i++] = 1;
    while (cnt2--) arr[i++] = 2;
}
```

* Time: **O(n)**, Space: **O(1)** → **Two passes**

---

## Approach 3: Optimal – Dutch National Flag (One Pass)

### Intuition  
**Three pointers**: `low`, `mid`, `high`  
- `mid` scans the array  
- Swap based on `arr[mid]`

**Rules**:
| `arr[mid]` | Action |
|-----------|--------|
| `0` | Swap with `low`, `low++`, `mid++` |
| `1` | Just `mid++` |
| `2` | Swap with `high`, `high--` |

> **Why no `mid++` when swap with `high`?**  
> Because the swapped value might be `0` or `1` → needs rechecking.

---

### Algorithm  
``` 
low = mid = 0, high = n-1  
while mid <= high:  
    if arr[mid] == 0:  
        swap(arr[low], arr[mid])  
        low++, mid++  
    else if arr[mid] == 1:  
        mid++  
    else:  
        swap(arr[mid], arr[high])  
        high--
```

---

### Dry Run: [2,0,2,1,1,0]

| Step | mid | arr[mid] | Action | Array After |
|------|-----|----------|--------|-------------|
| 1 | 0 | 2 | swap(0,5) → high-- | `[0,0,2,1,1,2]`, high=4 |
| 2 | 0 | 0 | swap(0,0) → low++,mid++ | `[0,0,2,1,1,2]`, low=1,mid=1 |
| 3 | 1 | 0 | swap(1,1) → low++,mid++ | `[0,0,2,1,1,2]`, low=2,mid=2 |
| 4 | 2 | 2 | swap(2,4) → high-- | `[0,0,1,1,2,2]`, high=3 |
| 5 | 2 | 1 | mid++ | `[0,0,1,1,2,2]`, mid=3 |
| 6 | 3 | 1 | mid++ | `[0,0,1,1,2,2]`, mid=4 |
| 7 | 4 | 2 | swap(4,3) → high-- | `[0,0,1,1,2,2]`, high=2 |
| → Done (mid > high)

---

### Code

#### C++
```cpp
void dutchFlag(vector<int>& arr) {
    int low = 0, mid = 0, high = arr.size() - 1;
    while (mid <= high) {
        if (arr[mid] == 0) {
            swap(arr[low++], arr[mid++]);
        }
        else if (arr[mid] == 1) {
            mid++;
        }
        else {
            swap(arr[mid], arr[high--]);
        }
    }
}
```

#### JavaScript
```js
function dutchFlag(arr) {
    let low = 0, mid = 0, high = arr.length - 1;
    while (mid <= high) {
        if (arr[mid] === 0) {
            [arr[low], arr[mid]] = [arr[mid], arr[low]];
            low++; mid++;
        }
        else if (arr[mid] === 1) {
            mid++;
        }
        else {
            [arr[mid], arr[high]] = [arr[high], arr[mid]];
            high--;
        }
    }
}
```

* Time Complexity: **O(n)** → **Single Pass**  
* Space Complexity: **O(1)** → **In-place**

---

## Approach 4: STL / Built-in (Not Allowed)

```cpp
sort(arr.begin(), arr.end()); // O(n log n) → not allowed
```

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|---------|-------|----------|---------|
| n = 1 | `[1]` | `[1]` | Yes |
| All 0s | `[0,0,0]` | `[0,0,0]` | Yes |
| All 1s | `[1,1]` | `[1,1]` | Yes |
| All 2s | `[2,2,2]` | `[2,2,2]` | Yes |
| Already sorted | `[0,1,2]` | `[0,1,2]` | Yes |
| Reverse sorted | `[2,1,0]` | `[0,1,2]` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Single Pass? | Best For |
|--------|------|-------|--------------|----------|
| Sorting | O(n log n) | O(1) | No | Learning |
| Count Frequency | O(n) | O(1) | No (2 passes) | Simple logic |
| **Dutch Flag** | **O(n)** | **O(1)** | **Yes** | **Interviews (Optimal)** |

**Use Dutch National Flag Algorithm**

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute: Sorting
    void brute(vector<int>& arr) {
        sort(arr.begin(), arr.end());
    }

    // 2. Count Frequency (Two Pass)
    void countFreq(vector<int>& arr) {
        int cnt0 = 0, cnt1 = 0, cnt2 = 0;
        for (int num : arr) {
            if (num == 0) cnt0++;
            else if (num == 1) cnt1++;
            else cnt2++;
        }
        int i = 0;
        while (cnt0--) arr[i++] = 0;
        while (cnt1--) arr[i++] = 1;
        while (cnt2--) arr[i++] = 2;
    }

    // 3. Optimal: Dutch National Flag (One Pass)
    void dutchFlag(vector<int>& arr) {
        int low = 0, mid = 0, high = (int)arr.size() - 1;
        while (mid <= high) {
            if (arr[mid] == 0) {
                swap(arr[low++], arr[mid++]);
            }
            else if (arr[mid] == 1) {
                mid++;
            }
            else {
                swap(arr[mid], arr[high--]);
            }
        }
    }
};
```

### JavaScript
```javascript
class Solution {
    // 1. Brute
    brute(arr) {
        arr.sort((a, b) => a - b);
    }

    // 2. Count Frequency
    countFreq(arr) {
        let cnt0 = 0, cnt1 = 0, cnt2 = 0;
        for (let num of arr) {
            if (num === 0) cnt0++;
            else if (num === 1) cnt1++;
            else cnt2++;
        }
        let i = 0;
        while (cnt0--) arr[i++] = 0;
        while (cnt1--) arr[i++] = 1;
        while (cnt2--) arr[i++] = 2;
    }

    // 3. Optimal: Dutch Flag
    dutchFlag(arr) {
        let low = 0, mid = 0, high = arr.length - 1;
        while (mid <= high) {
            if (arr[mid] === 0) {
                [arr[low], arr[mid]] = [arr[mid], arr[low]];
                low++; mid++;
            }
            else if (arr[mid] === 1) {
                mid++;
            }
            else {
                [arr[mid], arr[high]] = [arr[high], arr[mid]];
                high--;
            }
        }
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since only 3 values, I can use **Dutch National Flag** in **one pass**."
2. "Three pointers: `low`, `mid`, `high`"
3. "Rules:  
   - `0` → swap with `low`, move both  
   - `1` → skip  
   - `2` → swap with `high`, only move `high`"
4. "Time: **O(n)**, Space: **O(1)**, **Single pass** — optimal."
5. **Bonus**: "This is same as LeetCode 'Sort Colors' — very common in interviews."
