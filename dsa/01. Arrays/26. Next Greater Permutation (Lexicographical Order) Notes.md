# Problem: Next Greater Permutation (Lexicographical Order)

**GFG Link**: https://www.geeksforgeeks.org/problems/next-permutation/1  
**LeetCode Link**: https://leetcode.com/problems/next-permutation/

---

## 1. Problem Statement

**English**:  
Given an array of integers, rearrange it to form the **lexicographically next greater permutation**.  
If no greater permutation exists (i.e., current is the last), return the **smallest permutation** (sorted in ascending order).

**Hinglish**:  
Array ko aise rearrange karo ki uska **next bada permutation** bane. Agar last wala hai to **sabse chhota** (sorted) bana do.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [1, 2, 3]`  
**Output Expected**: `[1, 3, 2]`

**Constraints**:  
- `1 ≤ arr.length ≤ 100`  
- `0 ≤ arr[i] ≤ 100`  
- May contain **duplicates**

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[1,2,3]` | `[1,3,2]` | Next after 123 |
| 2 | `[3,2,1]` | `[1,2,3]` | Last → return first |
| 3 | `[1,1,5]` | `[1,5,1]` | With duplicates |
| 4 | `[1]` | `[1]` | Single element |
| 5 | `[1,3,2]` | `[2,1,3]` | Normal case |
| 6 | `[2,3,1]` | `[3,1,2]` | Peak at end |

---

## 4. Intuition & Core Thinking

> Think of the array as a **number**:  
> `[1,2,3]` → number `123`  
> Next permutation → `132`

**Goal**: Increase the number **as little as possible**.

**Steps**:
1. Find the **first dip** from the right: `arr[i] < arr[i+1]` → this is where we can **increase**
2. From the right, find the **smallest number > arr[i]** → swap with it
3. Reverse everything after `i` → makes it **smallest possible**

If **no dip** → array is **descending** → it's the **last permutation** → reverse to get **first**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Generate All Permutations

### Intuition  
Generate **all possible permutations**, sort them, find current → return next.

### Why This Approach?  
- Works logically  
- Easy to understand  
- Teaches `next_permutation` STL

### Why Move to Next?  
- **O(n! × n)** → explodes fast  
- **O(n!)** space → not feasible  
- **Never used in interviews**

---

### Algorithm  
1. Generate all permutations  
2. Sort them lexicographically  
3. Find current → return next  
4. If last → return first

---

### Pseudocode  
``` 
function brute(arr):  
    all_perms = []  
    sort arr  
    do:  
        all_perms.push(copy(arr))  
    while next_permutation(arr)  
    find index of original → return next (or first if last)
```

---

### Dry Run: [1,2,3]  
Perms: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]  
Current: [1,2,3] → index 0 → next is [1,3,2]

---

### Code

#### C++
```cpp
vector<int> brute(vector<int> arr) {
    vector<vector<int>> all;
    sort(arr.begin(), arr.end());
    do {
        all.push_back(arr);
    } while (next_permutation(arr.begin(), arr.end()));
    
    for (int i = 0; i < all.size(); i++) {
        if (all[i] == arr) {
            return (i == all.size() - 1) ? all[0] : all[i + 1];
        }
    }
    return arr;
}
```

#### JavaScript
```js
function brute(arr) {
    let all = [];
    arr = [...arr].sort((a,b) => a-b);
    do {
        all.push([...arr]);
    } while (nextPermutation(arr));
    
    for (let i = 0; i < all.length; i++) {
        if (arraysEqual(all[i], arr)) {
            return i === all.length - 1 ? all[0] : all[i + 1];
        }
    }
    return arr;
}
```

* Time: **O(n! × n)**  
* Space: **O(n!)** → **Disastrous**

---

## Approach 2: Optimal – 3-Step Algorithm (In-Place)

### Intuition  
> **"Increase from the right, minimize the change"**

**3 Steps**:
1. **Find the dip**: First `i` from right where `arr[i] < arr[i+1]`
2. **Find swap candidate**: From right, first `j > i` where `arr[j] > arr[i]`
3. **Swap + Reverse**: Swap `i` and `j`, then reverse `[i+1, end)`

If no dip → reverse entire array

---

### Why This Approach?  
- **O(n) time**  
- **O(1) space**  
- **In-place**  
- **Standard algorithm** — used in STL

### Why This is Final?  
- **Optimal** — no better way  
- **Minimal changes**  
- **Handles duplicates**

---

### Algorithm  
``` 
1. Find largest i where arr[i] < arr[i+1]  
   → If none → reverse entire array  
2. From end, find largest j where arr[j] > arr[i]  
3. Swap arr[i] and arr[j]  
4. Reverse subarray [i+1, n-1]
```

---

### Pseudocode  
``` 
function nextPermutation(arr):  
    n = arr.length  
    i = n-2  
    while i >= 0 and arr[i] >= arr[i+1]:  
        i--  
    if i == -1:  
        reverse(arr, 0, n-1)  
        return  
    j = n-1  
    while arr[j] <= arr[i]:  
        j--  
    swap(arr[i], arr[j])  
    reverse(arr, i+1, n-1)
```

---

### Dry Run: [1, 2, 3] → Want next

| Step | Array | Action |
|------|-------|--------|
| Start | [1,2,3] | |
| Find dip | i=1: 2 < 3 → **i=1** | |
| Find swap | j=2: 3 > 2 → **j=2** | |
| Swap | [1,**3**,**2**] | |
| Reverse after i+1 | [1,3,2] → already sorted | Done |

→ Answer: `[1,3,2]`

---

### Dry Run: [3,2,1] → Last permutation

| Step | Array | Action |
|------|-------|--------|
| Find dip | 3≥2, 2≥1 → **i=-1** | No dip |
| Reverse all | [1,2,3] | |

→ Answer: `[1,2,3]`

---

### Code

#### C++
```cpp
void nextPermutation(vector<int>& arr) {
    int n = arr.size();
    int i = n - 2;
    
    // Step 1: Find dip
    while (i >= 0 && arr[i] >= arr[i + 1]) {
        i--;
    }
    
    if (i == -1) {
        reverse(arr.begin(), arr.end());
        return;
    }
    
    // Step 2: Find swap candidate
    int j = n - 1;
    while (arr[j] <= arr[i]) {
        j--;
    }
    
    // Step 3: Swap and reverse
    swap(arr[i], arr[j]);
    reverse(arr.begin() + i + 1, arr.end());
}
```

#### JavaScript
```js
function nextPermutation(arr) {
    let n = arr.length;
    let i = n - 2;
    
    // Step 1: Find first dip from right
    while (i >= 0 && arr[i] >= arr[i + 1]) {
        i--;
    }
    
    if (i === -1) {
        arr.reverse();
        return;
    }
    
    // Step 2: Find number just larger than arr[i]
    let j = n - 1;
    while (arr[j] <= arr[i]) {
        j--;
    }
    
    // Step 3: Swap and reverse suffix
    [arr[i], arr[j]] = [arr[j], arr[i]];
    let left = i + 1, right = n - 1;
    while (left < right) {
        [arr[left++], arr[right--]] = [arr[right], arr[left]];
    }
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)**

---

## Approach 3: STL `next_permutation` (Production)

### Intuition  
C++ STL has **built-in** `next_permutation()` → highly optimized.

### Why This?  
- **One-liner**  
- **Production code**  
- **Handles duplicates**

### Why Not in Interview?  
- Interviewers want **logic**  
- May ask to **implement manually**

---

### Code

#### C++
```cpp
#include <algorithm>
bool nextPermutationSTL(vector<int>& arr) {
    return next_permutation(arr.begin(), arr.end());
    // Returns false if it was last → array becomes first
}
```

#### JavaScript → No built-in → implement manually

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|--------|-------|----------|---------|
| Already last | `[3,2,1]` | `[1,2,3]` | Yes |
| Single element | `[5]` | `[5]` | Yes |
| Duplicates | `[1,1,5]` | `[1,5,1]` | Yes |
| Already sorted | `[1,2,3]` | `[1,3,2]` | Yes |
| Two elements | `[1,2]` | `[2,1]` | Yes |
| All same | `[2,2,2]` | `[2,2,2]` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute (All Perms) | O(n! × n) | O(n!) | Never |
| **3-Step Algorithm** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| STL `next_permutation` | O(n) | O(1) | Production |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute: Generate all (NOT RECOMMENDED)
    vector<int> brute(vector<int> arr) {
        vector<vector<int>> all;
        sort(arr.begin(), arr.end());
        vector<int> orig = arr;
        do {
            all.push_back(arr);
        } while (next_permutation(arr.begin(), arr.end()));
        for (int i = 0; i < all.size(); i++) {
            if (all[i] == orig) {
                return i == all.size() - 1 ? all[0] : all[i + 1];
            }
        }
        return orig;
    }

    // Optimal: 3-Step In-Place
    void nextPermutation(vector<int>& arr) {
        int n = arr.size(), i = n - 2;
        while (i >= 0 && arr[i] >= arr[i + 1]) i--;
        if (i == -1) {
            reverse(arr.begin(), arr.end());
            return;
        }
        int j = n - 1;
        while (arr[j] <= arr[i]) j--;
        swap(arr[i], arr[j]);
        reverse(arr.begin() + i + 1, arr.end());
    }

    // STL (Production)
    void stl(vector<int>& arr) {
        next_permutation(arr.begin(), arr.end());
    }
};
```

### JavaScript
```javascript
class Solution {
    // Optimal: 3-Step
    nextPermutation(arr) {
        let n = arr.length;
        let i = n - 2;
        while (i >= 0 && arr[i] >= arr[i + 1]) i--;
        if (i === -1) {
            arr.reverse();
            return;
        }
        let j = n - 1;
        while (arr[j] <= arr[i]) j--;
        [arr[i], arr[j]] = [arr[j], arr[i]];
        let left = i + 1, right = n - 1;
        while (left < right) {
            [arr[left++], arr[right--]] = [arr[right], arr[left]];
        }
    }

    // Built-in style (simulate STL)
    builtin(arr) {
        this.nextPermutation(arr);
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I'll use the **3-step algorithm** in **O(n)** time."  
2. "Step 1: Find **first dip** from right → `arr[i] < arr[i+1]`"  
3. "Step 2: Find **smallest greater** than `arr[i]` from right"  
4. "Step 3: **Swap** and **reverse suffix**"  
5. "If no dip → reverse all"  
6. "Handles **duplicates**, **single element**, **last case**"  
7. **Bonus**: "This is exactly how C++ `next_permutation` works!"

---
