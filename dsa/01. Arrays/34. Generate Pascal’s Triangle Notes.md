# Problem: Generate Pascal’s Triangle (All Variations)

**GFG Link**: https://www.geeksforgeeks.org/problems/pascal-triangle0652/1  
**LeetCode**: https://leetcode.com/problems/pascals-triangle/ (and variants)

---

## 1. Problem Statement

**English**:  
Given an integer `N`, generate:
1. The **first N rows** of Pascal’s Triangle  
2. The **N-th row** (0-indexed or 1-indexed as specified)  
3. The **element at position (r, c)** (1-indexed)

**Hinglish**:  
Pascal ka triangle banao — teen cheezein chahiye:  
- Pehle N rows  
- Sirf N-th row  
- (r,c) wala single element

---

## 2. Input / Output / Constraints

**Input Example 1**: `N = 5`  
**Output**:  
```
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1
```

**Input Example 2**: `N = 5` → N-th row → `[1 4 6 4 1]`  
**Input Example 3**: `r = 5, c = 3` → `6`

**Constraints**:  
- `1 ≤ N ≤ 1000`  
- `1 ≤ r ≤ 1000`, `1 ≤ c ≤ r`  
- Values can go up to ~10¹⁸ → use `long long`

---

## 3. Examples (All Cases Covered)

| Case | Input | Output | Why |
|------|-------|--------|-----|
| 1 | N=1 | `[[1]]` | Base case |
| 2 | N=5 | 5 rows (as above) | Standard |
| 3 | N=6, get 6th row | `[1 5 10 10 5 1]` | Row only |
| 4 | r=5, c=3 | `6` | C(4,2) |
| 5 | r=30, c=15 | `155117520` | Large value test |

---

## 4. Intuition & Core Thinking

Pascal’s Triangle = **Binomial Coefficients**  
> `Row n (0-indexed)` → `C(n, 0), C(n, 1), ..., C(n, n)`

Every element:  
`triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]`

**Key Observations**:
- First & last element of every row → `1`
- Can generate **entire triangle** → O(N²)
- Can generate **only N-th row** → O(N)
- Can compute **single element** → O(min(c, r-c))

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Generate Entire Triangle (Standard)

### Intuition  
Build row by row using previous row.

### Why This Approach?  
- Clear, visual  
- Easy to debug  
- Directly matches definition

### When to Use?  
- When you need **all rows**  
- LeetCode 118

---

### Algorithm  
1. Start with row 0: `[1]`  
2. For each new row `i`:  
  - Size = `i+1`  
  - First & last = `1`  
  - Middle: `prev[j-1] + prev[j]`

---

### Dry Run: N=4 (0-indexed)
```
Row 0: [1]
Row 1: [1, 1] 
Row 2: [1, 2, 1] 
Row 3: [1, 3, 3, 1]
```

---

### Code

#### C++
```cpp
vector<vector<long long>> generateTriangle(int n) {
    vector<vector<long long>> tri(n);
    for (int i = 0; i < n; i++) {
        tri[i].resize(i + 1);
        tri[i][0] = tri[i][i] = 1;
        for (int j = 1; j < i; j++) {
            tri[i][j] = tri[i-1][j-1] + tri[i-1][j];
        }
    }
    return tri;
}
```

#### JavaScript
```js
function generateTriangle(n) {
    let tri = [];
    for (let i = 0; i < n; i++) {
        let row = new Array(i + 1).fill(1);
        for (let j = 1; j < i; j++) {
            row[j] = tri[i-1][j-1] + tri[i-1][j];
        }
        tri.push(row);
    }
    return tri;
}
```

* Time: **O(N²)**, Space: **O(N²)**

---

## Approach 2: Generate Only N-th Row (Optimal for Row)

### Intuition  
Use formula:  
**C(n,k) = C(n,k-1) × (n-k+1) / k**

Start with `1`, multiply and divide iteratively → **no overflow** if done carefully.

### Why This is Better?  
- **O(N) time**  
- **O(N) space** (only one row)  
- **No need to store previous rows**

---

### Dry Run: N=5 (1-indexed → row 5)
```
val = 1                         → push 1
k=1: 1 * (5-1)/1 = 4             → [1 4]
k=2: 4 * (5-2)/2 = 4*3/2 = 6     → [1 4 6]
k=3: 6 * (5-3)/3 = 6*2/3 = 4     → [1 4 6 4]
k=4: 4 * (5-4)/4 = 4*1/4 = 1     → [1 4 6 4 1]
```

---

### Code

#### C++
```cpp
vector<long long> getRow(int n) {  // n is 1-indexed
    vector<long long> row;
    long long val = 1;
    row.push_back(1);
    for (int k = 1; k < n; k++) {
        val = val * (n - k) / k;
        row.push_back(val);
    }
    return row;
}
```

#### JavaScript
```js
function getRow(n) {  // n = row number (1-indexed)
    let row = [1];
    let val = 1;
    for (let k = 1; k < n; k++) {
        val = val * (n - k) / k;
        row.push(val);
    }
    return row;
}
```

* Time: **O(N)**, Space: **O(N)** → **Best for single row**

---

## Approach 3: Single Element using Binomial Coefficient (Fastest for One Value)

### Intuition  
Element at `(r,c)` (1-indexed) = **C(r-1, c-1)**

Compute using loop:  
`res *= (n-i) / (i+1)`

Take min(c-1, r-c) to reduce loop → symmetry!

---

### Code

#### C++
```cpp
long long getElement(int r, int c) {
    r--; c--;  // convert to 0-indexed
    if (c > r - c) c = r - c;  // symmetry
    long long res = 1;
    for (int i = 0; i < c; i++) {
        res *= (r - i);
        res /= (i + 1);
    }
    return res;
}
```

#### JavaScript
```js
function getElement(r, c) {
    r--; c--;
    if (c > r - c) c = r - c;
    let res = 1;
    for (let i = 0; i < c; i++) {
        res = res * (r - i) / (i + 1);
    }
    return res;
}
```

* Time: **O(min(c, r-c))**, Space: **O(1)** → **Fastest for single query**

---

## 5. Edge Case List

| Edge Case | Input | Handled? |
|---------|-------|---------|
| N=1 | → `[[1]]` | Yes |
| r=1, c=1 | → `1` | Yes |
| c=1 or c=r | → `1` | Yes |
| Large N (r=30) | → big numbers | Use `long long` |
| r=1000, c=500 | → may overflow int | Use `long long` |

---

## 6. Complexity Summary

| Task                    | Approach          | Time        | Space     | Best For |
|-------------------------|-------------------|-------------|-----------|----------|
| Full Triangle           | Row-by-row        | O(N²)       | O(N²)     | LeetCode 118 |
| Only N-th Row           | Multiplicative    | **O(N)**    | O(N)      | GFG N-th row |
| Single Element (r,c)    | Binomial formula  | **O(k)**    | **O(1)**  | Fast query |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Pascal {
public:
    // 1. Full Triangle
    vector<vector<long long>> generate(int n) {
        vector<vector<long long>> tri(n);
        for (int i = 0; i < n; i++) {
            tri[i].resize(i + 1, 1);
            for (int j = 1; j < i; j++) {
                tri[i][j] = tri[i-1][j-1] + tri[i-1][j];
            }
        }
        return tri;
    }

    // 2. Only N-th row (1-indexed)
    vector<long long> getNthRow(int n) {
        vector<long long> row;
        long long val = 1;
        row.push_back(1);
        for (int k = 1; k < n; k++) {
            val = val * (n - k) / k;
            row.push_back(val);
        }
        return row;
    }

    // 3. Single element (r,c) 1-indexed
    long long getElement(int r, int c) {
        r--; c--;
        if (c > r - c) c = r - c;
        long long res = 1;
        for (int i = 0; i < c; i++) {
            res = res * (r - i) / (i + 1);
        }
        return res;
    }
};
```

### JavaScript
```javascript
class Pascal {
    // Full triangle
    generate(n) {
        let tri = [];
        for (let i = 0; i < n; i++) {
            let row = new Array(i + 1).fill(1);
            for (let j = 1; j < i; j++) {
                row[j] = tri[i-1][j-1] + tri[i-1][j];
            }
            tri.push(row);
        }
        return tri;
    }

    // N-th row (1-indexed)
    getNthRow(n) {
        let row = [1];
        let val = 1;
        for (let k = 1; k < n; k++) {
            val = val * (n - k) / k;
            row.push(val);
        }
        return row;
    }

    // Single element (r,c) 1-indexed
    getElement(r, c) {
        r--; c--;
        if (c > r - c) c = r - c;
        let res = 1;
        for (let i = 0; i < c; i++) {
            res = res * (r - i) / (i + 1);
        }
        return res;
    }
}
```

---

## 8. Interview Strategy

1. **Clarify**: "Do you want full triangle, N-th row, or single element?"
2. **Start simple**: Show full triangle → O(N²)
3. **Optimize**:
   - "If only N-th row → use multiplicative formula → O(N)"
   - "If single element → direct binomial → O(min(c,r-c))"
4. **Edge cases**: N=1, large values → use `long long`
5. **Bonus**: "This is how C(n,k) is computed in combinatorics!"

---