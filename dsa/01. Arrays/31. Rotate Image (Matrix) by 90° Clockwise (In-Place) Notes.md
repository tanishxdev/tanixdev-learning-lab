# Problem: Rotate Image (Matrix) by 90° Clockwise (In-Place)

**LeetCode**: https://leetcode.com/problems/rotate-image/  
**GFG**: https://www.geeksforgeeks.org/problems/rotate-a-matrix-by-90-degrees/1

---

## 1. Problem Statement

**English**:  
Given an `n × n` 2D matrix, rotate it **90 degrees clockwise** **in-place** (without using extra space proportional to input size).

**Hinglish**:  
Square matrix ko 90° clockwise ghumao — **bina extra matrix banaye**, same matrix mein modify karo.

---

## 2. Input / Output / Constraints

**Input Example 1**:  
```
[[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9]]
```
**Output Expected**:
```
[[7, 4, 1],
 [8, 5, 2],
 [9, 6, 3]]
```

**Input Example 2**:
```
[[5,  1,  9, 11],
 [2,  4,  8, 10],
 [13, 3,  6,  7],
 [15,14, 12, 16]]
```
**Output**:
```
[[15,13, 2, 5],
 [14, 3, 4, 1],
 [12, 6, 8, 9],
 [16, 7,10,11]]
```

**Constraints**:  
- `n == matrix.length == matrix[i].length`  
- `1 ≤ n ≤ 20`  
- `-1000 ≤ matrix[i][j] ≤ 1000`

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | 3×3 standard | As above | Classic |
| 2 | 4×4 complex | As above | Real test |
| 3 | 1×1 → `[[5]]` | `[[5]]` | No change |
| 4 | 2×2 → `[[1,2],[3,4]]` | `[[3,1],[4,2]]` | Small case |

---

## 4. Intuition & Core Thinking

**Observation**:
> To rotate 90° clockwise:
> 1. **Transpose** the matrix (swap `matrix[i][j]` ↔ `matrix[j][i]`)
> 2. **Reverse each row**

That’s it! This is the **most elegant** and **interview-favorite** trick.

**Why it works?**  
After transpose:
```
1 4 7
2 5 8
3 6 9
```
After reversing each row → perfect 90° rotation!

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Using Extra Matrix

### Intuition  
Create a new `n×n` matrix → fill it by mapping:
> `new[j][n-1-i] = old[i][j]`

### Why Move to Next?  
- Uses **O(n²)** extra space → not allowed in interviews  
- LeetCode asks **in-place**

---

### Code (C++)
```cpp
vector<vector<int>> rotateBrute(vector<vector<int>>& mat) {
    int n = mat.size();
    vector<vector<int>> rotated(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            rotated[j][n - 1 - i] = mat[i][j];
        }
    }
    return rotated;  // Note: returns new matrix
}
```

* Time: **O(n²)**  
* Space: **O(n²)** → Not optimal

---

## Approach 2: Optimal – Transpose + Reverse (In-Place)

### Intuition  
**Two-step magic**:
1. Transpose (swap above diagonal)
2. Reverse every row

### Why This is Final?  
- **O(1) space**  
- **Clean, short, fast**  
- **Standard interview answer**  
- Works for any n×n

---

### Algorithm  
1. **Transpose**: For `i < j`, swap `mat[i][j]` ↔ `mat[j][i]`  
2. **Reverse rows**: For each row, reverse the elements

---

### Dry Run: `[[1,2,3],[4,5,6],[7,8,9]]`

**Step 1: Transpose**
```
1 4 7
2 5 8
3 6 9
```

**Step 2: Reverse each row**
```
7 4 1
8 5 2
9 6 3
```
Done!

---

### Code (Optimal)

#### C++
```cpp
void rotate(vector<vector<int>>& mat) {
    int n = mat.size();

    // Step 1: Transpose
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {  // j starts from i+1 → only upper triangle
            swap(mat[i][j], mat[j][i]);
        }
    }

    // Step 2: Reverse each row
    for (int i = 0; i < n; i++) {
        reverse(mat[i].begin(), mat[i].end());
    }
}
```

#### JavaScript
```js
function rotate(mat) {
    let n = mat.length;

    // Transpose
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [mat[i][j], mat[j][i]] = [mat[j][i], mat[i][j]];
        }
    }

    // Reverse each row
    for (let i = 0; i < n; i++) {
        mat[i].reverse();
    }
}
```

* Time Complexity: **O(n²)**  
* Space Complexity: **O(1)** → Truly in-place!

---

## Bonus: Rotate 90° Anti-Clockwise?

Just reverse the steps:
1. Reverse each row first
2. Then transpose

```cpp
// Anti-clockwise 90°
for (int i = 0; i < n; i++) reverse(mat[i].begin(), mat[i].end());
for (int i = 0; i < n; i++)
    for (int j = i + 1; j < n; j++)
        swap(mat[i][j], mat[j][i]);
```

---

## 5. Edge Case List

| Edge Case       | Handled? |
|----------------|--------|
| n = 1 (1×1)     | Yes (no change) |
| n = 2           | Yes |
| n = 0 (empty)   | Not in constraints |
| Odd & Even size | Yes |

---

## 6. Complexity Summary

| Approach           | Time   | Space  | Best For           |
|-------------------|--------|--------|--------------------|
| Extra Matrix      | O(n²)  | O(n²)  | Learning only      |
| **Transpose + Reverse** | **O(n²)** | **O(1)** | **Interviews & LeetCode** |

**This is the gold standard**

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute Force (Extra Space)
    vector<vector<int>> brute(vector<vector<int>> mat) {
        int n = mat.size();
        vector<vector<int>> res(n, vector<int>(n));
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                res[j][n - 1 - i] = mat[i][j];
        return res;
    }

    // Optimal: In-place
    void rotate(vector<vector<int>>& mat) {
        int n = mat.size();

        // Transpose
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                swap(mat[i][j], mat[j][i]);

        // Reverse each row
        for (int i = 0; i < n; i++)
            reverse(mat[i].begin(), mat[i].end());
    }

    // Anti-clockwise version
    void rotateAntiClockwise(vector<vector<int>>& mat) {
        int n = mat.size();
        for (int i = 0; i < n; i++) reverse(mat[i].begin(), mat[i].end());
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                swap(mat[i][j], mat[j][i]);
    }
};
```

### JavaScript
```javascript
class Solution {
    // Optimal Clockwise
    rotate(mat) {
        let n = mat.length;

        // Transpose
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                [mat[i][j], mat[j][i]] = [mat[j][i], mat[i][j]];
            }
        }

        // Reverse rows
        for (let i = 0; i < n; i++) {
            mat[i].reverse();
        }
    }

    // Anti-clockwise
    rotateLeft(mat) {
        let n = mat.length;
        for (let row of mat) row.reverse();
        for (let i = 0; i < n; i++)
            for (let j = i + 1; j < n; j++)
                [mat[i][j], mat[j][i]] = [mat[j][i], mat[i][j]];
    }
}
```

---

## 8. Interview Strategy

1. **Say confidently**:  
   → "Sir, the optimal way is **Transpose + Reverse each row** — O(1) space."

2. **Explain**:
   - "First, we transpose the matrix → converts columns to rows"
   - "Then reverse each row → gives 90° clockwise rotation"

3. **Write code** → clean, with comments

4. **Bonus**:
   - "For anti-clockwise: reverse rows first, then transpose"
   - "Time: O(n²), Space: O(1) — can't do better"

5. **Dry run** on 3×3 → seal the deal

---
