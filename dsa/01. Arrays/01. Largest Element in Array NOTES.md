# Problem: Find the Largest Element in an Array

**GFG Link**: https://www.geeksforgeeks.org/problems/largest-element-in-array4009/1


---

## 1. Problem Statement

**English**:  
Given an array of integers, return the **largest element**. If the array is empty, return `-1` (or handle as per requirement).

**Hinglish**:  
Array mein sabse bada number dhundho. Agar array khali hai to `-1` return karo.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [2, 5, 1, 3, 0]`  
**Output Expected**: `5`

**Constraints**:  
- `0 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- Array may contain **negative**, **zero**, or **positive** numbers

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[2,5,1,3,0]` | `5` | Normal case |
| 2 | `[8,10,5,7,9]` | `10` | Multiple large values |
| 3 | `[7]` | `7` | Single element |
| 4 | `[]` | `-1` | Empty array |
| 5 | `[-3, -1, -5]` | `-1` | All negative |
| 6 | `[0, 0, 0]` | `0` | All zeros |

---

## 4. Intuition & Core Thinking

> **"Largest" = keep track of the maximum seen so far.**

Like walking through a row of people and remembering the **tallest** one.

Key Questions:  
- What if array is empty? → Handle explicitly  
- What if all negative? → Max is least negative  
- Can I do better than sorting? → **Yes! O(n) is optimal**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Sorting

### Intuition  
Sort the array → largest is at the end.

### Why This Approach?  
- Easy to think  
- Works for any data  
- Teaches sorting basics

### Why Move to Next?  
- **O(n log n)** → unnecessary  
- Modifies original array (unless copied)  
- **Not optimal**

---

### Algorithm  
1. If array empty → return `-1`  
2. Sort array in ascending order  
3. Return `arr[n-1]`

---

### Pseudocode  
``` 
function sortApproach(arr):  
    if arr is empty: return -1  
    sort(arr)  
    return arr[arr.length - 1]
```

---

### Dry Run: [2, 5, 1, 3, 0]  
→ Sort: [0, 1, 2, 3, 5]  
→ Answer: `5`

---

### Code

#### C++
```cpp
int sortApproach(vector<int>& arr) {
    if (arr.empty()) return -1;
    sort(arr.begin(), arr.end());
    return arr.back();
}
```

#### JavaScript
```js
function sortApproach(arr) {
    if (arr.length === 0) return -1;
    arr.sort((a, b) => a - b);
    return arr[arr.length - 1];
}
```

* Time Complexity: **O(n log n)**  
* Space Complexity: **O(1)** (in-place) or **O(n)** (if copying)

---

## Approach 2: Linear Scan with Max Variable (Optimal)

### Intuition  
> **One pass**: Start with first element as max → update if you find bigger.

Like scanning a leaderboard and updating the **highest score**.

### Why This Approach?  
- **O(n) time** → optimal  
- **O(1) space**  
- **Simple & clean**  
- **Interview favorite**

### Why This is Final?  
- **Cannot do better than O(n)** — must look at every element in worst case  
- Handles **all edge cases**  
- Production-ready

---

### Algorithm  
1. If `arr.empty()` → return `-1`  
2. `maxVal = arr[0]`  
3. For `i = 1` to `n-1`:  
  if `arr[i] > maxVal` → `maxVal = arr[i]`  
4. Return `maxVal`

---

### Pseudocode  
``` 
function linearScan(arr):  
    if arr is empty: return -1  
    maxVal = arr[0]  
    for i from 1 to n-1:  
        if arr[i] > maxVal:  
            maxVal = arr[i]  
    return maxVal
```

---

### Dry Run: [2, 5, 1, 3, 0]  
| i | arr[i] | maxVal |
|---|--------|--------|
| 0 | 2      | 2      |
| 1 | 5      | **5**  |
| 2 | 1      | 5      |
| 3 | 3      | 5      |
| 4 | 0      | 5      |

→ Answer: `5`

---

### Code

#### C++
```cpp
int linearScan(vector<int>& arr) {
    if (arr.empty()) return -1;
    int maxVal = arr[0];
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }
    return maxVal;
}
```

#### JavaScript
```js
function linearScan(arr) {
    if (arr.length === 0) return -1;
    let maxVal = arr[0];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }
    return maxVal;
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)**

---

## Approach 3: Using STL `max_element` (Production)

### Intuition  
Use language’s built-in **optimized** function.

### Why This?  
- **One-liner**  
- **Highly optimized**  
- **Real-world code**

### Why Not Always?  
- Interviewers want **logic**  
- May ask to implement manually

---

### Code

#### C++
```cpp
#include <algorithm>
int stlApproach(vector<int>& arr) {
    if (arr.empty()) return -1;
    return *max_element(arr.begin(), arr.end());
}
```

#### JavaScript (No built-in max_element → use Math.max)
```js
function stlApproach(arr) {
    if (arr.length === 0) return -1;
    return Math.max(...arr);
}
```

* Time: **O(n)**, Space: **O(1)**

---

## Approach 4: Using Reduce (Functional Style - JS)

```js
function reduceApproach(arr) {
    if (arr.length === 0) return -1;
    return arr.reduce((max, curr) => curr > max ? curr : max, arr[0]);
}
```

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|--------|-------|----------|---------|
| Empty array | `[]` | `-1` | Yes |
| Single element | `[7]` | `7` | Yes |
| All negative | `[-5, -1, -3]` | `-1` | Yes |
| All same | `[2, 2, 2]` | `2` | Yes |
| Max at start | `[10, 1, 2]` | `10` | Yes |
| Max at end | `[1, 2, 10]` | `10` | Yes |
| Includes zero | `[0, -1, 5]` | `5` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Sorting | O(n log n) | O(1) | Learning |
| **Linear Scan** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| STL / Built-in | O(n) | O(1) | Production |

> **Use Linear Scan in interviews**  
> **Use STL in production**

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Sorting (Brute)
    int sortApproach(vector<int>& arr) {
        if (arr.empty()) return -1;
        sort(arr.begin(), arr.end());
        return arr.back();
    }

    // 2. Linear Scan (Optimal)
    int linearScan(vector<int>& arr) {
        if (arr.empty()) return -1;
        int maxVal = arr[0];
        for (int i = 1; i < arr.size(); i++) {
            if (arr[i] > maxVal) maxVal = arr[i];
        }
        return maxVal;
    }

    // 3. STL (Production)
    int stlApproach(vector<int>& arr) {
        if (arr.empty()) return -1;
        return *max_element(arr.begin(), arr.end());
    }
};
```

### JavaScript
```javascript
class Solution {
    // 1. Sorting
    sortApproach(arr) {
        if (arr.length === 0) return -1;
        arr.sort((a, b) => a - b);
        return arr[arr.length - 1];
    }

    // 2. Linear Scan (Optimal)
    linearScan(arr) {
        if (arr.length === 0) return -1;
        let maxVal = arr[0];
        for (let i = 1; i < arr.length; i++) {
            if (arr[i] > maxVal) maxVal = arr[i];
        }
        return maxVal;
    }

    // 3. Built-in
    builtin(arr) {
        if (arr.length === 0) return -1;
        return Math.max(...arr);
    }

    // 4. Reduce
    reduceApproach(arr) {
        if (arr.length === 0) return -1;
        return arr.reduce((max, curr) => curr > max ? curr : max, arr[0]);
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I’ll scan the array in **O(n)** time using a `max` variable."  
2. "Initialize `max = arr[0]`, then loop from index 1, update if larger."  
3. "Edge case: if array empty → return `-1`."  
4. "Time: **O(n)**, Space: **O(1)** — optimal."  
5. **Bonus**: "Sorting would be O(n log n) — overkill. In production, I’d use `max_element` (C++) or `Math.max` (JS)."

---