# Merge Overlapping Intervals  
**LeetCode 56** – One of the **most important** interview problems!

**Link**: https://leetcode.com/problems/merge-intervals/

---

### Problem Statement
Given an array of intervals `intervals[i] = [start_i, end_i]`,  
**Merge all overlapping intervals** and return the list of **non-overlapping** intervals that cover all input intervals.

**Examples**
```
Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]

Input: [[1,4],[4,5]]
Output: [[1,5]]   (touching intervals → merge)
```

---

### Core Intuition (Must Know)

> **If two intervals overlap or touch → they can be merged!**  
> Two intervals `[a,b]` and `[c,d]` overlap if:  
> `a ≤ c ≤ b`  or  `c ≤ a ≤ d`  
> After sorting by start time → just check:  
> **Current interval’s start ≤ last merged interval’s end**

---

### All Approaches – Full Code + Dry Run + Pseudocode

---

#### Approach 1: Brute Force (Not truly brute – still O(N²))

```cpp
vector<vector<int>> mergeBrute(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> ans;
    
    int n = intervals.size();
    for (int i = 0; i < n; ) {
        int start = intervals[i][0];
        int end = intervals[i][1];
        
        int j = i + 1;
        while (j < n && intervals[j][0] <= end) {
            end = max(end, intervals[j][1]);
            j++;
        }
        
        ans.push_back({start, end});
        i = j;  // skip all merged intervals
    }
    return ans;
}
```

Works, but **O(N²)** in worst case → not optimal.

---

#### Approach 2: Optimal – Sort + One Pass (BEST)

```cpp
// Optimal - O(N log N) Time, O(1) Extra Space (excluding output)
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};
    
    sort(intervals.begin(), intervals.end());  // Sort by start time
    
    vector<vector<int>> merged;
    merged.push_back(intervals[0]);  // Add first interval
    
    for (int i = 1; i < intervals.size(); i++) {
        auto& last = merged.back();  // last merged interval
        auto& curr = intervals[i];   // current interval
        
        if (curr[0] <= last[1]) {
            // Overlap → merge
            last[1] = max(last[1], curr[1]);
        } else {
            // No overlap → add new
            merged.push_back(curr);
        }
    }
    return merged;
}
```

**This is the standard interview solution!**

---

### Dry Run – [[1,3],[2,6],[8,10],[15,18]]

After sorting: same  
Step-by-step:

| Current Interval | Last Merged | Action                     | Merged List       |
|------------------|-------------|----------------------------|-------------------|
| [1,3]            | -           | Add first                  | [[1,3]]           |
| [2,6]            | [1,3]       | 2 ≤ 3 → merge → [1,6]      | [[1,6]]           |
| [8,10]           | [1,6]       | 8 > 6 → no overlap → add   | [[1,6],[8,10]]    |
| [15,18]          | [8,10]      | 15 > 10 → add              | [[1,6],[8,10],[15,18]] |

**Output**: `[[1,6],[8,10],[15,18]]`

---

### Edge Cases Handled

| Case                        | Handled? | How? |
|-----------------------------|--------|------|
| Empty input                 | Yes    | Return {} |
| Single interval             | Yes    | Directly added |
| All overlapping             | Yes    | Becomes one interval |
| Touching intervals [1,4],[4,5] | Yes | `curr[0] <= last[1]` → merges |
| Already sorted              | Yes    | Still works |
| Unsorted input              | Yes    | We sort first |

---

### Pseudocode (Optimal)

```
function mergeIntervals(intervals):
    if intervals is empty:
        return []
    
    sort intervals by start time
    
    merged = [intervals[0]]
    
    for each interval in intervals[1..end]:
        last = merged.last()
        if interval.start <= last.end:
            last.end = max(last.end, interval.end)
        else:
            add interval to merged
    
    return merged
```

---

### Final Consolidated Code (C++ & JavaScript)

#### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute Force Style (O(N²) worst case)
    vector<vector<int>> mergeBrute(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> ans;
        int n = intervals.size();
        
        for (int i = 0; i < n; ) {
            int start = intervals[i][0];
            int end = intervals[i][1];
            int j = i + 1;
            while (j < n && intervals[j][0] <= end) {
                end = max(end, intervals[j][1]);
                j++;
            }
            ans.push_back({start, end});
            i = j;
        }
        return ans;
    }

    // Optimal - O(N log N)
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};
        
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> merged = {intervals[0]};
        
        for (int i = 1; i < intervals.size(); i++) {
            auto& last = merged.back();
            auto& curr = intervals[i];
            
            if (curr[0] <= last[1]) {
                last[1] = max(last[1], curr[1]);
            } else {
                merged.push_back(curr);
            }
        }
        return merged;
    }
};
```

#### JavaScript
```javascript
function merge(intervals) {
    if (intervals.length === 0) return [];
    
    intervals.sort((a, b) => a[0] - b[0]);
    let merged = [intervals[0]];
    
    for (let i = 1; i < intervals.length; i++) {
        let last = merged[merged.length - 1];
        let curr = intervals[i];
        
        if (curr[0] <= last[1]) {
            last[1] = Math.max(last[1], curr[1]);
        } else {
            merged.push(curr);
        }
    }
    return merged;
}

// Test
console.log(merge([[1,3],[2,6],[8,10],[15,18]])); 
// → [[1,6],[8,10],[15,18]]
```

---

### Complexity Summary

| Approach     | Time           | Space       | Best For         |
|--------------|----------------|-------------|------------------|
| Brute Style  | O(N²) worst    | O(1) extra  | Learning         |
| **Optimal**  | **O(N log N)** | **O(1)**    | **Interviews**   |

**Always use Optimal in interviews!**

---
