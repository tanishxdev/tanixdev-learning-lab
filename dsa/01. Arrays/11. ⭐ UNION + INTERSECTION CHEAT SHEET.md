# **UNION + INTERSECTION CHEAT SHEET**

(DSA – Arrays – Sorted & Unsorted)

---

## 1. **Union vs Intersection – Core Difference**

| Operation        | Meaning                                | Example (A={1,2,2,3}, B={2,3,4}) |
| ---------------- | -------------------------------------- | -------------------------------- |
| **Union**        | All unique elements from both arrays   | {1,2,3,4}                        |
| **Intersection** | Only elements present in *both* arrays | {2,3}                            |

---

# **UNION**

## A) **Approach 1 – Using Set** (Works for Unsorted)

* Insert all elements of A into set
* Insert all elements of B into set
* Convert set → vector
* Set automatically removes duplicates + sorts

**Time:** O((n+m) log(n+m))
**Space:** O(n+m)
**Use When:** Arrays not sorted

---

## B) **Approach 2 – Two Pointer Merge** (Better, Sorted)

* Both arrays must be sorted
* Use two pointers to merge like merge-sort
* If both equal → add once
* Skip duplicates using `res.back()`

**Time:** O(n+m)
**Space:** O(n+m)
**Use When:** Arrays sorted and you want efficient solution

---

# **INTERSECTION**

## A) **Approach 1 – Hash Set** (Unsorted)

* Insert elements of A in set
* Traverse B
* If element in set → add to result and erase
* Avoids duplicates automatically

**Time:** O(n+m)
**Space:** O(n)
**Use When:** Arrays unsorted

---

## B) **Approach 2 – Two Pointer** (Sorted)

* Traverse both using i, j
* If equal → add to result
* Move both pointers
* Skip duplicates by checking last element in result

**Time:** O(n+m)
**Space:** O(1) extra
**Use When:** Arrays sorted

---

# **CLEAR PICTURE: UNION VS INTERSECTION USING POINTERS**

Suppose:

```
A = [1,2,2,3,4]
B = [2,2,3,5]
```

### **Union Pointer Flow**

```
i=0 j=0 => 1 added
i=1 j=0 => 2 added
i=2 j=1 => skip duplicates
i=3 j=2 => 3 added
i=4 j=3 => 4 added
A ends -> add leftover of B => 5
Final: [1,2,3,4,5]
```

### **Intersection Pointer Flow**

```
i=1 j=0 => 2 equal -> add
i=2 j=1 => skip duplicate
i=3 j=2 => 3 equal -> add
Final: [2,3]
```

---

# **COMMON MISTAKES & EDGE CASES**

### 1. Not checking duplicates

Use:

```
if(res.empty() || res.back() != x)
```

### 2. Forgetting sorted requirement in two-pointer approach

If arrays unsorted → sort first.

### 3. Forgetting to erase element in hash-set intersection

Otherwise duplicates appear.

### 4. Using unordered_map instead of unordered_set

Intersection requires membership, not counting.

---

# **REAL INTERVIEW QUESTIONS BASED ON THIS**

### Q1. Union of two sorted arrays

Use two-pointer method.

### Q2. Intersection of sorted arrays

Use two-pointer method.

### Q3. Intersection of unsorted arrays

Use hash-set.

### Q4. Find common elements in 3 sorted arrays

Extend two-pointer → 3 pointers.

### Q5. Check if two arrays are disjoint

If intersection is empty → disjoint.

### Q6. Count elements in intersection (with duplicates allowed)

Use frequency maps.

### Q7. Find missing elements between two arrays

Use sets / maps.

### Q8. Merge two sorted arrays without duplicates

Same as union pointer approach.

### Q9. Check if array A is subset of B

Use set or hash map.

### Q10. Number of unique elements in two arrays

Union size.

---

# **SHORT REVISION SUMMARY (SUPER QUICK)**

* **Union Set:** Works everywhere, slower
* **Union Two-Pointer:** Best, but needs sorted
* **Intersection Set:** Unsorted, uses hashing
* **Intersection Two-Pointer:** Best + sorted
* Check duplicates using `res.back()`
* If arrays not sorted, sort first before pointer method

---

