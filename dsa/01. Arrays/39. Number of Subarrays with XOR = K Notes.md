# Count Number of Subarrays with XOR = K  
**"The XOR version of Subarray Sum Equals K"**

**LeetCode**: https://leetcode.com/problems/subarray-xor-equals-k/ (Premium)  
**GFG**: https://practice.geeksforgeeks.org/problems/subarrays-with-xor-k

---

### Problem Statement
Given an array `A[]` and integer `K`,  
Find **total number of subarrays** whose **bitwise XOR** is exactly `K`.

**Examples**  
```
Input: [4,2,2,6,4], K=6  
Output: 4  
Subarrays: [4,2], [2,2,6], [6], [4,2,2,6,4]

Input: [5,6,7,8,9], K=5  
Output: 2  
Subarrays: [5], [5,6,7,8,9]
```

---

### Core Intuition (MOST IMPORTANT)

> **XOR is invertible**:  
> `prefixXOR[i] ^ prefixXOR[j] = XOR of subarray (j+1 to i)`  
> So,  
> `subarray(j+1 → i) XOR = K`  
> → `prefixXOR[i] ^ prefixXOR[j] = K`  
> → `prefixXOR[j] = prefixXOR[i] ^ K`

**So, for every prefix XOR at index i, we just need to count how many times `(prefixXOR[i] ^ K)` has appeared before!**

---

### All 3 Approaches – Full Code + Dry Run + Pseudocode

---

#### Approach 1: Brute Force – 3 Nested Loops  
**Time**: O(N³)

```cpp
int brute(vector<int>& a, int k) {
    int n = a.size();
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int xor_val = 0;
            for (int l = i; l <= j; l++) {
                xor_val ^= a[l];
            }
            if (xor_val == k) cnt++;
        }
    }
    return cnt;
}
```

---

#### Approach 2: Better – 2 Loops (Smart XOR Update)  
**Time**: O(N²)

```cpp
int better(vector<int>& a, int k) {
    int n = a.size();
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        int xor_val = 0;
        for (int j = i; j < n; j++) {
            xor_val ^= a[j];           // O(1) update
            if (xor_val == k) cnt++;
        }
    }
    return cnt;
}
```

Still too slow for large N (N ≤ 10⁵)

---

#### Approach 3: Optimal – Prefix XOR + HashMap (BEST)

```cpp
// Optimal - O(N) Time, O(N) Space
int subarraysWithXorK(vector<int>& a, int k) {
    int n = a.size();
    unordered_map<int, int> freq;  // prefixXOR → count
    int prefix_xor = 0;
    int count = 0;

    freq[0] = 1;  // Important: handles subarray from index 0

    for (int i = 0; i < n; i++) {
        prefix_xor ^= a[i];

        // We need subarray ending at i with XOR = k
        // So we search for: prefix_xor ^ k
        int need = prefix_xor ^ k;

        if (freq.count(need)) {
            count += freq[need];
        }

        // Store current prefix XOR
        freq[prefix_xor]++;
    }
    return count;
}
```

**Why `freq[0] = 1`?**  
Because if at any point `prefix_xor == k`, then subarray from **index 0 to current** has XOR = k.  
We need to count it → so we pre-insert `0` with frequency 1.

---

### Dry Run – [4,2,2,6,4], K=6

| i | a[i] | prefix_xor | need = prefix_xor ^ 6 | freq[need] | count | freq map |
|---|------|------------|-------------------------|------------|-------|----------|
|   |      |            |                         |            |     0 | {0:1}    |
| 0 | 4    | 4          | 4^6=2                   | 0          | 0   | {0:1,4:1} |
| 1 | 2    | 6          | 6^6=0                   | 1          | 1   | {0:1,4:1,6:1} → [4,2] |
| 2 | 2    | 4          | 4^6=2                   | 0          | 1   | {0:1,4:2,6:1} |
| 3 | 6    | 2          | 2^6=4                   | 2          | 3   | {0:1,4:2,6:1,2:1} → [2,2,6], [6] |
| 4 | 4    | 6          | 6^6=0                   | 1          | 4   | {0:1,4:2,6:2,2:1} → [4,2,2,6,4] |

**Answer = 4**

---

### Pseudocode (Optimal)

```
function countSubarraysWithXorK(arr, k):
    map = {0: 1}
    xor = 0
    count = 0
    
    for each num in arr:
        xor = xor ^ num
        
        need = xor ^ k
        
        if need in map:
            count += map[need]
            
        map[xor] += 1
        
    return count
```

---

### Edge Cases Handled

| Case                      | Handled? | How? |
|---------------------------|--------|------|
| K = 0                     | Yes    | Works (need = xor ^ 0 = xor) |
| Single element = K        | Yes    | Due to freq[0] = 1 |
| All elements same         | Yes    | Map handles correctly |
| Negative numbers          | Yes    | XOR works with negatives |
| Large array (10⁵)         | Yes    | O(N) passes |

---

### Final Consolidated Code (All 3 Approaches)

#### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute - O(N³)
    int brute(vector<int>& a, int k) {
        int n = a.size(), cnt = 0;
        for (int i = 0; i < n; i++)
            for (int j = i; j < n; j++) {
                int xr = 0;
                for (int l = i; l <= j; l++) xr ^= a[l];
                if (xr == k) cnt++;
            }
        return cnt;
    }

    // Better - O(N²)
    int better(vector<int>& a, int k) {
        int n = a.size(), cnt = 0;
        for (int i = 0; i < n; i++) {
            int xr = 0;
            for (int j = i; j < n; j++) {
                xr ^= a[j];
                if (xr == k) cnt++;
            }
        }
        return cnt;
    }

    // Optimal - Prefix XOR + Map
    int optimal(vector<int>& a, int k) {
        unordered_map<int, int> freq;
        freq[0] = 1;
        int xr = 0, cnt = 0;

        for (int num : a) {
            xr ^= num;
            int need = xr ^ k;
            if (freq.count(need)) cnt += freq[need];
            freq[xr]++;
        }
        return cnt;
    }
};
```

#### JavaScript
```javascript
function subarraysWithXorK(arr, k) {
    let map = new Map();
    map.set(0, 1);
    let xor = 0;
    let count = 0;

    for (let num of arr) {
        xor ^= num;
        let need = xor ^ k;
        if (map.has(need)) {
            count += map.get(need);
        }
        map.set(xor, (map.get(xor) || 0) + 1);
    }
    return count;
}

// Test
console.log(subarraysWithXorK([4,2,2,6,4], 6)); // 4
console.log(subarraysWithXorK([5,6,7,8,9], 5)); // 2
```

---

### Complexity Summary

| Approach     | Time       | Space   | Verdict        |
|--------------|------------|---------|----------------|
| Brute        | O(N³)      | O(1)    | TLE            |
| Better       | O(N²)      | O(1)    | AC (small N)   |
| **Optimal**  | **O(N)**   | **O(N)**| **Best**       |

**Use Optimal in interviews – it's a top-tier question!**

---