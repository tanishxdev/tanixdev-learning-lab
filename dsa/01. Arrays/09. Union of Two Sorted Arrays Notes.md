# Problem: Union of Two Sorted Arrays

**GFG Link**: https://www.geeksforgeeks.org/problems/union-of-two-sorted-arrays/1  
**LeetCode (Similar)**: https://leetcode.com/problems/merge-sorted-array/

---

## 1. Problem Statement

**English**:  
Given two **sorted arrays** `arr1` and `arr2` of sizes, find their **union** — all **distinct elements** in **ascending order**.

**Hinglish**:  
Do sorted arrays ka **union** nikalo — saare **alag-alag** elements, **chhote se bade** order mein.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr1 = [1,2,3,4,5]`, `arr2 = [2,3,4,4,5]`  
**Output Expected**: `[1,2,3,4,5]`

**Constraints**:  
- `1 ≤ n, m ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- Arrays are **sorted in non-decreasing order**

---

## 3. Examples (All Cases Covered)

| Example | arr1 | arr2 | Output | Why |
|-------|------|------|--------|-----|
| 1 | `[1,2,3,4,5]` | `[2,3,4,4,5]` | `[1,2,3,4,5]` | Duplicates removed |
| 2 | `[1,2,3,4,5,6,7,8,9,10]` | `[2,3,4,4,5,11,12]` | `[1,2,3,4,5,6,7,8,9,10,11,12]` | Long arrays |
| 3 | `[1,3,5]` | `[2,4,6]` | `[1,2,3,4,5,6]` | No overlap |
| 4 | `[1,1,1]` | `[1,1,1]` | `[1]` | All same |
| 5 | `[1]` | `[2]` | `[1,2]` | Single elements |
| 6 | `[]` | `[1,2]` | `[1,2]` | One empty |

---

## 4. Intuition & Core Thinking

> **Since arrays are sorted → we can merge them like in merge sort!**

Think of it like:  
> "I’m combining two sorted lists. I take the smaller one, but **skip duplicates**."

Key Insight:  
- Use **two pointers** (`i`, `j`)  
- Compare `arr1[i]` and `arr2[j]`  
- Insert **only if different from last inserted**  
- Final result is **sorted + unique**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Using `map` / `set` (Easy but Slower)

### Intuition  
Insert all elements into a `map` or `set` → extract keys → sorted & unique.

### Why This Approach?  
- Easy to code  
- Handles duplicates  
- Works for **unsorted** too

### Why Move to Next?  
- **O((m+n) log(m+n))** time  
- **O(m+n)** space  
- **Slower than optimal**

---

### Code (Set)

#### C++
```cpp
vector<int> unionWithSet(vector<int>& a, vector<int>& b) {
    set<int> s;
    for (int x : a) s.insert(x);
    for (int x : b) s.insert(x);
    return vector<int>(s.begin(), s.end());
}
```

* Time: **O((m+n) log(m+n))**, Space: **O(m+n)**

---

## Approach 2: Two Pointers (Optimal & Fastest)

### Intuition  
> **Merge two sorted arrays, but skip duplicates**

Use:
- `i` → pointer in `arr1`  
- `j` → pointer in `arr2`  
- `union` vector to store result

**Only insert if:**
- It's the first element, **or**
- It's **different from last element in union**

### Why This Approach?  
- **O(m + n) time**  
- **O(1) extra space** (if output not counted)  
- **In-place merge style**  
- **Interview favorite**

### Why This is Final?  
- **Fastest possible**  
- **Optimal**  
- Uses sorted property

---

### Algorithm  
``` 
i = 0, j = 0
union = []

while i < n and j < m:
    if arr1[i] <= arr2[j]:
        if union empty or union.back() != arr1[i]:
            union.push(arr1[i])
        i++
    else:
        if union empty or union.back() != arr2[j]:
            union.push(arr2[j])
        j++

# Remaining elements
while i < n:
    if union.back() != arr1[i]: union.push(arr1[i])
    i++
while j < m:
    if union.back() != arr2[j]: union.push(arr2[j])
    j++

return union
```

---

### Dry Run: [1,2,3,4,5], [2,3,4,4,5]

| i | j | arr1[i] | arr2[j] | Compare | Action | union |
|---|---|---------|---------|--------|--------|-------|
| 0 | 0 | 1       | 2       | 1<2    | add 1  | [1]   |
| 1 | 0 | 2       | 2       | 2==2   | add 2  | [1,2] |
| 2 | 1 | 3       | 3       | 3==3   | add 3  | [1,2,3] |
| 3 | 2 | 4       | 4       | 4==4   | add 4  | [1,2,3,4] |
| 4 | 3 | 5       | 4       | 5>4    | add 4? → skip (last=4) | — |
| 4 | 4 | 5       | 5       | 5==5   | add 5  | [1,2,3,4,5] |

---

### Code

#### C++ (Optimal)
```cpp
vector<int> findUnion(vector<int>& arr1, vector<int>& arr2) {
    int n = arr1.size(), m = arr2.size();
    int i = 0, j = 0;
    vector<int> unionArr;

    while (i < n && j < m) {
        if (arr1[i] <= arr2[j]) {
            if (unionArr.empty() || unionArr.back() != arr1[i])
                unionArr.push_back(arr1[i]);
            i++;
        } else {
            if (unionArr.empty() || unionArr.back() != arr2[j])
                unionArr.push_back(arr2[j]);
            j++;
        }
    }

    while (i < n) {
        if (unionArr.back() != arr1[i])
            unionArr.push_back(arr1[i]);
        i++;
    }
    while (j < m) {
        if (unionArr.back() != arr2[j])
            unionArr.push_back(arr2[j]);
        j++;
    }

    return unionArr;
}
```

#### JavaScript
```js
function findUnion(arr1, arr2) {
    let n = arr1.length, m = arr2.length;
    let i = 0, j = 0;
    let union = [];

    while (i < n && j < m) {
        if (arr1[i] <= arr2[j]) {
            if (union.length === 0 || union[union.length-1] !== arr1[i])
                union.push(arr1[i]);
            i++;
        } else {
            if (union.length === 0 || union[union.length-1] !== arr2[j])
                union.push(arr2[j]);
            j++;
        }
    }

    while (i < n) {
        if (union[union.length-1] !== arr1[i])
            union.push(arr1[i]);
        i++;
    }
    while (j < m) {
        if (union[union.length-1] !== arr2[j])
            union.push(arr2[j]);
        j++;
    }

    return union;
}
```

* Time: **O(m + n)**, Space: **O(1)** (output excluded)

---

## 5. Edge Case List (Line-wise)

| Edge Case | arr1 | arr2 | Expected | Handled? |
|---------|------|------|----------|---------|
| Empty arrays | `[]` | `[]` | `[]` | Yes |
| One empty | `[]` | `[1,2]` | `[1,2]` | Yes |
| All same | `[1,1]` | `[1,1]` | `[1]` | Yes |
| No overlap | `[1,2]` | `[3,4]` | `[1,2,3,4]` | Yes |
| Full overlap | `[1,2]` | `[1,2]` | `[1,2]` | Yes |
| Large k | 10⁵ elements | 10⁵ elements | Correct | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Set / Map | O((m+n) log(m+n)) | O(m+n) | Learning |
| **Two Pointers** | **O(m + n)** | **O(1)** | **Interviews (Optimal)** |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Using Set (Easy)
    vector<int> unionWithSet(vector<int>& a, vector<int>& b) {
        set<int> s;
        for (int x : a) s.insert(x);
        for (int x : b) s.insert(x);
        return vector<int>(s.begin(), s.end());
    }

    // Optimal: Two Pointers
    vector<int> findUnion(vector<int>& arr1, vector<int>& arr2) {
        int n = arr1.size(), m = arr2.size();
        int i = 0, j = 0;
        vector<int> unionArr;

        while (i < n && j < m) {
            if (arr1[i] <= arr2[j]) {
                if (unionArr.empty() || unionArr.back() != arr1[i])
                    unionArr.push_back(arr1[i]);
                i++;
            } else {
                if (unionArr.empty() || unionArr.back() != arr2[j])
                    unionArr.push_back(arr2[j]);
                j++;
            }
        }

        while (i < n) {
            if (unionArr.empty() || unionArr.back() != arr1[i])
                unionArr.push_back(arr1[i]);
            i++;
        }
        while (j < m) {
            if (unionArr.empty() || unionArr.back() != arr2[j])
                unionArr.push_back(arr2[j]);
            j++;
        }

        return unionArr;
    }
};
```

### JavaScript
```javascript
class Solution {
    // Set Method
    unionWithSet(a, b) {
        let s = new Set();
        for (let x of a) s.add(x);
        for (let x of b) s.add(x);
        return Array.from(s).sort((x,y) => x-y);
    }

    // Two Pointers
    findUnion(arr1, arr2) {
        let n = arr1.length, m = arr2.length;
        let i = 0, j = 0;
        let union = [];

        while (i < n && j < m) {
            if (arr1[i] <= arr2[j]) {
                if (union.length === 0 || union[union.length-1] !== arr1[i])
                    union.push(arr1[i]);
                i++;
            } else {
                if (union.length === 0 || union[union.length-1] !== arr2[j])
                    union.push(arr2[j]);
                j++;
            }
        }

        while (i < n) {
            if (union.length === 0 || union[union.length-1] !== arr1[i])
                union.push(arr1[i]);
            i++;
        }
        while (j < m) {
            if (union.length === 0 || union[union.length-1] !== arr2[j])
                union.push(arr2[j]);
            j++;
        }

        return union;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since arrays are **sorted**, I’ll use **two pointers** to merge in **O(m+n) time**."  
2. "I’ll compare `arr1[i]` and `arr2[j]`, insert smaller, but **only if different from last inserted**."  
3. "Handle remaining elements at the end."  
4. "Edge cases: empty arrays, all duplicates → handled."  
5. **Bonus**: "Set uses O((m+n) log(m+n)) — slower. This is **optimal**."

---
