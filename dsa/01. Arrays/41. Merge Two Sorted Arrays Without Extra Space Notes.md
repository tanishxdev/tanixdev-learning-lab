# Problem: Merge Two Sorted Arrays Without Extra Space  
**(In-Place Merge into nums1)**

**GFG Link**: https://www.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1  
**LeetCode**: https://leetcode.com/problems/merge-sorted-array/

---

## 1. Problem Statement

**English (Simple):**  
You are given two sorted arrays:  
- `nums1` → length `m + n` (first `m` elements are real, last `n` are `0`s)  
- `nums2` → length `n` (all real elements)  

Your task: Merge both into `nums1` such that final `nums1` is fully sorted in **non-decreasing order**, **without using extra space**.

**Hinglish:**  
Do sorted arrays ko merge karna hai, lekin extra array nahi banega.  
`nums1` mein already jagah hai (zeros ke saath), usi mein final sorted array banake daal do.

---

## 2. Input / Output / Constraints

**Input Example:**  
```cpp
nums1 = [1, 3, 5, 0, 0, 0], m = 3  
nums2 = [2, 4, 6],         n = 3  
```

**Output Expected:**  
```cpp
nums1 becomes → [1, 2, 3, 4, 5, 6]
```

**Constraints:**  
- `0 ≤ m, n ≤ 200`  
- `1 ≤ m + n ≤ 200`  
- `-10⁹ ≤ nums1[i], nums2[i] ≤ 10⁹`  
- Both arrays are **sorted in non-decreasing order**

---

## 3. Examples (All Cases Covered)

| Example | nums1 (with m)         | nums2         | Final nums1               | Why |
|-------|-------------------------|---------------|----------------------------|-----|
| 1     | [1,3,5,0,0,0], m=3     | [2,4,6]       | [1,2,3,4,5,6]             | Normal case |
| 2     | [1], m=1                | []            | [1]                        | nums2 empty |
| 3     | [0,0,0], m=0            | [2,5,6]       | [2,5,6]                    | nums1 empty |
| 4     | [4,5,6,0,0,0], m=3     | [1,2,3]       | [1,2,3,4,5,6]             | nums2 smaller |
| 5     | [1,2,3,0,0], m=3       | [4,5]         | [1,2,3,4,5]               | nums1 smaller |
| 6     | [2,0], m=1             | [1]           | [1,2]                      | Smallest case |

---

## 4. Intuition & Core Thinking (Clear & Easy Language)

**Wrong Way (Jo hum sochte hain pehle):**  
Start from front → take small element → insert → shift all → **O(n²)** → TLE!

**Smart Way (Jo interviewer chahta hai):**  
**"Bade se chhote ki taraf jaao!"**

Think like this:  
> Sabse bada element kahan hoga? → Dono arrays ke end mein!  
> Toh end se start karo, bada wala peeche daalte jao → koi shifting nahi lagega!

**Visualize like filling from the back:**  
Imagine you're filling a bucket from the bottom (end).  
You always pick the **larger** fruit from two baskets and put it at the bottom.

**Three Pointers Magic:**  
- `i` → last valid element of nums1  
- `j` → last element of nums2  
- `k` → last position in nums1 (where to place next big element)

**Compare nums1[i] and nums2[j] → jo bada hai, usko nums1[k] mein daal do!**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Insert & Shift

### Intuition  
Insert elements of nums2 one by one from front → shift nums1 elements right.

### Why Bad?  
- Every insertion → O(m) shift  
- Total time → O(m×n) → **TLE**

### Never Do This in Interview!

---

## Approach 2: Extra Array + Copy Back

### Intuition  
Use a new array → merge normally → copy back to nums1.

### Why Not Allowed?  
- Uses O(m+n) extra space  
- Problem says **"without extra space"** → fail!

---

## Approach 3: Optimal – Start from End (Three Pointers)

### Intuition  
**Start from the end → compare → place larger → move left**

**Why this works:**  
- We are filling nums1 from the end → no overwriting of useful data  
- Larger elements go to the end first → perfect for sorted order  
- No shifting needed!

### Why This is Final?  
- **O(m + n)** time  
- **O(1)** space  
- **Interview favorite**  
- Clean, bug-free, elegant

---

### Algorithm (Step by Step)

1. `i = m - 1` → last real element in nums1  
2. `j = n - 1` → last element in nums2  
3. `k = m + n - 1` → last index of nums1  

4. While `i >= 0` and `j >= 0`:  
  → If `nums1[i] > nums2[j]` → put `nums1[i]` at `nums1[k]`, `i--`, `k--`  
  → Else → put `nums2[j]` at `nums1[k]`, `j--`, `k--`

5. If nums2 has remaining elements (`j >= 0`) → copy them  
6. If nums1 has remaining → already in place (no need to touch)

---

### Dry Run: nums1 = [1,3,5,0,0,0], nums2 = [2,4,6]

| Step | i | j | k | nums1[k] gets | nums1 becomes           |
|------|---|----|---|---------------|--------------------------|
| 1    | 2 | 2 | 5 | 6 (bigger)    | [1,3,5,0,0,6]           |
| 2    | 2 | 1 | 4 | 5 > 4 → 5     | [1,3,5,0,5,6]           |
| 3    | 1 | 1 | 3 | 4 = 4 → 4     | [1,3,5,4,5,6]           |
| 4    | 1 | 0 | 2 | 3 > 2 → 3     | [1,3,3,4,5,6]           |
| 5    | 0 | 0 | 1 | 2 = 2 → 2     | [1,2,3,4,5,6]           |
| 6    | 0 | -1| 0 | 1 → place 1   | [1,2,3,4,5,6] Done!    |

Perfect!

---

### Code (Clean & Clear)

#### C++
```cpp
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1;      // last valid in nums1
    int j = n - 1;      // last in nums2
    int k = m + n - 1;  // last position in nums1

    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }

    // Only copy remaining from nums2 (if any)
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
    // No need for nums1 remaining → already in place!
}
```

#### JavaScript
```js
function merge(nums1, m, nums2, n) {
    let i = m - 1;
    let j = n - 1;
    let k = m + n - 1;

    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }

    // Copy remaining from nums2
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}
```

* Time Complexity: **O(m + n)**  
* Space Complexity: **O(1)** → True in-place!

---

## 5. Edge Case List

| Edge Case             | Handled? | Why Safe |
|-----------------------|---------|---------|
| nums2 empty (n=0)     | Yes     | j starts -1 → loop skipped |
| nums1 empty (m=0)     | Yes     | i = -1 → only copy nums2 |
| All nums1 > nums2     | Yes     | Copies nums2 first |
| All nums2 > nums1     | Yes     | Copies nums1 first |
| Duplicates            | Yes     | `>=` or `>` doesn't matter |
| Single element        | Yes     | Works perfectly |

---

## 6. Complexity Summary

| Approach               | Time       | Space   | Verdict     |
|-----------------------|------------|---------|-------------|
| Insert from front     | O(m×n)     | O(1)    | TLE         |
| Extra array           | O(m+n)     | O(m+n)  | Not allowed |
| **From End (3 Ptr)**  | **O(m+n)** | **O(1)**| **Optimal** |

---

## 7. Final Consolidated Code

### C++
```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
};
```

### JavaScript
```js
var merge = function(nums1, m, nums2, n) {
    let i = m - 1, j = n - 1, k = m + n - 1;
    
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }
    
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
};
```

---