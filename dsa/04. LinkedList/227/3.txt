Good.
Now we do **ONLY this one problem**:

# **MERGE TWO SORTED LINKED LISTS (LC 21)**

We will follow the **same master notes format** you locked.

---

# LINKED LIST — MERGE TWO SORTED LINKED LISTS

---

## What We Are Solving

You are given two sorted linked lists:

```
l1 → 1 → 3 → 5 → null
l2 → 2 → 4 → 6 → null
```

You must merge them into **one sorted linked list**:

```
1 → 2 → 3 → 4 → 5 → 6 → null
```

And return the **head of the merged list**.

---

## Why This Problem Exists

This is not about merging arrays.

It tests:

> Can you **rebuild pointers** across two lists **without losing nodes**?

You are not allowed to create new nodes (LeetCode).
You must **reuse existing nodes**.

So this is a **pointer weaving problem**.

---

## Core Mindset

> We never “combine values”.
> We only **choose which node comes next**.

At every step:

* Look at `l1.data` and `l2.data`
* Pick the **smaller node**
* Attach it to the result
* Move forward in that list

This repeats until one list becomes empty.

---

# Two Ways to Solve

1. **Recursive (your video logic)**
2. **Iterative (dummy node method)**

We will do **both**.

---

# PART A — RECURSIVE MERGE (Your Video Logic)

---

## Intuition

Think like this:

> “Whichever list has smaller head, that head must become the next node in the result.”

After choosing one node:

* The remaining work is again **merge two sorted lists**
* So we recurse

---

## Base Case

If one list is empty:

```
l1 == null → return l2  
l2 == null → return l1
```

Because:

> Nothing left to merge, so return whatever is left.

---

## Pseudocode

```
MERGE(l1, l2):

    IF l1 == null: return l2
    IF l2 == null: return l1

    IF l1.data < l2.data:
        l1.next = MERGE(l1.next, l2)
        return l1
    ELSE:
        l2.next = MERGE(l1, l2.next)
        return l2
```

---

## C++ Code

### Version 1 — Clean

```cpp
Node* merge(Node* l1, Node* l2) {
    if (l1 == nullptr) return l2;
    if (l2 == nullptr) return l1;

    if (l1->data < l2->data) {
        l1->next = merge(l1->next, l2);
        return l1;
    } else {
        l2->next = merge(l1, l2->next);
        return l2;
    }
}
```

---

### Version 2 — Full Program

```cpp
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

Node* merge(Node* l1, Node* l2) {

    // Base cases
    if (l1 == nullptr) return l2;
    if (l2 == nullptr) return l1;

    // Choose smaller head
    if (l1->data < l2->data) {
        l1->next = merge(l1->next, l2);
        return l1;
    } else {
        l2->next = merge(l1, l2->next);
        return l2;
    }
}

void traverse(Node* head) {
    while (head != nullptr) {
        cout << head->data << " ";
        head = head->next;
    }
}

int main() {
    Node* l1 = new Node(1);
    l1->next = new Node(3);
    l1->next->next = new Node(5);

    Node* l2 = new Node(2);
    l2->next = new Node(4);
    l2->next->next = new Node(6);

    Node* res = merge(l1, l2);
    traverse(res);
}
```

---

## Dry Run (Recursive)

```
l1: 1 → 3 → 5
l2: 2 → 4 → 6
```

| Compare | Pick     | Next Call     |
| ------- | -------- | ------------- |
| 1 vs 2  | 1        | merge(3,2)    |
| 3 vs 2  | 2        | merge(3,4)    |
| 3 vs 4  | 3        | merge(5,4)    |
| 5 vs 4  | 4        | merge(5,6)    |
| 5 vs 6  | 5        | merge(null,6) |
| null    | return 6 |               |

Final:

```
1 → 2 → 3 → 4 → 5 → 6
```

---

# PART B — ITERATIVE MERGE (Dummy Node)

---

## Intuition

We create a **dummy node** to build the result list safely.

We keep attaching the smaller node.

---

## Pseudocode

```
dummy
tail = dummy

WHILE l1 and l2:
    IF l1.data < l2.data:
        tail.next = l1
        l1 = l1.next
    ELSE:
        tail.next = l2
        l2 = l2.next
    tail = tail.next

Attach remaining list

RETURN dummy.next
```

---

## C++ Code

### Version 1 — Clean

```cpp
Node* merge(Node* l1, Node* l2) {
    Node dummy(0);
    Node* tail = &dummy;

    while (l1 && l2) {
        if (l1->data < l2->data) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }

    tail->next = (l1 != nullptr) ? l1 : l2;

    return dummy.next;
}
```

---

## Time & Space

| Method    | Time   | Space  |
| --------- | ------ | ------ |
| Recursive | O(n+m) | O(n+m) |
| Iterative | O(n+m) | O(1)   |

---

## Interview Truth

> Merge Two Sorted Lists is just **“who comes next?”** repeated until one list dies.

---

If this is clear, say **“next”** and we will do:

> **Merge Two Sorted Lists in Reverse Order (GFG PTD)**
