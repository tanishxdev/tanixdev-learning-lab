# 15.5 useImperativeHandle

---

# 1. Why useImperativeHandle?

### The core problem

By default, React follows **declarative UI** and **one-way data flow**.
Parents pass data down to children through **props**, but parents cannot directly call internal functions of the child component.

However, in real-world UI, sometimes a parent **must imperatively control** a child component.

Examples:

* Manually focusing an input field
* Triggering a child's animation
* Reading or resetting internal values
* Opening or closing a modal from parent
* Scrolling a child component to a position
* Controlling a complex UI widget

React’s default behavior:

```jsx
const ref = useRef();
<Child ref={ref} />
```

If `Child` is a functional component:

* The parent ref only points to the **DOM node**, not child methods
* The parent cannot call custom functions inside child
* You cannot expose selected internal functionality

`useImperativeHandle` solves this by letting you define **what the parent is allowed to access** from a child component.

---

# 2. What is useImperativeHandle?

`useImperativeHandle` is a hook that **customizes the value exposed to parent components** when using `ref`.

It works with `forwardRef`:

```jsx
useImperativeHandle(ref, () => ({
  method1,
  method2
}));
```

This allows the parent to call:

```jsx
ref.current.method1();
```

Instead of returning the actual DOM node, you expose only the methods you choose.

---

# 3. When to use useImperativeHandle?

Use it ONLY when:

* Parent must control child behavior
* Child needs to expose imperative actions
* Functional components need ref-based control
* DOM-like actions are required but not directly accessible
* You are building a reusable input, modal, or animation component

Real examples:

* Custom Input component exposing `.focus()`
* Modal exposing `.open()` and `.close()`
* Carousel exposing `.next()` and `.prev()`
* Form field exposing `.reset()`
* Scrollable container exposing `.scrollToBottom()`

Do NOT use it for:

* Normal data passing (use props)
* State lifting
* Re-rendering logic
* Anything not requiring direct imperative control

---

# 4. Analogy

Think of `useImperativeHandle` like a hotel room keycard.

* Guest (parent) does not have access to everything in the hotel (child)
* But the hotel provides a keycard that allows specific actions
  – enter room
  – turn on lights

Child component decides **which “abilities”** to expose.

---

# 5. How it works internally

1. Parent creates a ref
2. Parent attaches ref to child using `forwardRef`
3. Child calls useImperativeHandle(ref, createObject)
4. React sets `ref.current` to whatever object you return
5. Parent can now call these methods
6. React keeps object stable across renders unless dependencies change

Important:

* Methods exposed DO NOT cause re-render
* Only intentional imperative actions happen
* Parent does not get access to entire child, only what child provides

---

# 6. Developer Mindset Thinking

Ask:

1. Does the parent need to trigger a DOM behavior inside the child?
2. Am I building a reusable component library?
3. Does the child need to expose a controlled API?
4. Is the imperative action unavoidable?
5. Will props not solve this?

If YES → useImperativeHandle.
If NO → do not use it.

React prefers declarative patterns.
ImperativeHandle is an exception used intentionally.

---

# 7. Simple Code Example

Parent focuses child input using custom method.

## File: CustomInput.jsx

```jsx
import { forwardRef, useImperativeHandle, useRef } from "react";

function CustomInput(_, ref) {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus() {
      inputRef.current.focus();
    }
  }));

  return <input ref={inputRef} placeholder="Type here..." />;
}

export default forwardRef(CustomInput);
```

## File: Parent.jsx

```jsx
import { useRef } from "react";
import CustomInput from "./CustomInput";

export default function Parent() {
  const inputRef = useRef();

  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>
        Focus Input
      </button>
    </div>
  );
}
```

---

# 8. Dry Run of the Example

1. Parent creates `inputRef`.
2. Parent renders `<CustomInput ref={inputRef} />`.
3. React forwards the ref to CustomInput.
4. CustomInput uses:

```
useImperativeHandle(ref, () => ({
  focus() { inputRef.current.focus(); }
}));
```

5. React sets:

```
inputRef.current = { focus: function }
```

6. When parent clicks button:

```
inputRef.current.focus()
```

7. Child input receives focus immediately.
8. No re-renders required.

---

# 9. Example 2: Modal exposing open() and close()

```jsx
useImperativeHandle(ref, () => ({
  open: () => setVisible(true),
  close: () => setVisible(false)
}));
```

Parent can:

```jsx
modalRef.current.open();
```

---

# 10. Common Mistakes

1. **Using without forwardRef**
   It will not work unless component uses forwardRef.

2. **Exposing entire component or DOM node**
   Always expose minimal API.

3. **Using for data flow**
   Not intended for passing data. Use props.

4. **Exposing unstable functions**
   Methods should be stable, not recreated unnecessarily.

5. **Misusing it for things that should be declarative**
   Only use when imperative action is required.

---

# 11. When NOT to Use useImperativeHandle

* For sending data from parent to child
* For triggering re-renders
* For list manipulation
* For state management
* When props can achieve the same result
* For uncontrolled DOM access unless required

Avoid unless UI requires direct command-style actions.

---

# 12. Best Practices

1. Expose only necessary methods
2. Keep methods small and specific
3. Wrap component in forwardRef
4. Do not use for non-DOM interactions
5. Prefer declarative patterns wherever possible

---

# 13. Compare: useRef vs useImperativeHandle

| Feature                  | useRef | useImperativeHandle |
| ------------------------ | ------ | ------------------- |
| Access DOM node          | Yes    | If exposed          |
| Expose custom methods    | No     | Yes                 |
| Works without forwardRef | Yes    | No                  |
| Used for component API   | No     | Yes                 |
| Controls child behavior  | No     | Yes                 |

---

# 14. Follow-up questions

1. Why doesn't React allow parent to call child functions by default?
2. What role does forwardRef play in useImperativeHandle?
3. Why is useImperativeHandle considered an escape hatch?
4. What happens if you return unstable functions?
5. When should a developer avoid useImperativeHandle?
6. Why is this hook ideal for custom inputs and modals?
7. Does useImperativeHandle trigger re-renders?
8. How does React store the object returned by useImperativeHandle?
9. What is the difference between accessing DOM through ref vs exposing methods?
10. Can you expose state via useImperativeHandle? Why not recommended?
