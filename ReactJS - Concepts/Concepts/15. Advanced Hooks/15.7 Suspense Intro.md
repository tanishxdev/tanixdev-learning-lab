# 15.7 Suspense Intro

---

# 1. Why Suspense?

### The core problem

React components often depend on **asynchronous data**:

* Fetching API data
* Loading lazy components
* Waiting for slow resources
* Preparing heavy UI chunks

Traditionally, developers handled async loading manually:

```jsx
if (loading) return <Spinner />;
```

Problems with manual loading handling:

1. Repeated boilerplate in every component
2. Inconsistent loading UI across application
3. Difficult to coordinate multiple async sources
4. Hard to show partial UI while waiting
5. No standard mechanism for delayed UI hydration (SSR/CSR)
6. UI flashes or flickers during asynchronous data fetch
7. No way to stream data into UI gradually
8. Impossible to block rendering of children declaratively

React needed a **centralized, declarative mechanism** to handle asynchronous UI.

Suspense solves this.

---

# 2. What is Suspense?

Suspense is a React mechanism that **pauses rendering** until some data or resource is ready, and shows a fallback UI in the meantime.

Basic usage:

```jsx
<Suspense fallback={<Loading />}>
  <SomeComponent />
</Suspense>
```

Meaning:

* If SomeComponent (or its children) is “not ready” → fallback UI shows
* When ready → Suspense boundary continues rendering normally

Suspense is NOT only for data fetching; it's a **rendering control mechanism**.

Suspense allows:

* Lazy-loading components
* Streaming server rendering
* Managing loading states declaratively
* Blocking or deferring part of UI

---

# 3. When to use Suspense?

Use Suspense when a component depends on something that may not be immediately available.

Typical use cases:

* Lazy-loaded components using React.lazy
* Server Components (React 18)
* Streaming rendering (SSR HTML chunks)
* Data fetching libraries with Suspense support (React Query, Relay)
* Controlled loading boundaries for smoother UI

Do NOT use Suspense for:

* Manual state-based loading if not required
* API fetching in useEffect without Suspense-friendly libs
* Logic that must always run before UI renders

Suspense requires React to “throw a promise” internally; not all components support this yet.

---

# 4. Analogy

Imagine a movie theater:

* Audience waits in lobby
* Theater staff prepares the hall
* Only when ready → doors open

Suspense acts like:

* Lobby = fallback UI
* Preparation = async loading
* Opening doors = component becomes ready

The audience doesn’t see the incomplete hall.

---

# 5. How it works internally

React’s Suspense relies on **render interruption**.

Internal sequence:

1. React begins rendering a component
2. Component requests some async resource
3. If not ready → component throws a promise
4. React pauses rendering at the Suspense boundary
5. React renders the fallback UI
6. When the promise resolves → React resumes rendering
7. UI updates with the fully ready component

Important:

* Suspense is tied to React’s concurrent rendering model
* It allows rendering to pause and resume
* It never blocks the main thread

Suspense is the gateway to advanced React features like **Streaming**, **Server Components**, **use**, **Transitions**, etc.

---

# 6. Developer Mindset Thinking

Ask:

1. Does this part of UI load asynchronously?
2. Should I show a placeholder during loading?
3. Does the UI need to avoid half-loaded screens?
4. Am I loading a large component lazily?
5. Do I want a clean, declarative loading mechanism?
6. Am I using a data library that supports Suspense (React Query, Relay)?

If YES → wrap with Suspense.

---

# 7. Simple Code Example

Lazy-loaded component.

## File: LazyComponent.jsx

```jsx
export default function LazyComponent() {
  return <h2>This component was loaded lazily.</h2>;
}
```

## File: App.jsx

```jsx
import { Suspense, lazy } from "react";

const LazyComponent = lazy(() => import("./LazyComponent"));

export default function App() {
  return (
    <Suspense fallback={<p>Loading...</p>}>
      <LazyComponent />
    </Suspense>
  );
}
```

What happens:

* LazyComponent imports asynchronously
* Suspense detects delay
* Shows fallback
* Once loaded → renders actual component

---

# 8. Dry Run of the Example

1. App renders
2. LazyComponent import begins
3. React suspends at boundary because import is still loading
4. Fallback `<p>Loading...</p>` is displayed
5. When module loads → promise resolves
6. React resumes rendering
7. LazyComponent displays

No flicker.
No manual “loading state”.

---

# 9. Example 2: Suspense with multiple components

```jsx
<Suspense fallback={<p>Loading parts...</p>}>
  <Chart />
  <Comments />
  <Profile />
</Suspense>
```

All wrapped components must be ready before UI appears.

---

# 10. Common Mistakes

1. Expecting Suspense to work automatically with fetch
   Suspense only works when resource “throws a promise”.

2. Using fallback as a loading spinner for all UI
   Best to use nested boundaries instead.

3. Wrapping too much UI inside Suspense
   Leads to full-screen blocking.

4. Not using lazy() for dynamic import
   Suspense requires something async.

5. Mixing Suspense and useEffect-based fetching
   Suspense will not detect the useEffect fetch.

---

# 11. When NOT to Use Suspense

* One-off simple loading logic
* When using libraries that don’t support Suspense
* For synchronous UI rendering
* For logic that must execute before render (useLayoutEffect is better)
* Without understanding how boundaries work

---

# 12. Best Practices

1. Use Suspense with **React.lazy** for code-splitting
2. Use multiple nested Suspense boundaries
3. Keep fallback small and meaningful
4. Use Suspense-aware data fetching libraries
5. Avoid wrapping the whole app in a single Suspense
6. Prefer fine-grained UI blocking

---

# 13. Compare: Suspense vs useEffect loading

| Feature                      | Suspense | useEffect-based loading |
| ---------------------------- | -------- | ----------------------- |
| Declarative                  | Yes      | No                      |
| Standardized loading         | Yes      | No                      |
| Concurrent rendering support | Yes      | No                      |
| Interruptible                | Yes      | No                      |
| Fallback handling            | Built-in | Manual                  |
| Boilerplate                  | Low      | High                    |

Suspense is the future model of async UI in React.

---

# 14. Follow-up questions

1. Why was Suspense introduced?
2. How does Suspense decide when to show fallback?
3. Why doesn't Suspense work with traditional fetch calls?
4. What is the relationship between Suspense and React.lazy?
5. Can Suspense wrap multiple async components?
6. How does Suspense avoid flickering during async load?
7. What happens internally when a component "suspends"?
8. Why should Suspense boundaries be small and focused?
9. How does Suspense improve SSR and streaming rendering?
10. What is the difference between Suspense and traditional loading states?

---
