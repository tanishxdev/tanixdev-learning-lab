# 15.9 When to use which hook

---

# 1. Why We Need a “When to Use Which Hook” Guide

### The core problem

React provides many hooks (basic + advanced).
Beginners often struggle with:

* Choosing the correct hook for a situation
* Understanding performance impact
* Misusing advanced hooks for simple problems
* Using basic hooks where advanced control is required
* Confusing useEffect, useLayoutEffect, and Suspense
* Handling async, layout, subscription, or heavy updates incorrectly

This leads to:

* Unnecessary re-renders
* UI lag or freeze
* Layout flicker
* Incorrect async behavior
* Complex code for simple logic
* Over-engineering or under-engineering

Developers need a clear **decision-making framework**.

---

# 2. What Hooks Categories Exist?

There are **four categories** of hooks:

### A. State Hooks

* useState
* useReducer

### B. Side-effect & Lifecycle Hooks

* useEffect
* useLayoutEffect

### C. Performance Optimization Hooks

* useMemo
* useCallback
* useTransition
* useDeferredValue

### D. Reference / Imperative & External Hooks

* useRef
* useId
* useSyncExternalStore
* useImperativeHandle

Plus:

### E. Suspense / Error Control

* Suspense
* Error Boundaries
* use (future React)

Different hooks solve **different classes of problems**.
Choosing the right one requires understanding intent.

---

# 3. When to Use Which Hook (Master Table)

| Situation                                     | Best Hook            | Why                          |
| --------------------------------------------- | -------------------- | ---------------------------- |
| Component needs local state                   | useState             | Simple values, quick updates |
| Complex state transitions                     | useReducer           | Predictable, reducer pattern |
| Run side-effects (API, logging)               | useEffect            | After paint, safe, async     |
| Sync layout before paint                      | useLayoutEffect      | Avoid flicker, measure DOM   |
| Store mutable value without re-render         | useRef               | Persistent reference         |
| Expose DOM methods to parent                  | useImperativeHandle  | Custom imperative API        |
| Unique stable ID for labels                   | useId                | SSR-safe deterministic ID    |
| Subscribe to external store                   | useSyncExternalStore | Stable subscriptions         |
| Heavy computation depends on value            | useMemo              | Cache expensive results      |
| Prevent function recreation                   | useCallback          | Stabilize function identity  |
| Expensive re-renders triggered by interaction | useTransition        | Mark non-urgent updates      |
| Heavy derived value updates                   | useDeferredValue     | Slow down heavy UI work      |
| Load async UI (lazy, data)                    | Suspense             | Declarative async boundaries |
| Isolate component errors                      | Error Boundaries     | Prevent UI crashes           |

This table is the fastest decision tool.

---

# 4. Developer Mindset Flowchart

### Step 1 — Do I need state?

* YES → useState / useReducer
* NO → continue

### Step 2 — Is this about DOM behavior or side-effects?

* YES → useEffect or useLayoutEffect
* useLayoutEffect only when layout measurement is needed

### Step 3 — Is this about performance optimization?

* useMemo → expensive calculations
* useCallback → stable functions
* useTransition → avoid blocking urgent updates
* useDeferredValue → avoid blocking during derived updates

### Step 4 — Is this about referencing DOM or component internals?

* useRef
* useImperativeHandle
* useId

### Step 5 — Is the state external to React?

* useSyncExternalStore

### Step 6 — Is this about loading async data or components?

* Suspense

### Step 7 — Is this about catching render errors?

* Error Boundary

This flow covers 95% of real decisions.

---

# 5. Detailed “When to Use” Breakdown for Each Hook

---

## useState

Use when:

* Local UI state
* Simple counters, forms, toggles
* Component-specific logic

Avoid when:

* Many related state transitions → useReducer

---

## useReducer

Use when:

* Complex state logic
* Multiple conditions
* State transitions depend on previous state

Avoid when:

* State is simple

---

## useEffect

Use when:

* API calls
* Event listeners
* Subscriptions
* Logging
* Anything that must run after DOM paint

Avoid when:

* You need DOM measurement → useLayoutEffect
* Logic can run during render → don’t use effect unnecessarily

---

## useLayoutEffect

Use when:

* Measuring DOM
* Avoiding layout flicker
* Setting scroll position
* Calculating size/position before paint

Avoid when:

* Doing API calls
* Heavy work

---

## useRef

Use when:

* Storing values that persist without re-render
* Focusing inputs
* Holding timers
* Measuring DOM nodes

Avoid when:

* You need state that triggers renders

---

## useImperativeHandle

Use when:

* Parent must control child:
  – focus
  – open/close
  – scroll
  – reset

Avoid when:

* A declarative pattern can solve problem

---

## useId

Use when:

* Labels
* Accessibility
* SSR-safe component IDs

Avoid when:

* List keys
* Business-level IDs

---

## useSyncExternalStore

Use when:

* Connecting React to external store (Redux, Zustand, WebSocket-based stores)

Avoid when:

* Local or simple shared state

---

## useMemo

Use when:

* Expensive calculations
* Derived data
* Heavy filtering/sorting

Avoid when:

* Calculation is cheap
* Unnecessary over-optimization

---

## useCallback

Use when:

* Passing functions to children
* Preventing re-renders
* Stable function identity required

Avoid when:

* No re-render issue

---

## useTransition

Use when:

* Heavy UI updates should be deferred
* Input must stay responsive
* Large lists, charts, expensive updates

Avoid when:

* Update must be instant
* Not heavy

---

## useDeferredValue

Use when:

* Derived UI updates are slow
* Input must be fast
* Avoid expensive recalculations on every keystroke

Avoid when:

* Non-expensive updates
* You need explicit scheduling → useTransition

---

## Suspense

Use when:

* Lazy-loaded components
* Async UI boundaries
* Streaming server rendering
* Suspense-aware data libraries

Avoid when:

* Fetch inside useEffect
* Data library not compatible

---

## Error Boundaries

Use when:

* Isolating risky components
* Catching render errors

Avoid when:

* Async errors
* Event handler errors

---

# 6. Analogy: How Hooks Are Positioned

Think of hooks as tools in a professional workshop:

* Painting → useEffect
* Measuring → useLayoutEffect
* Storing reference → useRef
* Creating tools → useCallback/useMemo
* Delaying heavy jobs → useTransition/useDeferredValue
* Identifying items → useId
* Error shields → Error Boundaries
* Connecting external pipelines → useSyncExternalStore
* Assembling detailed pieces → useState/useReducer

Each has a domain.
Use the tool that fits the metric.

---

# 7. Sample Real-World Scenarios (What hook to choose)

### Scenario A: Search bar + heavy list

* useState (input)
* useDeferredValue (filter value)
* useMemo (heavy filter)

### Scenario B: Lazy loading dashboard widgets

* Suspense
* React.lazy

### Scenario C: Parent needs to reset child form

* useImperativeHandle

### Scenario D: Tracking mouse position

* useEffect + useRef

### Scenario E: Keeping app responsive while sorting 10k items

* useTransition

### Scenario F: Measuring element height before animation

* useLayoutEffect

### Scenario G: Connecting custom store

* useSyncExternalStore

---

# 8. Code patterns: How to choose**

### Basic state example

```jsx
const [value, setValue] = useState("");
```

### Derived expensive value

```jsx
const filteredList = useMemo(() => heavyCalc(value), [value]);
```

### Heavy updates based on input

```jsx
startTransition(() => {
  setFilteredList(filtered);
});
```

### Slow derived value

```jsx
const slowValue = useDeferredValue(value);
```

### DOM measurement

```jsx
useLayoutEffect(() => {
  measure(ref.current);
}, []);
```

### External store subscription

```jsx
useSyncExternalStore(subscribe, getSnapshot);
```

---

# 9. Follow-up questions

1. What is the difference between expensive state updates and expensive derived values?
2. How do you decide between useTransition and useDeferredValue?
3. When is useLayoutEffect mandatory instead of useEffect?
4. Why should useState not be overused for complex logic?
5. When should useRef replace useState?
6. In what cases does useCallback become unnecessary?
7. How does Suspense change loading patterns in React?
8. Why is useSyncExternalStore important for modern state libraries?
9. What problems occur when using useMemo for cheap calculations?
10. Why must React developers think in terms of urgency, layout, and derivation when choosing hooks?

---
