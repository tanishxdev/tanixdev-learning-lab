# 15.1 useLayoutEffect

---

# 1. Why useLayoutEffect?

### The core problem

React updates the DOM asynchronously. A normal `useEffect` runs **after** the DOM paint.

Sometimes you need to:

* Read layout (width, height, position of an element)
* Measure DOM before the browser paints
* Synchronously apply style changes to avoid flicker
* Update scroll position immediately
* Keep UI layout stable

If you use `useEffect` for layout measurements, you may see:

* Layout jump
* Flashing
* Wrong measurement
* One-frame flicker

### Real-world examples where useEffect fails

1. Expanding panels where you need exact height before animation
2. Measuring an element’s bounding box
3. Calculating scroll and applying corrections
4. Synchronizing DOM layout before it appears

---

# 2. What is useLayoutEffect?

`useLayoutEffect` is a hook that runs **synchronously after DOM updates, but before the browser paints the screen**.

Order:

```
React updates DOM  
useLayoutEffect runs  
Browser paints to screen  
useEffect runs later  
```

This makes `useLayoutEffect` the correct tool for layout-sensitive logic.

---

# 3. When to use useLayoutEffect?

Use it **only when your state update depends on DOM measurement**.

Examples:

* Read DOM size, scroll height, width
* Apply immediate DOM adjustments
* Prevent flicker caused by delayed calculation
* Prepare animation layout

Do NOT use it for:

* API calls
* Logging
* Normal side effects

Those belong to `useEffect`.

---

# 4. Analogy

Imagine you want to adjust your shirt before stepping on stage.

* `useEffect` = You adjust after stepping on stage → people see the messy moment
* `useLayoutEffect` = You adjust backstage before stepping out → no one sees the flicker

---

# 5. How it works internally

React render cycle:

```
Render phase:
  - React prepares Virtual DOM
  - React calculates changes

Commit phase:
  - React applies changes to Real DOM
  - useLayoutEffect executes
  - Browser paints to screen
  - useEffect executes
```

So:

* useLayoutEffect blocks painting until it finishes
* useEffect never blocks paint

This is why useLayoutEffect must be used wisely.
Too much logic → janky UI.

---

# 6. Developer Mindset Thinking

Ask yourself:

1. Do I need DOM measurement?
2. Will the UI look wrong for a moment if I wait?
3. Does this logic depend on element size or position?
4. Will useEffect cause a flicker or jump?

If yes → useLayoutEffect.

If the logic is not layout-sensitive → useEffect.

---

# 7. Simple Code Example

Adjusting an element's height before painting.

## File: AutoHeightBox.jsx

```jsx
import { useLayoutEffect, useRef, useState } from "react";

export default function AutoHeightBox() {
  const boxRef = useRef(null);
  const [height, setHeight] = useState(0);

  // useLayoutEffect ensures no flicker
  useLayoutEffect(() => {
    const rect = boxRef.current.getBoundingClientRect();
    setHeight(rect.height);
  }, []);

  return (
    <div>
      <div
        ref={boxRef}
        style={{
          background: "lightgray",
          padding: "20px",
          marginBottom: "10px",
        }}
      >
        This is the box whose height we measure.
      </div>

      <p>Measured height: {height}px</p>
    </div>
  );
}
```

---

# 8. Dry Run of the Example

Step-by-step:

1. Component renders the first time.
2. DOM created → boxRef points to the element.
3. React enters commit phase.
4. Before browser paints:

   * useLayoutEffect runs
   * Measures height
   * Calls setHeight(state)
5. React re-renders immediately
6. Browser paints the final UI with correct height
7. No flicker.

If you used useEffect:

* Paint happens first
* Then measurement
* Flicker appears

---

# 9. Example 2: Fixing a Flickering Animation

When expanding a div, measuring height must happen before paint.

```jsx
useLayoutEffect(() => {
  const height = contentRef.current.scrollHeight;
  setTargetHeight(height);
}, []);
```

This prevents a visible jump.

---

# 10. Common Mistakes

1. Using useLayoutEffect for API calls

   * Blocks paint
   * Slows UI

2. Doing heavy operations inside

   * Causes jank
   * Increases render time

3. Thinking useLayoutEffect fixes rendering problems unrelated to layout

4. Accessing DOM before it's ready

   * It runs after DOM updates, but elements may still be null if conditionally rendered

---

# 11. When NOT to Use useLayoutEffect

* When reading or writing external data
* When changing state unrelated to layout
* When you want to avoid blocking paint
* For event listeners, API calls, subscriptions

---

# 12. Best Practices

1. Keep logic minimal
2. Use useEffect unless layout absolutely requires it
3. Never block thread with heavy computations
4. Always check if you're measuring DOM or preventing flicker
5. Prefer useRef for storing values without re-rendering

---

# 13. Compare: useEffect vs useLayoutEffect

| Feature            | useEffect    | useLayoutEffect |
| ------------------ | ------------ | --------------- |
| Runs before paint  | No           | Yes             |
| Blocks painting    | No           | Yes             |
| Layout measurement | Not reliable | Perfect         |
| Performance        | Better       | More expensive  |
| Primary use        | Side effects | Layout sync     |

---

# 14.Follow-up questions

1. What is the difference between useEffect and useLayoutEffect?
2. Why does useLayoutEffect run before paint?
3. When is useLayoutEffect necessary?
4. What happens if you use useLayoutEffect for heavy logic?
5. Does useLayoutEffect block the browser paint?
6. Why does useEffect cause layout flickering in some cases?
7. Can you measure DOM in useEffect? Why or why not?
8. What are layout thrashing issues?
9. How does the commit phase relate to useLayoutEffect?
10. Is useLayoutEffect used often in real projects? Why?
