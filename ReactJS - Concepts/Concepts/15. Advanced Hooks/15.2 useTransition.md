# **15.2 useTransition**

---

# 1. Why useTransition?

### The core problem

Some state updates in React are **urgent** (typing, clicking), and some are **non-urgent** (filtering a large list, sorting, rendering heavy UI).

Without `useTransition`, both updates happen with the same priority.

This causes problems:

* UI freezes during heavy updates
* Typing input lags
* Click feels delayed
* Entire component tree re-renders immediately
* Browser becomes unresponsive

### Real-world examples where UI lags

1. Searching a list of 10,000 items and filtering on each keystroke
2. Switching tabs with expensive content inside
3. Rendering dashboards with heavy charts
4. Applying filters in a catalog or admin panel
5. Expensive recalculations triggered by minor user input

React needed a way to mark some updates as:

* High priority
* Low priority

`useTransition` solves this.

---

# 2. What is useTransition?

`useTransition` is a React hook that lets you mark a state update as **non-urgent**.

React will:

* Keep the UI responsive
* Show urgent updates immediately
* Defer heavy updates until the browser is free

Signature:

```jsx
const [isPending, startTransition] = useTransition();
```

Meaning:

* `startTransition` wraps low-priority updates
* `isPending` lets you show a loading indicator

---

# 3. When to use useTransition?

Use it when a state update is:

* Heavy
* Causes slow rendering
* Should not block urgent interactions
* Should run in background
* Can wait without affecting UX

Examples:

* Large list filtering
* Heavy calculations
* Changing pages in huge dashboards
* Rendering large tables
* Expensive sorting

Do NOT use it for:

* API calls (useEffect or React Query is correct)
* DOM measurement (useLayoutEffect is correct)
* Immediate user feedback

---

# 4. Analogy

Imagine in a restaurant:

* Urgent task: A customer asks for water → waiter must serve immediately
* Non-urgent task: Preparing a big meal → kitchen does it when ready

`useTransition` = telling React
"This update is like the big meal. Do it later. But keep giving water quickly."

---

# 5. How it works internally

React has two lanes:

* Urgent lane → high priority
* Transition lane → low priority

Flow:

```
User types input  
React updates input immediately (urgent)  
Heavy filtering marked with startTransition  
React waits for free time  
Executes heavy update  
UI never blocks  
```

This avoids jank and keeps interactions smooth.

---

# 6. Developer Mindset Thinking

Ask:

1. Does this update block typing or clicking?
2. Is this update visually heavy?
3. Will user tolerate waiting for it?
4. Should input remain instantly responsive?

If YES → wrap inside `startTransition`.

If the update must happen immediately → do NOT use transition.

---

# 7. Simple Code Example

Large list filtering without freezing.

## File: LargeFilter.jsx

```jsx
import { useState, useTransition } from "react";

export default function LargeFilter() {
  const [query, setQuery] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);

  function handleChange(e) {
    const value = e.target.value;
    setQuery(value); // urgent update

    // non-urgent heavy update
    startTransition(() => {
      const filtered = items.filter((item) =>
        item.toLowerCase().includes(value.toLowerCase())
      );
      setList(filtered);
    });
  }

  return (
    <div>
      <input placeholder="Search..." value={query} onChange={handleChange} />
      {isPending && <p>Filtering...</p>}

      <ul>
        {list.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

# 8. Dry Run of the Example

1. User types “a”.
2. `setQuery("a")` runs immediately (urgent).
   Input updates instantly.
3. Heavy filtering wrapped in `startTransition`.
4. React delays it until free time.
5. `isPending` becomes true → shows “Filtering…”
6. After React finishes heavy work → updates list.
7. UI stays smooth entire time.

Without useTransition, typing would lag.

---

# 9. Example 2: Tab Switch with heavy content

```jsx
startTransition(() => {
  setActiveTab(tabName);
});
```

This avoids UI freeze when switching to a heavy tab.

---

# 10. Common Mistakes

1. Using useTransition for API calls
2. Wrapping everything inside startTransition
3. Assuming it speeds up code
   It only defers it.
4. Using transitions unnecessarily for small components
5. Not using isPending for user feedback

---

# 11. When NOT to Use useTransition

* Validation
* Input formatting
* Form submission
* Immediate button feedback
* Animation logic
* DOM measurement (useLayoutEffect)

Only use when update can be delayed.

---

# 12. Best Practices

1. Keep urgent updates outside transition
2. Always show isPending feedback for UX
3. Wrap only the heavy update
4. Test with large data to verify improvement
5. Avoid nesting transitions

---

# 13. Compare: Normal update vs Transition update

| Feature               | Normal Update | Transition Update |
| --------------------- | ------------- | ----------------- |
| Priority              | High          | Low               |
| Blocks UI             | Yes           | No                |
| Good for input typing | No            | Yes               |
| Good for heavy UI     | No            | Yes               |
| Is it async?          | Yes           | Yes, but deferred |

---

# 14. Follow-up questions

1. What problem does useTransition solve?
2. Why are some updates urgent and some non-urgent?
3. How does React decide priority inside startTransition?
4. What happens if you wrap everything in startTransition?
5. What is isPending used for?
6. Why is filtering a good example for transitions?
7. Does useTransition make operations faster?
8. How does React keep typing smooth while doing heavy updates?
9. Difference between useDeferredValue and useTransition?
10. When should a developer avoid transitions?
