# **20.6 Testing Forms**

A complete, production-grade explanation of **how to test forms in React** using React Testing Library + Jest, including controlled inputs, validation, submission flows, error messages, async form handling, disabled states, success states, and real-world architecture patterns.

Forms are one of the most critical UI features to test because they involve:

* state
* user input
* event handling
* validation
* error feedback
* async submission

This chapter teaches the full approach.

---

# 1. What Does “Testing Forms” Mean?

A form test must verify:

1. The user can type into fields
2. Validation messages appear correctly
3. Submit button enables/disables correctly
4. Form submits the correct data
5. Errors from backend are handled properly
6. Success states appear after submission

You do NOT test:

* form internal state
* internal validation functions except through UI
* implementation details of controlled components

Testing must reflect user behavior.

---

# 2. Tools Needed

```jsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
```

If submission is async:

```jsx
import { waitFor } from "@testing-library/react";
```

---

# 3. Basic Form Example (Controlled Input)

Component:

```jsx
function LoginForm({ onSubmit }) {
  const [email, setEmail] = useState("");

  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        onSubmit(email);
      }}
    >
      <label htmlFor="email">Email</label>
      <input
        id="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
      />

      <button type="submit">Login</button>
    </form>
  );
}
```

Test:

```jsx
test("submits entered email", async () => {
  const mockSubmit = jest.fn();
  render(<LoginForm onSubmit={mockSubmit} />);

  await userEvent.type(screen.getByLabelText(/email/i), "tanish@mail.com");
  await userEvent.click(screen.getByRole("button", { name: /login/i }));

  expect(mockSubmit).toHaveBeenCalledWith("tanish@mail.com");
});
```

This covers:

* typing
* controlled input state update
* submit event
* passing correct data

---

# 4. Testing Form Validation (Client-side)

Component:

```jsx
function SignupForm() {
  const [email, setEmail] = useState("");
  const [error, setError] = useState("");

  const handleSubmit = e => {
    e.preventDefault();
    if (!email.includes("@")) {
      setError("Invalid email");
      return;
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        placeholder="Email"
        value={email}
        onChange={e => setEmail(e.target.value)}
      />

      {error && <p role="alert">{error}</p>}

      <button type="submit">Submit</button>
    </form>
  );
}
```

Test:

```jsx
test("shows validation message for invalid email", async () => {
  render(<SignupForm />);

  await userEvent.type(screen.getByPlaceholderText("Email"), "invalid");
  await userEvent.click(screen.getByRole("button", { name: /submit/i }));

  expect(screen.getByRole("alert")).toHaveTextContent("Invalid email");
});
```

Key point:
You test the **visible error UI**, not internal logic.

---

# 5. Testing Disabled Submit Button

Component:

```jsx
function Form() {
  const [email, setEmail] = useState("");

  return (
    <>
      <input
        placeholder="Email"
        value={email}
        onChange={e => setEmail(e.target.value)}
      />

      <button disabled={!email.includes("@")}>Submit</button>
    </>
  );
}
```

Test:

```jsx
test("submit button is disabled until email is valid", async () => {
  render(<Form />);

  const button = screen.getByRole("button", { name: /submit/i });
  expect(button).toBeDisabled();

  await userEvent.type(screen.getByPlaceholderText("Email"), "abc@mail.com");

  expect(button).toBeEnabled();
});
```

This is an important UX verification.

---

# 6. Testing Asynchronous Form Submission

Component:

```jsx
function ContactForm({ submitForm }) {
  const [status, setStatus] = useState("idle");

  const handleSubmit = async e => {
    e.preventDefault();
    setStatus("loading");
    try {
      await submitForm();
      setStatus("success");
    } catch {
      setStatus("error");
    }
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <button type="submit">Send</button>
      </form>

      {status === "loading" && <p>Sending...</p>}
      {status === "success" && <p>Sent</p>}
      {status === "error" && <p>Failed</p>}
    </>
  );
}
```

Test success:

```jsx
test("shows success after submission", async () => {
  const mockSubmit = jest.fn().mockResolvedValueOnce();

  render(<ContactForm submitForm={mockSubmit} />);

  await userEvent.click(screen.getByRole("button", { name: /send/i }));

  expect(screen.getByText("Sending...")).toBeInTheDocument();

  expect(await screen.findByText("Sent")).toBeInTheDocument();
});
```

Test error:

```jsx
test("shows error when submission fails", async () => {
  const mockSubmit = jest.fn().mockRejectedValueOnce(new Error());

  render(<ContactForm submitForm={mockSubmit} />);

  await userEvent.click(screen.getByRole("button", { name: /send/i }));

  expect(await screen.findByText("Failed")).toBeInTheDocument();
});
```

Async form flows must test:

* loading state
* success state
* error state

---

# 7. Testing Multi-Field Forms

Component:

```jsx
function MultiForm({ onSubmit }) {
  const [form, setForm] = useState({ name: "", email: "" });

  const handleChange = e => {
    setForm({ ...form, [e.target.name]: e.target.value });
  };

  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        onSubmit(form);
      }}
    >
      <input name="name" placeholder="Name" onChange={handleChange} />
      <input name="email" placeholder="Email" onChange={handleChange} />
      <button type="submit">Save</button>
    </form>
  );
}
```

Test:

```jsx
test("submits multiple fields", async () => {
  const mockSubmit = jest.fn();

  render(<MultiForm onSubmit={mockSubmit} />);

  await userEvent.type(screen.getByPlaceholderText("Name"), "John");
  await userEvent.type(screen.getByPlaceholderText("Email"), "john@mail.com");

  await userEvent.click(screen.getByRole("button", { name: /save/i }));

  expect(mockSubmit).toHaveBeenCalledWith({
    name: "John",
    email: "john@mail.com"
  });
});
```

Confirms proper field mapping.

---

# 8. Testing Backend Error Handling (Mock API)

Component:

```jsx
function FormWithAPI({ api }) {
  const [error, setError] = useState("");

  const handleSubmit = async e => {
    e.preventDefault();
    try {
      await api();
    } catch (err) {
      setError("Server error");
    }
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <button type="submit">Submit</button>
      </form>

      {error && <p role="alert">{error}</p>}
    </>
  );
}
```

Test:

```jsx
test("shows API error", async () => {
  const mockAPI = jest.fn().mockRejectedValueOnce(new Error());

  render(<FormWithAPI api={mockAPI} />);

  await userEvent.click(screen.getByRole("button", { name: /submit/i }));

  expect(await screen.findByRole("alert")).toHaveTextContent("Server error");
});
```

Validates server failure handling.

---

# 9. Testing Form Reset Behavior

Component:

```jsx
function ResetForm() {
  const [text, setText] = useState("");

  const handleSubmit = e => {
    e.preventDefault();
    setText("");
  };

  return (
    <>
      <input
        placeholder="Message"
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button onClick={handleSubmit}>Send</button>
    </>
  );
}
```

Test:

```jsx
test("resets field after submit", async () => {
  render(<ResetForm />);

  const input = screen.getByPlaceholderText("Message");

  await userEvent.type(input, "hello");
  await userEvent.click(screen.getByRole("button", { name: /send/i }));

  expect(input).toHaveValue("");
});
```

Covers reset logic.

---

# 10. Common Anti-Patterns

Avoid:

1. Reading internal state
2. Querying by testId when not required
3. Skipping validation tests
4. Using fireEvent instead of userEvent
5. Mocking implementation instead of behavior
6. Using setTimeout in tests (use findBy instead)

Good form tests simulate the **full user experience**.

---

# 11. Full Production Example: Testing a Real Login Form

Component:

```jsx
function Login({ loginAPI }) {
  const [error, setError] = useState("");

  const handleSubmit = async e => {
    e.preventDefault();
    try {
      await loginAPI();
    } catch {
      setError("Invalid credentials");
    }
  };

  return (
    <>
      <input placeholder="Email" />
      <input placeholder="Password" type="password" />
      <button>Login</button>
      {error && <p role="alert">{error}</p>}
    </>
  );
}
```

Test:

```jsx
test("handles failed login", async () => {
  const mockLogin = jest.fn().mockRejectedValueOnce(new Error());

  render(<Login loginAPI={mockLogin} />);

  await userEvent.type(screen.getByPlaceholderText("Email"), "tanish@mail.com");
  await userEvent.type(screen.getByPlaceholderText("Password"), "wrongpass");

  await userEvent.click(screen.getByRole("button", { name: /login/i }));

  expect(await screen.findByRole("alert"))
    .toHaveTextContent("Invalid credentials");
});
```

This simulates a real-world login flow.

---

# 12. Follow-up Questions

1. Do your forms have client-side validation that needs testing?
2. Are you testing UI behavior instead of form implementation details?
3. Which form fields require async testing (API responses)?
4. Do your forms disable buttons based on validation rules?
5. How do you test backend error feedback in forms?
6. Do your forms need success message or redirect tests?
7. Are you mocking API calls consistently for all form tests?
8. Do you have multi-field forms requiring combined submission tests?
9. Should some form tests use MSW instead of jest.mock for realism?
10. How do you ensure that tests cover all validation branches?
