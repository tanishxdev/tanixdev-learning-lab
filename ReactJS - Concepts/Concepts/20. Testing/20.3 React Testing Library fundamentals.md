# **20.3 React Testing Library Fundamentals**

A complete, production-grade explanation of **how React Testing Library (RTL)** works, why it is used instead of Enzyme or manual DOM testing, what its philosophy is, how to render components, how to query elements correctly, and how user-event simulation works in real tests.

---

# 1. What Is React Testing Library?

React Testing Library (RTL) is a lightweight library that helps you test React components by focusing on **user interactions and visible behavior**, not component internals.

Its core goal:

```
Test what the user sees, not what the component implements.
```

RTL replaces older tools like Enzyme by promoting best practices:

* Test via DOM
* Interact as a user would
* Avoid implementation details
* Prefer real rendering over shallow rendering

RTL is the standard testing tool for React in modern projects.

---

# 2. Why RTL Over Enzyme or Manual DOM Testing?

## Reason 1: RTL encourages user-focused testing

Users do not interact with:

* component state
* props directly
* hook internals

Users interact with:

* text
* buttons
* forms
* UI elements

RTL tests these exactly.

---

## Reason 2: No shallow rendering

Shallow rendering hides child components.
RTL renders fully, ensuring realistic behavior.

---

## Reason 3: Queries mimic accessibility behaviors

RTL uses queries similar to how screen readers detect content:

* `getByRole`
* `getByLabelText`
* `getByText`
* `getByPlaceholderText`

This leads to more accessible UI.

---

## Reason 4: Clean, simple API

Rendering requires one function:

```jsx
render(<MyComponent />);
```

Queries come from:

```jsx
screen.getByRole(...)
```

Assertions come from Jest.

---

# 3. The Core Philosophy of RTL

RTL follows three principles:

## Principle 1: Avoid implementation details

Tests should not depend on:

* component internals
* useState/useEffect usage
* specific DOM structure

These can change without affecting functionality.

---

## Principle 2: Test from the user's perspective

The question is:

"Can the user do this action and see the expected result?"

Not:

"Does this component have a div with id='x'?"

---

## Principle 3: Make tests future-proof

Implementation changes should not break tests unless behavior changes.

---

# 4. Setting Up RTL in a React Project

Most setups already include RTL via:

* Create React App
* Vite + RTL plugins
* Next.js custom config

Imports you typically use:

```jsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
```

---

# 5. Rendering a Component

Example component:

```jsx
function Greeting({ name }) {
  return <h1>Hello {name}</h1>;
}
```

Test:

```jsx
test("renders greeting", () => {
  render(<Greeting name="Tanish" />);
  expect(screen.getByText("Hello Tanish")).toBeInTheDocument();
});
```

`render` creates a virtual DOM rooted in JSDOM.

`screen` provides access to the rendered DOM.

`expect(...).toBeInTheDocument()` comes from jest-dom.

---

# 6. Query Types in RTL

RTL exposes multiple query patterns.
You should know which to use and when.

## Priority Order (Recommended by RTL)

### 1. getByRole

Most accessible and reliable.

Example:

```jsx
screen.getByRole("button", { name: /submit/i });
```

### 2. getByLabelText

Used for form controls.

```jsx
screen.getByLabelText(/email/i);
```

### 3. getByPlaceholderText

Used when no label exists.

### 4. getByText

Used for paragraphs, headings, etc.

### 5. getByTestId

Use only as a last resort.

---

# 7. The getBy / queryBy / findBy Patterns

### getBy

Throws an error if not found.
Use for elements that must exist.

### queryBy

Returns null if not found.
Use for checking absence.

### findBy

Returns a promise.
Used for async waits (API, loading states).

Example:

```jsx
const item = await screen.findByText("Loaded");
```

---

# 8. Simulating User Interactions with userEvent

RTL recommends `userEvent` instead of fireEvent because it simulates **real-world behavior**.

Examples:

## Typing

```jsx
await userEvent.type(screen.getByRole("textbox"), "hello");
```

## Clicking

```jsx
await userEvent.click(screen.getByRole("button"));
```

## Selecting

```jsx
await userEvent.selectOptions(screen.getByRole("combobox"), "option1");
```

---

# 9. Example: Testing a Counter Component

Component:

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>Increase</button>
    </>
  );
}
```

Test:

```jsx
test("counter increments", async () => {
  render(<Counter />);

  const button = screen.getByRole("button", { name: /increase/i });

  await userEvent.click(button);

  expect(screen.getByText("Count: 1")).toBeInTheDocument();
});
```

Key idea:
User interacts with the UI as a real user would.

---

# 10. Testing Forms

Component:

```jsx
function Login() {
  const [value, setValue] = useState("");

  return (
    <form>
      <label htmlFor="email">Email</label>
      <input
        id="email"
        value={value}
        onChange={e => setValue(e.target.value)}
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

Test:

```jsx
test("user types email", async () => {
  render(<Login />);

  await userEvent.type(screen.getByLabelText(/email/i), "test@mail.com");

  expect(screen.getByDisplayValue("test@mail.com")).toBeInTheDocument();
});
```

RTL helps test input interactions precisely.

---

# 11. Testing Conditional UI

Component:

```jsx
function Toggle() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(s => !s)}>Toggle</button>
      {show && <p>Visible</p>}
    </>
  );
}
```

Test:

```jsx
test("toggles visibility", async () => {
  render(<Toggle />);

  const button = screen.getByRole("button", { name: /toggle/i });

  expect(screen.queryByText("Visible")).toBeNull();

  await userEvent.click(button);

  expect(screen.getByText("Visible")).toBeInTheDocument();
});
```

---

# 12. Testing Async State (API-like behavior)

Component simulating async fetch:

```jsx
function DataLoader() {
  const [data, setData] = useState(null);

  useEffect(() => {
    setTimeout(() => setData("Loaded"), 500);
  }, []);

  return <div>{data || "Loading..."}</div>;
}
```

Test:

```jsx
test("waits for async load", async () => {
  render(<DataLoader />);

  expect(screen.getByText("Loading...")).toBeInTheDocument();

  expect(await screen.findByText("Loaded")).toBeInTheDocument();
});
```

`findBy` waits automatically for async UI updates.

---

# 13. Cleanup and Test Environment Reset

RTL automatically cleans up after each test:

* DOM removed
* event listeners removed
* component unmounted

This prevents cross-test pollution.

---

# 14. What RTL Should Not Test

Avoid testing:

* CSS
* DOM structure specifics (unless required)
* internal state
* implementation details
* React internals

Focus on:

* what user sees
* what user does
* what UI does in response

---

# 15. Follow-up Questions

1. Do you consistently use getByRole instead of less accessible queries?
2. Which components in your app can be tested purely through user interactions?
3. Do your components rely too heavily on test IDs? Can they be replaced with accessible queries?
4. Are you using userEvent for all interactive tests?
5. Which parts of your UI require async testing with findBy queries?
6. Do your components return the same DOM structure regardless of internal refactoring?
7. Are your tests verifying behavior or implementation details?
8. How do you organize your tests in your project structure?
9. Do you use describe blocks to group related tests?
10. Are you writing tests that mimic real user workflows?
