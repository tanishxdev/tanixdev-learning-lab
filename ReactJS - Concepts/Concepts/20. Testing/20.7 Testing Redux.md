# **20.7 Testing Redux**

A complete, production-grade explanation of **how to test Redux logic and Redux-connected React components**, including reducers, actions, slices (Redux Toolkit), store interactions, connected components, async thunks, API mocking, selector testing, and React Testing Library integration.

Redux testing splits into two major parts:

1. **Testing Redux logic (pure functions → reducers, selectors, slices)**
2. **Testing UI that uses Redux state (React Testing Library + Provider)**

This chapter covers both completely.

---

# 1. What Does It Mean to Test Redux?

Testing Redux means verifying:

* reducers update state correctly
* actions produce the correct payloads
* slices behave correctly
* thunks handle success/failure correctly
* UI components read/write Redux state correctly
* async flows dispatch correct actions

Redux is predictable because reducers are **pure functions** → easy to test.

---

# 2. Testing Reducers (Most Important)

Reducer example:

```js
const initialState = { count: 0 };

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    default:
      return state;
  }
}
```

Test:

```js
test("increments count", () => {
  const newState = counterReducer({ count: 0 }, { type: "increment" });
  expect(newState.count).toBe(1);
});
```

Reducer tests:

* have no side effects
* require no mocking
* run extremely fast
* provide huge confidence

Reducer tests are the foundation of Redux testing.

---

# 3. Testing Redux Toolkit Slice Reducers

Slice:

```js
const counterSlice = createSlice({
  name: "counter",
  initialState: { count: 0 },
  reducers: {
    increment(state) {
      state.count++;
    },
    add(state, action) {
      state.count += action.payload;
    }
  }
});

export const { increment, add } = counterSlice.actions;
export default counterSlice.reducer;
```

Test:

```js
import reducer, { increment, add } from "./counterSlice";

test("increments count", () => {
  const state = reducer({ count: 0 }, increment());
  expect(state.count).toBe(1);
});

test("adds payload", () => {
  const state = reducer({ count: 0 }, add(5));
  expect(state.count).toBe(5);
});
```

Key point:
Even though slices use Immer internally, you test only the resultant state.

---

# 4. Testing Selectors

Selector:

```js
export const selectCount = (state) => state.counter.count;
```

Test:

```js
test("selects count", () => {
  const state = { counter: { count: 10 } };
  expect(selectCount(state)).toBe(10);
});
```

Selectors must:

* never mutate
* be pure
* be easy to test

---

# 5. Testing Async Thunks (Redux Toolkit createAsyncThunk)

Thunk:

```js
export const fetchUser = createAsyncThunk(
  "user/fetch",
  async () => {
    const res = await api.get("/user");
    return res.data;
  }
);
```

Slice:

```js
const userSlice = createSlice({
  name: "user",
  initialState: { data: null, status: "idle" },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.status = "success";
        state.data = action.payload;
      })
      .addCase(fetchUser.rejected, (state) => {
        state.status = "error";
      });
  }
});
```

Mock API:

```js
jest.mock("../api");
import api from "../api";
```

Test success:

```js
test("fetchUser fulfilled", async () => {
  api.get.mockResolvedValue({ data: { id: 1 } });

  const dispatch = jest.fn();
  const thunk = fetchUser();

  await thunk(dispatch, () => {}, undefined);

  expect(dispatch.mock.calls[0][0].type).toBe("user/fetch/pending");
  expect(dispatch.mock.calls[1][0].type).toBe("user/fetch/fulfilled");
});
```

Test error:

```js
test("fetchUser rejected", async () => {
  api.get.mockRejectedValue(new Error());

  const dispatch = jest.fn();
  const thunk = fetchUser();

  await thunk(dispatch, () => {}, undefined);

  expect(dispatch.mock.calls[1][0].type).toBe("user/fetch/rejected");
});
```

Thunks require mocking the API, but reducer behavior is still pure.

---

# 6. Testing React Components That Use Redux

A component:

```jsx
function Counter() {
  const count = useSelector(state => state.counter.count);
  const dispatch = useDispatch();

  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>Add</button>
    </>
  );
}
```

To test it, wrap it with Provider + store:

```jsx
import { Provider } from "react-redux";
import { configureStore } from "@reduxjs/toolkit";

function renderWithStore(ui, { preloadedState, reducer }) {
  const store = configureStore({
    reducer,
    preloadedState
  });
  return render(<Provider store={store}>{ui}</Provider>);
}
```

Test:

```jsx
test("increments from UI", async () => {
  renderWithStore(<Counter />, {
    reducer: { counter: reducer },
    preloadedState: { counter: { count: 0 } }
  });

  await userEvent.click(screen.getByRole("button", { name: /add/i }));

  expect(screen.getByText("Count: 1")).toBeInTheDocument();
});
```

Component-level Redux tests verify:

* selector reading
* dispatching actions
* updating DOM

---

# 7. Testing Redux with React Query (Hybrid Apps)

If app uses Redux for UI state and React Query for server state:

* Redux tests verify UI logic
* React Query tests verify caching + fetching

Example: a component dispatches UI selections and fetches remote data.

Mock both:

* Redux store
* axios

Then assert DOM behavior.

---

# 8. Testing Redux Middleware

Example logger middleware:

```js
const logger = store => next => action => {
  console.log("action:", action);
  return next(action);
};
```

Test:

```js
test("logger calls console.log", () => {
  console.log = jest.fn();

  const next = jest.fn();
  const action = { type: "test" };

  logger()(next)(action);

  expect(console.log).toHaveBeenCalledWith("action:", action);
});
```

Middleware tests ensure side effects behave correctly.

---

# 9. Testing Normalized EntityAdapter Logic

Slice:

```js
const usersAdapter = createEntityAdapter();

const usersSlice = createSlice({
  name: "users",
  initialState: usersAdapter.getInitialState(),
  reducers: {
    setUsers: usersAdapter.setAll,
    addUser: usersAdapter.addOne
  }
});
```

Test:

```js
test("adds user", () => {
  const state = usersSlice.reducer(
    usersAdapter.getInitialState(),
    usersSlice.actions.addUser({ id: 1, name: "A" })
  );

  expect(state.ids).toContain(1);
  expect(state.entities[1].name).toBe("A");
});
```

EntityAdapter logic must always be tested at reducer-level.

---

# 10. Common Anti-Patterns

Avoid:

1. Testing Redux by looking at state values in UI tests
2. Mocking Redux hooks manually
3. Using shallow rendering (not compatible with RTL philosophy)
4. Testing implementation details inside selector logic
5. Skipping reducer tests and relying only on component tests
6. Over-mocking store instead of using a real configured store

Redux is predictable; test it cleanly.

---

# 11. Real Production Example: Testing a Todo Slice + Component

Slice:

```js
const todoSlice = createSlice({
  name: "todos",
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push(action.payload);
    }
  }
});

export const { addTodo } = todoSlice.actions;
export default todoSlice.reducer;
```

Component:

```jsx
function TodoApp() {
  const todos = useSelector(state => state.todos);
  const dispatch = useDispatch();

  return (
    <>
      <button onClick={() => dispatch(addTodo("Buy milk"))}>Add</button>
      {todos.map((t, i) => (
        <p key={i}>{t}</p>
      ))}
    </>
  );
}
```

Test:

```jsx
test("adds todo from UI", async () => {
  renderWithStore(<TodoApp />, {
    reducer: { todos: reducer },
    preloadedState: { todos: [] }
  });

  await userEvent.click(screen.getByRole("button", { name: /add/i }));

  expect(screen.getByText("Buy milk")).toBeInTheDocument();
});
```

This verifies:

* dispatch working
* reducer updating state
* UI rendering updated state

---

# 12. Follow-up Questions

1. Are your Redux slices fully covered with reducer tests?
2. Do you mock async thunks or test them through Redux Toolkit's dispatch flow?
3. Have you created a reusable `renderWithStore` helper?
4. Are you testing UI behavior instead of Redux internals?
5. Which Redux selectors should be isolated and tested separately?
6. Does your app mix Redux with React Query? Should boundaries be clarified in tests?
7. Are async API calls mocked correctly for thunks?
8. Do your components rely too much on Redux for local UI state?
9. Should some states be moved from Redux to component state for simpler testing?
10. Are error and loading states in thunks being tested separately?
