# **20.4 Testing Components**

A complete, production-grade explanation of **how to test React components** using React Testing Library + Jest, including patterns for simple components, dynamic rendering, events, props, controlled inputs, async behavior, conditional UI, and component composition.

This chapter builds directly on 20.3 and prepares you for testing larger UI systems.

---

# 1. What Does “Testing Components” Mean?

Testing a component means verifying:

* what it renders
* how it behaves based on props
* how it responds to user interactions
* how it updates the DOM
* how it handles async data
* how it shows/hides elements

Component tests DO NOT check:

* internal state values
* hook usage
* implementation details

You test only what the **user can observe**.

---

# 2. The Structure of a Component Test

A typical component test has four steps:

1. **Render** the component
2. **Query** the elements
3. **Interact** with the UI (optional)
4. **Assert** visible changes

Example structure:

```jsx
render(<Component />);

const element = screen.getByRole("button");

await userEvent.click(element);

expect(screen.getByText("Updated")).toBeInTheDocument();
```

This flow mirrors how a real user interacts.

---

# 3. Testing Components That Render Static UI

Example component:

```jsx
function Header() {
  return <h1>Welcome to the App</h1>;
}
```

Test:

```jsx
test("renders header text", () => {
  render(<Header />);
  expect(screen.getByRole("heading", { name: /welcome to the app/i }))
    .toBeInTheDocument();
});
```

Key ideas:

* Use `getByRole("heading")` instead of `getByText()` when possible
* Do not match the exact text unless necessary

---

# 4. Testing Props-Based Components

Component:

```jsx
function Greeting({ name }) {
  return <p>Hello {name}</p>;
}
```

Test:

```jsx
test("renders greeting with name", () => {
  render(<Greeting name="Tanish" />);
  expect(screen.getByText("Hello Tanish")).toBeInTheDocument();
});
```

Props should always be tested by their **effect on UI**, not internal logic.

---

# 5. Testing Components With Events

Component:

```jsx
function Toggle() {
  const [open, setOpen] = useState(false);
  return (
    <>
      <button onClick={() => setOpen(o => !o)}>Toggle</button>
      {open && <span>Open</span>}
    </>
  );
}
```

Test:

```jsx
test("toggles open state", async () => {
  render(<Toggle />);

  const button = screen.getByRole("button", { name: /toggle/i });

  expect(screen.queryByText("Open")).toBeNull();

  await userEvent.click(button);

  expect(screen.getByText("Open")).toBeInTheDocument();
});
```

Testing user interaction = behavior testing.

---

# 6. Testing Controlled Inputs

Component:

```jsx
function InputBox() {
  const [text, setText] = useState("");

  return (
    <>
      <label htmlFor="msg">Message</label>
      <input id="msg" value={text} onChange={e => setText(e.target.value)} />
      <p>{text}</p>
    </>
  );
}
```

Test:

```jsx
test("updates text when user types", async () => {
  render(<InputBox />);

  const input = screen.getByLabelText(/message/i);

  await userEvent.type(input, "hello");

  expect(screen.getByText("hello")).toBeInTheDocument();
});
```

You test:

* label association
* user typing
* UI update

Never test internal state.

---

# 7. Testing Conditional Rendering

Component:

```jsx
function Status({ loading }) {
  if (loading) return <p>Loading...</p>;
  return <p>Loaded</p>;
}
```

Test:

```jsx
test("shows loading", () => {
  render(<Status loading={true} />);
  expect(screen.getByText("Loading...")).toBeInTheDocument();
});

test("shows loaded", () => {
  render(<Status loading={false} />);
  expect(screen.getByText("Loaded")).toBeInTheDocument();
});
```

Always test both branches.

---

# 8. Testing Async Components (useEffect, API-like flows)

Component:

```jsx
function FetchData() {
  const [data, setData] = useState(null);

  useEffect(() => {
    setTimeout(() => setData("Done"), 500);
  }, []);

  return <div>{data || "Loading"}</div>;
}
```

Test:

```jsx
test("loads data asynchronously", async () => {
  render(<FetchData />);

  expect(screen.getByText("Loading")).toBeInTheDocument();

  expect(await screen.findByText("Done")).toBeInTheDocument();
});
```

Key idea:

* `findBy` automatically waits for async updates.

---

# 9. Testing Components That Use Child Components

Parent component:

```jsx
function Parent() {
  return (
    <>
      <h1>Dashboard</h1>
      <Child />
    </>
  );
}

function Child() {
  return <p>Child Loaded</p>;
}
```

Test:

```jsx
test("renders parent and child", () => {
  render(<Parent />);

  expect(screen.getByRole("heading", { name: /dashboard/i })).toBeInTheDocument();
  expect(screen.getByText("Child Loaded")).toBeInTheDocument();
});
```

RTL renders full DOM, so child components appear naturally.

---

# 10. Testing Callback Props

Component:

```jsx
function Button({ onClick }) {
  return <button onClick={onClick}>Click</button>;
}
```

Test:

```jsx
test("calls callback on click", async () => {
  const mockFn = jest.fn();

  render(<Button onClick={mockFn} />);

  await userEvent.click(screen.getByRole("button"));

  expect(mockFn).toHaveBeenCalledTimes(1);
});
```

Callback tests ensure:

* correct event triggers
* correct number of calls
* correct arguments passed

---

# 11. Testing Components with Lists

Component:

```jsx
function List({ items }) {
  return items.map(i => <li key={i}>{i}</li>);
}
```

Test:

```jsx
test("renders list items", () => {
  render(<List items={["a", "b", "c"]} />);
  expect(screen.getByText("a")).toBeInTheDocument();
  expect(screen.getByText("b")).toBeInTheDocument();
  expect(screen.getByText("c")).toBeInTheDocument();
});
```

Test visible list output, not how it's rendered internally.

---

# 12. Testing Error UI

Component:

```jsx
function ErrorMessage({ message }) {
  return <div role="alert">{message}</div>;
}
```

Test:

```jsx
test("shows error message", () => {
  render(<ErrorMessage message="Invalid input" />);
  expect(screen.getByRole("alert")).toHaveTextContent("Invalid input");
});
```

Use semantic roles to improve reliability.

---

# 13. Common Anti-Patterns

Avoid:

1. Testing state variables directly
2. Testing implementation details (class names, DOM structure)
3. Using `getByTestId` unnecessarily
4. Using `fireEvent` instead of `userEvent`
5. Mocking too many internals

Tests must focus on user-visible behavior.

---

# 14. Real Production Example: Testing a Search Box

Component:

```jsx
function Search({ onSearch }) {
  const [term, setTerm] = useState("");

  return (
    <>
      <input
        placeholder="Search"
        value={term}
        onChange={e => setTerm(e.target.value)}
      />
      <button onClick={() => onSearch(term)}>Go</button>
    </>
  );
}
```

Test:

```jsx
test("searches with correct term", async () => {
  const mockSearch = jest.fn();

  render(<Search onSearch={mockSearch} />);

  const input = screen.getByPlaceholderText("Search");
  const button = screen.getByRole("button", { name: /go/i });

  await userEvent.type(input, "react testing");
  await userEvent.click(button);

  expect(mockSearch).toHaveBeenCalledWith("react testing");
});
```

This verifies:

* interactions
* controlled input updates
* callback correctness

---

# 15. Follow-up Questions

1. Are you testing components through their rendered DOM, not internal details?
2. Do you consistently use userEvent for interactions?
3. Which components in your app need conditional rendering tests?
4. How do your components handle async behavior, and do tests reflect it?
5. Are callback props tested for correct arguments and call count?
6. Do you always test both branches of conditionals?
7. Are list outputs tested by checking visible items?
8. Does your project include components that need separate error-state UI tests?
9. Are your components too tightly coupled for easy testing?
10. Can you reorganize your component code to make tests simpler and clearer?
