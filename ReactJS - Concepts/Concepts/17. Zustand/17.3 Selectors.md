# 17.3 Selectors (Zustand)

A full, deep, practical explanation of **what selectors are**, **why they matter**, **how to write them correctly**, and **how they give Zustand its high performance**.

---

# 1. Why Selectors?

### The core problem

If you read Zustand state like this:

```jsx
const state = useStore();
```

You subscribe the component to **the entire store**.

This causes:

* Unnecessary re-renders
* Performance issues
* UI flickering
* All parts of the store updating cause component updates

Example:

```jsx
const state = useStore();   // BAD
```

If anything in the store changes (cart, theme, modal),
**this component re-renders** — even if it doesn’t use that value.

This is the exact same issue React Context has.

### Selectors solve this.

---

# 2. What is a Selector?

A selector is a function that picks the **exact piece of state** your component needs:

```jsx
const count = useStore((state) => state.count);
```

This means:

* Component subscribes **only** to `count`
* Component re-renders **only** when `count` changes

Nothing else affects it.

Selectors provide:

* Fine-grained subscriptions
* High performance
* Component-level precision
* Avoid unnecessary renders

---

# 3. When to use Selectors?

**Always.**

Use a selector every single time you read Zustand state.

Selectors are required for:

* Performance
* Scalability
* Clean code
* Avoiding global re-renders

Example:

```jsx
useStore((s) => s.theme);
useStore((s) => s.user);
useStore((s) => s.cart.length);
useStore((s) => s.filters);
```

Never use:

```jsx
useStore(); // BAD
```

---

# 4. Analogy

Think of Zustand as a supermarket.

### Selector = picking only what you need (one product)

Fast, efficient, minimal movement.

### No selector = buying the entire supermarket

Slow, expensive, and totally unnecessary.

---

# 5. How Selectors Work Internally

When you do:

```jsx
useStore((state) => state.count);
```

Zustand:

1. Evaluates selector → state.count
2. Subscribes component to only that value
3. When set() runs:

   * Zustand computes the new state
   * Checks if `count` changed (shallow compare)
   * If yes → re-render
   * If no → no re-render

Other fields changing do NOT affect this component.

That is why Zustand is extremely performant.

---

# 6. Developer Mindset Thinking

Before reading state, ask:

1. What EXACT piece does this component need?
2. Is this derived or raw data?
3. Should the component update on every store change?
4. How small can my subscription be?

Think precision, not convenience.

---

# 7. Simple Store with Selectors

## store.js

```jsx
import { create } from "zustand";

export const useUserStore = create((set) => ({
  name: "Tanish",
  age: 20,
  incrementAge: () => set((s) => ({ age: s.age + 1 }))
}));
```

## Component using selectors

```jsx
export default function Profile() {
  const name = useUserStore((s) => s.name);
  const age = useUserStore((s) => s.age);

  return (
    <div>
      <p>Name: {name}</p>
      <p>Age: {age}</p>
    </div>
  );
}
```

---

# 8. Dry Run

1. Component reads `name` → subscribed
2. Component reads `age` → subscribed

If `incrementAge()` runs:

* age changes
* name does NOT change
* Component re-renders but only the part subscribed to `age` triggers updates

If another store field changes (e.g., theme),
**this component does not re-render**.

---

# 9. Example: Mapping multiple fields (object selector)

```jsx
const { name, age } = useUserStore((s) => ({
  name: s.name,
  age: s.age
}));
```

Important note:
This re-renders only when **name or age** change.

Zustand does shallow compare of the object.

---

# 10. Selector Best Practices

### 1. Always use selectors

Always subscribe to specific fields.

### 2. Derive values inside selectors

```jsx
useCartStore((s) => s.items.length);
```

Rather than returning the whole array:

```jsx
useCartStore((s) => s.items); // triggers more rerenders
```

### 3. Keep selectors pure

No async calls. No side effects.

### 4. Use multiple selectors inside one component (fine-grained)

```jsx
const open = useUIStore((s) => s.open);
const toggle = useUIStore((s) => s.toggle);
```

---

# 11. When NOT to Use Object Selectors

Avoid:

```jsx
useStore((s) => ({ a: s.a, b: s.b }));
```

If the object is recreated every render (due to new reference),
it may cause re-renders.

Use separate selectors if needed.

---

# 12. Advanced: Using shallow for object selectors

Zustand allows shallow comparison:

```jsx
import { shallow } from "zustand/shallow";

const { a, b } = useStore((s) => ({ a: s.a, b: s.b }), shallow);
```

This prevents re-renders unless a or b truly changed.

---

# 13. Advanced: Selector for derived state

```jsx
const total = useCartStore((s) =>
  s.items.reduce((sum, item) => sum + item.price, 0)
);
```

Computes only when needed.

---

# 14. Common Mistakes

1. Using `useStore()` without selector
   → Component re-renders for every state change

2. Selecting entire slice
   → Reduces performance

3. Using selectors with side effects
   → Wrong and unsafe

4. Returning new objects every time
   → Causes rerenders
   Example bad:

   ```jsx
   useStore((s) => ({ count: s.count })); // new object each time
   ```

5. Storing derived values in store instead of selectors
   → Causes unnecessary recomputations in store

---

# 15. Best Practices Summary

1. Always use selectors
2. Subscribe to minimal amount of state
3. Use shallow comparison when selecting multiple fields
4. Use derived selectors only when needed
5. Avoid whole-store subscriptions
6. Keep selectors pure
7. Store raw data, derive computed data

---

# 16. Comparison: Zustand Selectors vs Redux Selectors

| Feature      | Zustand                        | Redux                    |
| ------------ | ------------------------------ | ------------------------ |
| Required?    | Yes                            | Optional                 |
| Re-renders   | Very fine-grained              | Slice-based              |
| Memoization  | No (but shallow compare helps) | createSelector available |
| Setup        | Simple                         | More structured          |
| Subscription | Per-selector                   | Per-useSelector          |
| Performance  | Excellent                      | Excellent                |

Both systems use selectors for performance.

---

# 17. Follow-up Questions

1. Why do selectors prevent unnecessary re-renders?
2. When should you use shallow comparison?
3. Why should you avoid selecting entire store state?
4. What happens if a selector returns a new object each time?
5. Why should derived values be computed inside selectors?
6. What is the difference between Zustand and Redux selectors?
7. When should you split a store to avoid selector complexity?
8. How does Zustand know when to re-render a component?
9. Why should selectors not contain side effects?
10. How does Zustand’s subscription system differ from React Context?

---