# 17.2 Creating Stores (Zustand)

A complete, structured, dev-mindset explanation of how to **create and organize Zustand stores**, how they work internally, and how to avoid common mistakes.

---

# 1. Why "Creating Stores" matters?

The biggest confusion beginners have with Zustand:

* How many stores should I make?
* How to organize store logic?
* How to split UI state vs global state?
* How to structure actions and derived values?
* Should a store behave like Redux or like useState?

Understanding **store creation** gives clarity for:

* Scalability
* Maintainability
* Performance
* Predictable structure

---

# 2. What is a Zustand Store?

A Zustand store is:

* A **central place** for global state
* A hook that provides state + actions
* A subscription system without React Context
* A simple object with:
  – state
  – actions
  – sometimes derived values

Example mental model:

```
useStore = create(storeDefinition)
```

You call `useStore` inside components to access values.

---

# 3. When to Create a Store?

You should create a Zustand store when:

1. Multiple components need the same state
2. Updating the state should not cause global re-render
3. The state doesn’t need Redux architecture
4. You want simple global UI state (modal, theme, filters)
5. You want a global store with minimal API
6. You need fine-grained subscription for fast updates

Do NOT create a store when:

* State belongs only to one component
* State is server data (use React Query or RTK Query)
* You need Redux-level structure

---

# 4. Analogy for Easy Understanding

Think of Zustand like a **locker with keys**.

* Locker contains values (state)
* Keys open specific drawers (selectors)
* You only get the item you need — not the whole locker
* Others accessing the locker do not disturb your work

This is why Zustand prevents unnecessary re-renders.

---

# 5. How Zustand Creates a Store Internally

When you write:

```jsx
const useStore = create((set, get) => ({
  count: 0,
  increment: () => set({ count: get().count + 1 })
}));
```

Internally Zustand:

1. Creates a global store object
2. Stores values in a centralized state
3. Provides `set()` → modify state
4. Provides `get()` → read state
5. Maps each component selector → subscription
6. Only re-renders components whose selected values change

React Context is **not used**.

---

# 6. Simple Store Creation Example

## store.js

```jsx
import { create } from "zustand";

export const useCounterStore = create((set, get) => ({
  count: 0,

  increment: () =>
    set((state) => ({ count: state.count + 1 })),

  decrement: () =>
    set((state) => ({ count: state.count - 1 })),

  reset: () =>
    set({ count: 0 })
}));
```

## Component

```jsx
import { useCounterStore } from "./store";

export default function Counter() {
  const count = useCounterStore((s) => s.count);
  const increment = useCounterStore((s) => s.increment);

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}
```

---

# 7. Dry Run

1. Component subscribes to `state.count`
2. User clicks increment
3. set() updates state
4. Zustand compares new value vs previous
5. Only components reading `count` re-render
6. Components subscribed to other state do not re-render

Granular reactivity = fast UI.

---

# 8. Pattern: UI / UX Store (Modal Example)

Perfect example where Zustand shines.

### modalStore.js

```jsx
import { create } from "zustand";

export const useModalStore = create((set) => ({
  isOpen: false,
  toggle: () => set((s) => ({ isOpen: !s.isOpen }))
}));
```

### Component

```jsx
const { isOpen, toggle } = useModalStore((s) => ({
  isOpen: s.isOpen,
  toggle: s.toggle
}));
```

No Redux.
No Context.
No prop drilling.

---

# 9. Pattern: Business Logic Store (Cart Example)

### cartStore.js

```jsx
export const useCartStore = create((set, get) => ({
  items: [],

  addItem: (item) =>
    set((s) => ({ items: [...s.items, item] })),

  removeItem: (id) =>
    set((s) => ({
      items: s.items.filter((item) => item.id !== id)
    })),

  totalPrice: () =>
    get().items.reduce((sum, item) => sum + item.price, 0)
}));
```

Important:
Pure business logic, no UI.

---

# 10. Pattern: Split Stores (Scalable)

Recommended folder structure:

```
src/
 └── stores/
      ├── uiStore.js
      ├── cartStore.js
      ├── authStore.js
      ├── filterStore.js
```

Each store represents **one domain**, similar to Redux slices.

---

# 11. Pattern: One Big Store (Not Recommended)

```jsx
export const useStore = create((set) => ({
  count: 0,
  modalOpen: false,
  theme: "light",
  user: null,
  products: []
}));
```

Problems:

* Hard to scale
* Hard to maintain
* All logic gets mixed
* Not feature-driven

Only ok for small hobby projects.

---

# 12. Best Practice: Group by Domain (Redux-style)

Example:

### authStore.js

```jsx
export const useAuthStore = create((set) => ({
  user: null,

  login: (user) => set({ user }),
  logout: () => set({ user: null })
}));
```

### themeStore.js

```jsx
export const useThemeStore = create((set) => ({
  theme: "light",
  toggleTheme: () =>
    set((s) => ({
      theme: s.theme === "light" ? "dark" : "light"
    }))
}));
```

Cleaner, scalable.

---

# 13. Common Mistakes

1. Creating stores inside components
   → Breaks Zustand behavior
2. Accessing entire state without a selector
   → Causes unnecessary re-renders
3. Mixing unrelated logic in one store
4. Writing deeply nested structures
5. Using Zustand for server cache (bad use-case)
6. Forgetting that Zustand stores survive reloads only with persist middleware
7. Using props + Zustand wrongly (duplicate data sources)

---

# 14. Best Practices

1. One store per domain (auth, cart, UI, filters)
2. Always use selectors `(state) => state.field`
3. Keep actions simple
4. Keep state flat
5. Use middleware (persist, devtools, immer) when needed
6. Pull business logic out of components
7. Use React Query/RTK Query for API data, not Zustand

---

# 15. Comparison: Zustand Store vs Redux Slice

| Concept        | Zustand                  | Redux Toolkit              |
| -------------- | ------------------------ | -------------------------- |
| Setup          | Very simple              | Structured                 |
| Actions        | Inline functions         | Reducers + action creators |
| Async          | use async inside actions | createAsyncThunk           |
| Re-renders     | Fine-grained             | Selector-based             |
| Boilerplate    | None                     | Moderate                   |
| Architecture   | Flexible                 | Opinionated                |
| UI State       | Excellent                | Overkill                   |
| Business Logic | Good                     | Excellent                  |
| Team Size      | Small/Medium             | Any                        |

Zustand stores = high flexibility, minimal rules.
Redux slices = strict, predictable.

---

# 16. Follow-up Questions

1. How does Zustand store avoid Context-level re-renders?
2. When should you split Zustand stores?
3. Why should you always use selectors in Zustand?
4. What happens if a store is created inside a component?
5. Why is Zustand ideal for UI-level global state?
6. When should you NOT store API responses in Zustand?
7. How do set and get differ in Zustand store?
8. Why avoid deeply nested store structures?
9. When to choose Redux instead of Zustand for store creation?
10. Which middleware improves Zustand's persist/resilience?

