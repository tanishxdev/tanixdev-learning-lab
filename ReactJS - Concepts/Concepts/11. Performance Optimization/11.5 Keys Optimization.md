
# 11.4 useMemo Optimization

useMemo is used to memoize **values** (objects, arrays, expensive calculations).
Whereas useCallback memoizes **functions**, useMemo memoizes **non-function data** to prevent unnecessary recalculations or re-renders.

This is one of the most powerful optimizations in React when used correctly.

We will go step-by-step.

---

# 1. What is useMemo?

useMemo Memoizes a value.

Example:

```jsx
const memoizedValue = useMemo(() => expensiveCalculation(), []);
```

React remembers and returns the same value unless dependencies change.

---

# 2. Why useMemo is needed?

React re-renders components often.
During each render:

* Functions are recreated
* Objects/arrays are recreated
* Expensive calculations re-run

This can:

* Slow down your app
* Cause unnecessary re-renders in memoized children
* Trigger deep comparisons repeatedly

useMemo solves these issues.

---

# 3. When to use useMemo?

Use useMemo when:

1. A value is expensive to compute
2. A value is passed as a prop to a memoized child
3. An object/array changes every render but should stay stable
4. You want to prevent child re-renders caused by prop identity changes

---

# 4. When NOT to use useMemo

Avoid useMemo when:

1. Value is cheap to compute
2. You are not passing the value to memoized components
3. Dependencies change on every render
4. You are prematurely optimizing

useMemo adds overhead.
If not needed, it harms performance.

---

# 5. Expensive Calculation Example

Create file:

`RenderMemoValue1_NoMemo.jsx`

```jsx
import { useState } from "react";

function slowFunction(num) {
  console.log("Running slow function");
  for (let i = 0; i < 1000000000; i++) {}
  return num * 2;
}

export default function RenderMemoValue1_NoMemo() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  const result = slowFunction(count);

  return (
    <div>
      <h3>No useMemo (slow)</h3>
      <p>Result: {result}</p>

      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>

      <input
        placeholder="type here"
        value={text}
        onChange={e => setText(e.target.value)}
      />
    </div>
  );
}
```

Problem:

* Typing in input becomes laggy
* Because `slowFunction` runs on every re-render

---

# With useMemo (Optimized)

Create file:

`RenderMemoValue2_WithMemo.jsx`

```jsx
import { useState, useMemo } from "react";

function slowFunction(num) {
  console.log("Running slow function");
  for (let i = 0; i < 1000000000; i++) {}
  return num * 2;
}

export default function RenderMemoValue2_WithMemo() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  const result = useMemo(() => slowFunction(count), [count]);

  return (
    <div>
      <h3>With useMemo (fast)</h3>
      <p>Result: {result}</p>

      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>

      <input
        placeholder="type here"
        value={text}
        onChange={e => setText(e.target.value)}
      />
    </div>
  );
}
```

Now:

* slowFunction runs only when count changes
* Typing becomes smooth
* Performance improves dramatically

---

# 6. Storing Objects/Arrays with useMemo

This is the second major reason to use useMemo.

React memoization tools (React.memo) compare props shallowly.

So:

```jsx
<Child data={{ name: "John" }} />
```

Always re-renders the child because `{ name: "John" }` is new identity each render.

Fix:

```jsx
const user = useMemo(() => ({ name: "John" }), []);
<Child data={user} />
```

Now child will not re-render unnecessarily.

---

# Example: Without useMemo (bad)

`RenderMemoValue3_NoMemoObject.jsx`

```jsx
import { useState, memo } from "react";

const Child = memo(function Child({ user }) {
  console.log("Child rendered with user:", user);
  return <p>{user.name}</p>;
});

export default function RenderMemoValue3_NoMemoObject() {
  const [count, setCount] = useState(0);

  const user = { name: "John" };

  return (
    <div>
      <h3>No useMemo Object Example</h3>

      <button onClick={() => setCount(count + 1)}>Update</button>

      <Child user={user} />
    </div>
  );
}
```

Child re-renders every time.

---

# Example: With useMemo (optimized)

`RenderMemoValue4_WithMemoObject.jsx`

```jsx
import { useState, memo, useMemo } from "react";

const Child = memo(function Child({ user }) {
  console.log("Child rendered with user:", user);
  return <p>{user.name}</p>;
});

export default function RenderMemoValue4_WithMemoObject() {
  const [count, setCount] = useState(0);

  const user = useMemo(() => ({ name: "John" }), []);

  return (
    <div>
      <h3>useMemo Object Example</h3>

      <button onClick={() => setCount(count + 1)}>Update</button>

      <Child user={user} />
    </div>
  );
}
```

Now Child renders only once.

---

# 7. Summary of useMemo

useMemo prevents expensive recalculations and prevents unnecessary re-renders by stabilizing:

* Objects
* Arrays
* Computed values
* Expensive calculations

Key rules:

* Only use it when needed
* Do not overuse it
* Always use it with memoized children that receive objects

---
