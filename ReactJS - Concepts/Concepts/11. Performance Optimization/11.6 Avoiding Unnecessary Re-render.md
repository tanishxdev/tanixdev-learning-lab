# 11.6 Avoiding Unnecessary Re-renders

This section brings together everything we learned:

* React.memo
* useCallback
* useMemo
* Keys
* Rendering triggers
* Component structure

But now we will **combine them into real scenarios** and focus on how to detect and fix unnecessary re-renders.

We will go slow.

---

# 1. What is an unnecessary re-render?

A re-render is unnecessary when:

* It does not change UI
* It does not update state
* It is caused indirectly by parent
* It does not provide any benefit
* It can be avoided with memoization or structural change

In real applications, 30%â€“70% of re-renders are unnecessary, especially in:

* Lists
* Child components
* Forms
* Dashboards
* Tables
* Charts
* Context consumers

Your job as a React developer is not to remove all re-renders.
Instead:

> Remove only the re-renders that do NOT help the UI.

---

# 2. How to detect unnecessary re-renders

You detect them using:

1. Console logs
2. React DevTools Profiler
3. Observing performance slowdowns
4. Seeing UI lag
5. Watching child components re-render due to parent updates
6. Functions/objects being recreated
7. List items re-rendering even when unchanged

Before optimizing, always **measure**.

---

# 3. The 4 Root Causes of Unnecessary Re-renders

Almost all unnecessary re-renders come from these:

1. Parent re-rendering frequently
2. Inline functions causing new references
3. Inline objects/arrays causing new references
4. Incorrect keys causing React to re-build lists

If you fix these four, 80 percent of performance problems disappear.

---

# 4. Scenario-Based Learning (Realistic Cases)

We will create examples to show the unnecessary re-renders and then fix them.

Folder:

```
src/components/11.PerformanceOptimization/AvoidingRerenders
```

We will build:

* BadParent.jsx
* GoodParent.jsx
* BadList.jsx
* GoodList.jsx
* BadForm.jsx
* GoodForm.jsx

Let's start step-by-step.

---

# SCENARIO 1

A parent re-renders frequently and causes a child to re-render unnecessarily.

## Bad Example

`BadParent.jsx`

```jsx
import { useState } from "react";

function Child() {
  console.log("Child rendered");
  return <p>Stable Child</p>;
}

export default function BadParent() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  return (
    <div>
      <h3>Bad Parent Example</h3>

      <button onClick={() => setCount(count + 1)}>Increment</button>

      <Child />
    </div>
  );
}
```

Output:

* Parent re-renders
* Child re-renders every time
* Child has no reason to re-render

This is unnecessary.

---

## Fix: React.memo

`GoodParent.jsx`

```jsx
import { useState, memo } from "react";

const Child = memo(function Child() {
  console.log("Child rendered");
  return <p>Stable Child</p>;
});

export default function GoodParent() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  return (
    <div>
      <h3>Good Parent Example (With memo)</h3>

      <button onClick={() => setCount(count + 1)}>Increment</button>

      <Child />
    </div>
  );
}
```

Now:

* Parent re-renders
* Child renders only once

This avoids unnecessary render.

---

# SCENARIO 2

Passing inline functions to memoized children

## Bad Example

`BadInlineFunction.jsx`

```jsx
import { useState, memo } from "react";

const Child = memo(function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
});

export default function BadInlineFunction() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h3>Bad Inline Function</h3>

      <button onClick={() => setCount(count + 1)}>Parent Increment</button>

      <Child onClick={() => setCount(count + 1)} />
    </div>
  );
}
```

Even with memo:

Child re-renders every time.

Why?

Because

```js
() => setCount(count + 1)
```

creates a new function each render.

---

## Fix: useCallback

`GoodInlineFunction.jsx`

```jsx
import { useState, memo, useCallback } from "react";

const Child = memo(function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
});

export default function GoodInlineFunction() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return (
    <div>
      <h3>Good Inline Function (useCallback)</h3>

      <button onClick={increment}>Parent Increment</button>

      <Child onClick={increment} />
    </div>
  );
}
```

Now:

* Child does not re-render unnecessarily
* Function reference is stable

---

# SCENARIO 3

Passing objects/arrays inline

## Bad Example

`BadObjectProp.jsx`

```jsx
import { useState, memo } from "react";

const Child = memo(function Child({ user }) {
  console.log("Child rendered");
  return <p>{user.name}</p>;
});

export default function BadObjectProp() {
  const [count, setCount] = useState(0);

  const user = { name: "John" };

  return (
    <div>
      <h3>Bad Object Prop</h3>

      <button onClick={() => setCount(count + 1)}>Update</button>

      <Child user={user} />
    </div>
  );
}
```

Child always re-renders because object recreated each time.

---

## Fix: useMemo

`GoodObjectProp.jsx`

```jsx
import { useState, memo, useMemo } from "react";

const Child = memo(function Child({ user }) {
  console.log("Child rendered");
  return <p>{user.name}</p>;
});

export default function GoodObjectProp() {
  const [count, setCount] = useState(0);

  const user = useMemo(() => ({ name: "John" }), []);

  return (
    <div>
      <h3>Good Object Prop (useMemo)</h3>

      <button onClick={() => setCount(count + 1)}>Update</button>

      <Child user={user} />
    </div>
  );
}
```

Now child re-renders only when actually needed.

---

# SCENARIO 4

Incorrect keys causing full list re-renders

## Bad Example

`BadList.jsx`

```jsx
export default function BadList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

React cannot track item identity.
Even one change forces entire list to re-render.

---

## Fix: Stable Keys

`GoodList.jsx`

```jsx
export default function GoodList({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

Now React updates only changed rows.

---

# 5. Summary: How to Avoid Unnecessary Re-renders

Use these rules:

1. Memoize child components with React.memo
2. Stabilize functions using useCallback
3. Stabilize objects/arrays using useMemo
4. Use stable, unique keys for lists
5. Move heavy logic outside render
6. Avoid passing inline objects or inline functions to children
7. Split large components into smaller ones
8. Avoid global context for large structures

Follow these and you will avoid 90 percent of performance issues.

---