# 11.2 React.memo Optimization

This is the foundation of preventing unnecessary re-renders.

We will cover:

* What React.memo does
* Why it works
* When it helps
* When it is useless
* When it is harmful
* How it works internally
* Practical code examples
* Visual demonstration components

We will go slowly and clearly.

---

# 1. What is React.memo?

React.memo is a **Higher Order Component** (HOC) that wraps a component and prevents it from re-rendering **if its props have not changed**.

Example:

```jsx
const Child = memo(function Child() {
  return <p>Hello</p>;
});
```

Now Child will only re-render if its props change.

---

# 2. React.memo DOES NOT prevent all re-renders

It prevents only **prop-driven re-renders**.

React.memo does not stop re-render if:

* Local state changes
* Context values consumed by the component change
* Parent forces props to change
* Functions or objects passed as props change due to new identity

This is important.

Memo is not magic.
It relies on **shallow comparison** of props.

---

# 3. Why React.memo Works (Internal Logic)

React.memo uses **shallow comparison**:

```
If oldProps === newProps
    skip re-render
Else
    re-render component
```

Shallow comparison rules:

* Primitive values: compared by value
* Objects/arrays/functions: compared by reference

Thus:

```jsx
<Child value={1} />
```

No re-render unless value changes.

But:

```jsx
<Child obj={{name: "A"}} />
```

Always re-renders because `{name: "A"}` is a new object every render.

---

# 4. When React.memo is useful

React.memo is beneficial when:

1. Child component is expensive
2. Child component receives stable props
3. Parent re-renders frequently
4. Child is visually or computationally heavy
5. You want to avoid unnecessary re-renders

Examples:

* List items in a large list
* Heavy UI cards
* Graphs or data visualizations
* Large forms
* Complex components with nested children

---

# 5. When React.memo is useless

Never use React.memo when:

* Component always receives changing props
* Component is extremely small (simple div/p tag)
* Component always re-renders due to parent logic
* Component needs to be re-rendered anyway

Memo adds overhead, so use it wisely.

---

# 6. When React.memo is harmful

Avoid React.memo when:

* You wrap every component blindly
* You wrap a component receiving inline objects
* You wrap a component receiving inline functions

It might slow down your app because:

* React.memo still performs shallow comparison
* Checking props can be slower than re-rendering the component

Memo should be used **only when needed**.

---

# 7. Practical Component Examples

We now create files inside:

```
src/components/11.PerformanceOptimization
```

---

## Example 1: Without memo (unnecessary re-renders)

`RenderMemo1_NoMemo.jsx`

```jsx
import { useState } from "react";

function Child() {
  console.log("Child rendered");
  return <p>Child Component</p>;
}

export default function RenderMemo1_NoMemo() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  return (
    <div>
      <h3>No Memo Example</h3>
      
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>

      <Child />
    </div>
  );
}
```

Observation:

* Child renders on every parent update
* Even though Child does not depend on count

---

## Example 2: With memo (optimized)

`RenderMemo2_WithMemo.jsx`

```jsx
import { useState, memo } from "react";

const Child = memo(function Child() {
  console.log("Child rendered");
  return <p>Child Component</p>;
});

export default function RenderMemo2_WithMemo() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  return (
    <div>
      <h3>React.memo Example</h3>
      
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>

      <Child />
    </div>
  );
}
```

Observation:

* Parent renders
* Child renders only once

This is the first place where memo actually helps.

---

# 8. Example 3: memo failing because of inline objects

`RenderMemo3_Failing.jsx`

```jsx
import { useState, memo } from "react";

const Child = memo(function Child({ user }) {
  console.log("Child rendered with:", user);
  return <p>{user.name}</p>;
});

export default function RenderMemo3_Failing() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h3>React.memo Failing Example</h3>

      <button onClick={() => setCount(count + 1)}>Update</button>

      <Child user={{ name: "John" }} />
    </div>
  );
}
```

Even with memo:

Child renders every time.

Why?

Because `{ name: "John" }` is a new object every render.

---

## Example 4: Fixing it with useMemo

`RenderMemo4_Fixed.jsx`

```jsx
import { useState, memo, useMemo } from "react";

const Child = memo(function Child({ user }) {
  console.log("Child rendered with:", user);
  return <p>{user.name}</p>;
});

export default function RenderMemo4_Fixed() {
  const [count, setCount] = useState(0);

  const user = useMemo(() => ({ name: "John" }), []);

  return (
    <div>
      <h3>React.memo Fixed with useMemo</h3>

      <button onClick={() => setCount(count + 1)}>Update</button>

      <Child user={user} />
    </div>
  );
}
```

Now Child renders only once.

---

# 9. Key Takeaway for React.memo

React.memo prevents unnecessary re-renders only when:

* Props do not change
* Props are stable
* Objects and functions are memoized

Memo is part of a bigger optimization system.
You must combine it with:

* useCallback
* useMemo
* Proper keying

Memo alone is not enough.

---
