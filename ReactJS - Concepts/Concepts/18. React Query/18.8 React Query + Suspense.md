# 18.8 React Query + Suspense

A deep, production-level explanation of **how React Query integrates with React Suspense**, why this pattern exists, when to use it, how it changes loading/error handling, and how to architect Suspense-based data fetching in modern apps.

Suspense turns server-state fetching into a **declarative, blocking mechanism**—similar to how Next.js Server Components work.
This is an advanced but powerful pattern.

---

# 1. Why Suspense With React Query?

### The core problem

React Query’s normal loading behavior:

```
isLoading → show fallback → UI loads after data arrives
```

This works, but:

* loading state logic is repeated across components
* deeply nested components need prop-drilling for loading states
* layout shifts occur when content appears
* design consistency suffers
* you manually handle loading everywhere

Suspense solves this by letting React handle loading fallback declaratively.

### Suspense lets you write:

```jsx
<Suspense fallback={<Spinner />}>
  <UserProfile />
</Suspense>
```

React Query integrates with Suspense, making fetching *feel synchronous*.

---

# 2. What Does Suspense Do?

Suspense will:

* **pause rendering** of content
* show fallback UI
* wait for data to be ready
* render actual content when data resolved

So instead of:

```jsx
if (isLoading) return <Spinner />
```

React Query + Suspense handles it automatically.

---

# 3. When Should You Use Suspense?

Use Suspense for:

* blocking sections of UI
* dashboard widgets
* non-interruptible content
* when you want consistent loading experience
* data that must be available before UI renders
* when you want to remove loading logic from components

DO NOT use Suspense for:

* infinite scroll
* pagination
* background refresh
* mutation loading
* partial UI loading
* mission-critical content

---

# 4. Enabling Suspense in React Query

Wrap your app:

```jsx
<QueryClientProvider client={queryClient}>
  <ReactQueryErrorResetBoundary>
    <Suspense fallback={<Spinner />}>
      <App />
    </Suspense>
  </ReactQueryErrorResetBoundary>
</QueryClientProvider>
```

In your query:

```jsx
useQuery({
  queryKey: ["user"],
  queryFn: fetchUser,
  suspense: true
});
```

This tells React Query to throw a Promise when loading — Suspense catches it.

---

# 5. How Suspense Mode Changes Behavior

### Normal mode:

```
isLoading → show spinner
isFetching → show background loader
```

### Suspense mode:

```
isLoading → throw promise → Suspense fallback shown
isFetching → still background refresh (optional)
```

Suspense simplifies UI pipeline:

```
Component does NOT need loading logic.
Suspense boundaries handle loading.
Error Boundaries handle errors.
```

---

# 6. Example: Component Without Loading Logic

```jsx
function User() {
  const { data } = useQuery({
    queryKey: ["user"],
    queryFn: fetchUser,
    suspense: true
  });

  return <div>{data.name}</div>;
}
```

Suspense will block until data is ready.

---

# 7. Adding Error Boundaries

You NEED an error boundary when using Suspense.

```jsx
<ErrorBoundary fallback={<ErrorScreen />}>
  <Suspense fallback={<Spinner />}>
    <User />
  </Suspense>
</ErrorBoundary>
```

React Query will:

* throw promise when loading → Suspense handles
* throw error when failed → ErrorBoundary handles

This creates a clean async architecture.

---

# 8. Full Example Setup

### Component:

```jsx
function ProductDetails() {
  const { data } = useQuery({
    queryKey: ["product", 1],
    queryFn: () => fetch("/api/product/1").then(r => r.json()),
    suspense: true
  });

  return <h1>{data.title}</h1>;
}
```

### Wrapper:

```jsx
<ErrorBoundary fallback={<p>Error loading...</p>}>
  <Suspense fallback={<p>Loading product...</p>}>
    <ProductDetails />
  </Suspense>
</ErrorBoundary>
```

UI flow becomes:

1. Suspense displays loading
2. Query fetches
3. Data arrives
4. Component renders
5. If error → ErrorBoundary handles

---

# 9. Background Refetch With Suspense

Even in Suspense mode:

```jsx
isFetching
```

is still useful for non-blocking loaders.

For example:

```jsx
const { data, isFetching } = useQuery({ ..., suspense: true });
```

UI:

```jsx
{isFetching && <SmallLoader />}
```

---

# 10. Handling Parallel Queries With Suspense

If multiple queries have `suspense: true`:

React Query waits for *all of them* to resolve before rendering.

Example:

```jsx
function Dashboard() {
  const user = useQuery({ queryKey: ["user"], suspense: true });
  const stats = useQuery({ queryKey: ["stats"], suspense: true });
  const products = useQuery({ queryKey: ["products"], suspense: true });

  return <DashboardUI />;
}
```

Suspense fallback shown until all of them are loaded.

This is useful for pages that must render fully loaded data at once.

---

# 11. Suspense + Prefetching (Powerful Pattern)

You can prefetch data:

```jsx
await queryClient.prefetchQuery(["user"], fetchUser);
```

Then render component with Suspense:

```jsx
<Suspense fallback={<Spinner />}>
  <User />
</Suspense>
```

No spinner shown because data already in cache.

---

# 12. Using Suspense for Nested Components

```jsx
<Suspense fallback={<HeaderSkeleton />}>
  <Header />
</Suspense>

<Suspense fallback={<BodySkeleton />}>
  <MainContent />
</Suspense>
```

Each section loads independently.

Better UX than one giant page spinner.

---

# 13. Avoiding Suspense for Lists (Important)

Suspense can cause:

* large waterfalls
* long wait times
* inability to show partial data
* performance bottlenecks

Better to use normal loading or skeleton loaders for lists.

---

# 14. Best Practices (Suspense + React Query)

1. Use Suspense for blocking UI (detail pages, widgets)
2. Use normal queries for lists, incremental loads
3. Always wrap with ErrorBoundary
4. Keep Suspense boundaries small and isolated
5. Combine with skeletons for better UX
6. Use prefetching to avoid loading flicker
7. Never rely solely on Suspense for mutations
8. Avoid Suspense in infinite scroll or pagination
9. Tune staleTime so Suspense does not block unnecessarily
10. Use suspense only when your UI architecture supports it

---

# 15. Comparison Table (Suspense vs Normal Queries)

| Feature            | Suspense + RQ | Normal RQ |
| ------------------ | ------------- | --------- |
| Show fallback ⏳    | Automatic     | Manual    |
| Handle errors      | ErrorBoundary | isError   |
| Code simplicity    | Very high     | Medium    |
| Layout shifts      | Eliminated    | Possible  |
| Background refetch | Yes           | Yes       |
| Partial rendering  | Hard          | Easy      |
| Infinite scroll    | Not ideal     | Perfect   |

Suspense is powerful but must be used wisely.

---

# 16. Dry Run Example (Full Async Lifecycle)

Query with suspense:

```jsx
useQuery({ suspense: true });
```

### Flow:

1. Component renders
2. Query throws promise
3. Suspense catches → shows fallback
4. Data fetched
5. Suspense re-renders child
6. If refetch occurs:

   * show cached data
   * isFetching = true
   * no blocking fallback
7. If error occurs:

   * error thrown
   * ErrorBoundary handles it

Suspense completely removes loading/error code from the component.

---

# 17. Follow-up Questions

1. Why does React Query throw a Promise when suspense is enabled?
2. Why must Error Boundaries wrap Suspense when using React Query?
3. What happens when multiple queries inside a component use suspense?
4. When should Suspense not be used in React Query?
5. How does background refetch behave with Suspense?
6. Why is Suspense bad for pagination and infinite scroll?
7. How does prefetching remove Suspense fallback UI?
8. Why does Suspense reduce loading boilerplate?
9. How does Suspense improve UX for detail pages?
10. How should Suspense boundaries be structured in large apps?
