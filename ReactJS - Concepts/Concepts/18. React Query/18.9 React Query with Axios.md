# 18.9 React Query with Axios

A complete, production-grade explanation of **how to use Axios with React Query**, why Axios is often preferred over fetch, how to architect API layers cleanly, and how to integrate Axios interceptors (auth tokens, refresh tokens) with React Query.

This is the real-world pattern used in most React apps.

---

# 1. Why Use Axios With React Query?

Axios provides advantages over fetch:

* Automatic JSON parsing
* Automatic request cancellation
* Interceptors (auth headers, refresh tokens)
* Default configuration
* Cleaner error handling
* Timeout support
* Supports request & response transformation

React Query + Axios gives:

```
Caching + retries + stale/fresh rules  → from React Query
Consistent API client                 → from Axios
```

This is the “industry standard” setup.

---

# 2. Axios Setup (api.js)

Create a central Axios instance.

```jsx
// api.js
import axios from "axios";

export const api = axios.create({
  baseURL: "https://api.example.com",
  withCredentials: true, // optional
  timeout: 10000
});
```

Now all API calls go through this one client.

---

# 3. Adding Request Interceptors (Auth Tokens)

```jsx
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

This attaches the token to every request automatically.

---

# 4. Adding Response Interceptor (Token Refresh Example)

```jsx
api.interceptors.response.use(
  (res) => res,
  async (error) => {
    if (error.response?.status === 401) {
      // Token expired — attempt refresh
      const newToken = await refreshToken();
      localStorage.setItem("token", newToken);

      // retry request
      error.config.headers.Authorization = `Bearer ${newToken}`;
      return api.request(error.config);
    }
    return Promise.reject(error);
  }
);
```

Now React Query will use an Axios instance with:

* automatic tokens
* token refresh
* retries
* consistent data format

---

# 5. Using Axios in React Query — Basic Example

```jsx
import { useQuery } from "@tanstack/react-query";
import { api } from "./api";

export function useProducts() {
  return useQuery({
    queryKey: ["products"],
    queryFn: () => api.get("/products").then((res) => res.data),
  });
}
```

You must return `res.data` because Axios wraps responses.

---

# 6. Why Return res.data?

Axios response shape:

```js
{
  data: {...},
  status: 200,
  headers: {...},
  ...
}
```

React Query expects:

```
queryFn → return data only
```

So always:

```jsx
.then((res) => res.data)
```

---

# 7. Error Handling With Axios + React Query

React Query will expose errors from Axios:

```jsx
const { error, isError } = useQuery(...);

if (isError) return <p>{error.message}</p>;
```

Axios errors include `response.data.message` if backend sends messages.

You can format error handler globally in interceptors.

---

# 8. POST / PUT / DELETE with useMutation

```jsx
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { api } from "./api";

export function useAddProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload) =>
      api.post("/products", payload).then((res) => res.data),

    onSuccess: () => {
      queryClient.invalidateQueries(["products"]);
    }
  });
}
```

React Query handles:

* loading state
* error
* retry
* background refetch

---

# 9. Example: Delete Item

```jsx
export function useDeleteProduct() {
  const qc = useQueryClient();

  return useMutation({
    mutationFn: (id) => api.delete(`/products/${id}`),

    onSuccess: () => {
      qc.invalidateQueries(["products"]);
    }
  });
}
```

---

# 10. Example: Pagination With Axios + React Query

```jsx
const { data } = useQuery({
  queryKey: ["products", page],
  queryFn: () =>
    api.get(`/products?page=${page}`).then((res) => res.data),
  keepPreviousData: true,
});
```

---

# 11. Example: Infinite Scroll

```jsx
const result = useInfiniteQuery({
  queryKey: ["posts"],
  queryFn: ({ pageParam = 1 }) =>
    api.get(`/posts?page=${pageParam}`).then((res) => res.data),

  getNextPageParam: (lastPage) =>
    lastPage.hasMore ? lastPage.nextPage : undefined
});
```

Axios fits perfectly here.

---

# 12. Uploading Files With Axios + Mutation

Axios handles file uploads smoothly:

```jsx
export function useUploadImage() {
  return useMutation({
    mutationFn: (file) => {
      const form = new FormData();
      form.append("image", file);

      return api.post("/upload", form).then((res) => res.data);
    }
  });
}
```

---

# 13. Example: Optimistic Update with Axios

```jsx
export function useToggleLike() {
  const qc = useQueryClient();

  return useMutation({
    mutationFn: (id) => api.post(`/posts/${id}/like`),

    onMutate: async (id) => {
      await qc.cancelQueries(["post", id]);

      const prev = qc.getQueryData(["post", id]);

      qc.setQueryData(["post", id], (old) => ({
        ...old,
        liked: !old.liked
      }));

      return { prev };
    },

    onError: (_, id, ctx) => {
      qc.setQueryData(["post", id], ctx.prev);
    },

    onSettled: (_, __, id) => {
      qc.invalidateQueries(["post", id]);
    }
  });
}
```

Axios works seamlessly here.

---

# 14. Setting Global Defaults for Axios + React Query

```jsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5000,
      retry: 2,
      refetchOnWindowFocus: false
    }
  }
});
```

You can combine this with Axios defaults for complete behavior control.

---

# 15. Best Practices (Critical)

### 1. Always return `res.data`

Avoid wrapping Axios response everywhere.

### 2. Create a single Axios instance

Centralized API logic = good architecture.

### 3. Add interceptors

Handle tokens, refresh logic, logging.

### 4. Do NOT store API data in Zustand/Redux

Let React Query manage cache.

### 5. Use Axios errors for cleaner UI messages

Server messages appear automatically.

### 6. Reuse API functions inside queries & mutations

Avoid inline repeated logic.

---

# 16. Folder Architecture (Recommended)

```
src/
 ├── api/
 │     ├── api.js              // axios instance
 │     ├── auth.js             // queryFn helpers
 │     ├── products.js
 │     ├── users.js
 │
 ├── hooks/
 │     ├── useProducts.js      // useQuery wrappers
 │     ├── useAddProduct.js
 │     ├── useLogin.js
 │
 ├── components/
 │     └── ...
```

This structure prevents spaghetti code.

---

# 17. Dry Run Example (Full Flow)

### User clicks “Add Product”

1. mutation.mutate(payload)
2. Axios interceptors attach token
3. Axios sends POST request
4. React Query tracks loading state
5. On success: invalidate queries
6. products list refetches
7. UI updates automatically

Everything is wired through Axios + React Query.

---

# 18. Follow-up Questions

1. Why is a central Axios instance better than using fetch everywhere?
2. How do Axios interceptors improve React Query architecture?
3. Why should queryFn always return res.data?
4. When should retry be disabled for Axios requests?
5. How do you combine optimistic updates with Axios?
6. What happens if interceptors throw errors?
7. Why is storing API data in Zustand wrong when using React Query?
8. Why is Axios a better choice for file uploads?
9. How do pagination and infinite scroll differ with Axios?
10. How would you architect refresh token flow with Axios + React Query?
