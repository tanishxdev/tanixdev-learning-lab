# **19.3 Error Boundaries**

A complete, production-grade explanation of **what Error Boundaries are**, how they work, why Suspense depends on them, and how to use them to architect resilient UI in React applications.


---

# 1. What Is an Error Boundary?

An Error Boundary is a **React component that catches errors** that occur:

* in its child components
* during rendering
* in lifecycle methods
* inside Suspense boundaries
* inside async data fetching libraries (when enabled)

Error boundaries prevent the entire UI from breaking when a child component fails.

Syntax:

```jsx
<ErrorBoundary fallback={<ErrorUI />}>
  <MyComponent />
</ErrorBoundary>
```

If `MyComponent` throws an error, React will render `ErrorUI` instead of crashing the app.

---

# 2. The Core Problem Error Boundaries Solve

## Without an error boundary:

If a component throws an error:

```jsx
function Product() {
  throw new Error("Failed fetching product");
}
```

The app crashes, or React unmounts the entire subtree.

This results in:

1. White screen
2. Broken user experience
3. Uncaught exceptions
4. Impossible recovery
5. No retry mechanism

Error boundaries solve all of these.

---

# 3. What Error Boundaries Can Catch

Error boundaries catch errors from:

* Render phase
* Lifecycle methods
* Suspense fallbacks
* React Query (when `useErrorBoundary` is enabled)
* Child components throwing exceptions
* Async data libraries that rethrow errors synchronously

They do not catch:

* Errors in event handlers
* Errors in async callbacks not tied to render
* Errors in server-side code
* Errors in non-React code executed outside render tree

---

# 4. How Error Boundaries Work Internally

Error Boundaries work through Reactâ€™s **error propagation system**.

When a child component throws:

1. React stops rendering the subtree.
2. React walks upward searching for the closest `<ErrorBoundary>` instance.
3. When found, React calls its `getDerivedStateFromError`.
4. The boundary switches to fallback UI.
5. The app continues running normally.

This prevents a full UI crash.

---

# 5. Creating a Real Error Boundary Component

React requires a **class component** for error boundaries (for now).
You wrap it into a reusable wrapper.

## File: `ErrorBoundary.jsx`

```jsx
import React from "react";

export class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("ErrorBoundary caught:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <p>Something went wrong.</p>;
    }
    return this.props.children;
  }
}
```

Usage:

```jsx
<ErrorBoundary fallback={<ErrorBox />}>
  <UserProfile />
</ErrorBoundary>
```

---

# 6. Error Boundaries + Suspense

Suspense requires error boundaries because:

* Suspense handles pending async state
* Error Boundary handles error state

Together:

```
Suspense handles: waiting
ErrorBoundary handles: failing
```

Example:

```jsx
<ErrorBoundary fallback={<ErrorMessage />}>
  <Suspense fallback={<LoadingSkeleton />}>
    <UserDetails />
  </Suspense>
</ErrorBoundary>
```

If request fails:

* Suspense will not catch it
* ErrorBoundary will render its fallback

This is why Suspense and ErrorBoundaries are always paired.

---

# 7. React Query + Error Boundaries (Production Pattern)

Enable React Query integration:

```jsx
useQuery({
  queryKey: ["user"],
  queryFn: fetchUser,
  suspense: true,
  useErrorBoundary: true
});
```

Now React Query will:

* Suspend for loading
* Throw error for ErrorBoundary

UI tree:

```jsx
<ErrorBoundary fallback={<UserError />}>
  <Suspense fallback={<UserSkeleton />}>
    <UserCard />
  </Suspense>
</ErrorBoundary>
```

---

# 8. Building a Reusable Error UI Component

File: `ErrorBox.jsx`

```jsx
export function ErrorBox({ message, onRetry }) {
  return (
    <div className="error-box">
      <p>{message || "Something went wrong."}</p>
      {onRetry && <button onClick={onRetry}>Retry</button>}
    </div>
  );
}
```

This allows:

* Dynamic messages
* Retry handlers
* Reusable error UI

---

# 9. Error Resetting (Key Feature)

If you want to retry a failed component:

```jsx
<ErrorBoundary fallback={<ErrorBox />} key={userId}>
  <UserDetails userId={userId} />
</ErrorBoundary>
```

Changing the `key` resets the boundary.

React treats it as a new component, clearing the error state.

---

# 10. Component-Level vs Page-Level Error Boundaries

## Component-Level

Wrap small UI parts:

```jsx
<ErrorBoundary fallback={<UserError />}>
  <UserProfile />
</ErrorBoundary>
```

Good for:

* Profile cards
* Charts
* Tables
* Widgets

## Page-Level

Wrap the entire route:

```jsx
<ErrorBoundary fallback={<PageError />}>
  <Dashboard />
</ErrorBoundary>
```

Good for:

* Route failures
* Large layout issues

---

# 11. Error Boundary Design Patterns (Real-World)

## Pattern 1: Boundary per layout region

Used by large apps:

* Header boundary
* Sidebar boundary
* Content boundary
* Widgets boundary

Each one isolates failures.

## Pattern 2: Localized retry

Only failing card reloads itself.

## Pattern 3: Combined Suspense + ErrorBoundary wrapper

Create a standard higher-order wrapper:

```jsx
function AsyncWrapper({ children, loading, error }) {
  return (
    <ErrorBoundary fallback={error}>
      <Suspense fallback={loading}>
        {children}
      </Suspense>
    </ErrorBoundary>
  );
}
```

Used as:

```jsx
<AsyncWrapper
  loading={<UserSkeleton />}
  error={<UserError />}
>
  <UserDetails />
</AsyncWrapper>
```

This pattern is extremely common in production apps.

---

# 12. Debugging Errors with Boundaries

When error happens:

* `componentDidCatch` receives stack trace
* You can log to a monitoring service like Sentry
* You can show user-friendly fallback
* You can retry specific parts of the UI

Avoid using console logs in production.
Use a centralized logger instead.

---

# 13. Full Production Example

```jsx
export default function Dashboard() {
  return (
    <ErrorBoundary fallback={<DashboardError />}>

      <Header />

      <div className="grid">

        <ErrorBoundary fallback={<StatsError />}>
          <Suspense fallback={<StatsSkeleton />}>
            <Stats />
          </Suspense>
        </ErrorBoundary>

        <ErrorBoundary fallback={<ChartError />}>
          <Suspense fallback={<ChartSkeleton />}>
            <Chart />
          </Suspense>
        </ErrorBoundary>

      </div>

    </ErrorBoundary>
  );
}
```

This is the architecture used in enterprise dashboards:

* Each card isolated
* Failure does not break the app
* Retry possible per component
* Suspense handles loading
* Boundary handles errors

---

# 14. Follow-up Questions

These are practical, developer-thinking questions, not interview questions.

1. Which components in your current UI should have their own error boundary?
2. Do you need separate boundaries for sidebar, content, and widgets?
3. How would you design retry logic for a component that frequently fails?
4. Should your error messages come from backend or be generic?
5. How would you log errors inside `componentDidCatch`?
6. Would you place a boundary above or below Suspense? Why?
7. Can your app use a global error boundary for routes but local boundaries for cards?
8. How do you reset an error boundary without refreshing the page?
9. Should your API layer throw meaningful errors for boundaries?
10. Which React Query hooks need `useErrorBoundary: true` for clean UI layering?

---
