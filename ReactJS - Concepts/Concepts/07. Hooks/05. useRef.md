# useRef Hook – Simple → Practical → Real-world

Think of **useRef as a safe permanent box** that React does NOT erase on re-render.

---

## 1️⃣ What problem does useRef solve?

Sometimes we need to:

* Directly access DOM elements
* Store values without re-rendering
* Keep data persistent but hidden from UI

useState:
✅ Changes UI
❌ Triggers re-render

useRef:
✅ Stores data
❌ Does NOT trigger re-render

---

## 2️⃣ Simple Definition

> useRef creates a mutable reference that persists across renders without causing re-render.

---

## 3️⃣ Very Simple Mental Model

```
useState → UI Memory
useRef → Invisible Memory
```

---

## 4️⃣ Basic Syntax

```js
const ref = useRef(initialValue);
```

Access value:

```js
ref.current
```

---

# Progressive Examples

---

## ✅ Example 1: Accessing Input DOM Element

### Real use case:

Auto focus input or read value directly.

### Example1_Focus.jsx

```jsx
import { useRef } from "react";

function Example1_Focus() {
  const inputRef = useRef(null);

  function focusInput() {
    inputRef.current.focus();
  }

  return (
    <div>
      <h3>useRef Example 1: DOM Access</h3>

      <input ref={inputRef} placeholder="Click button to focus" />

      <button onClick={focusInput}>
        Focus Input
      </button>
    </div>
  );
}

export default Example1_Focus;
```

Now:

* Button clicks
* Cursor moves automatically to input

Used in:

* Search bars
* Login forms
* Chat apps

---

## ✅ Example 2: Store value without re-render

### Scenario:

Count increase but UI should NOT update

### Example2_NoRender.jsx

```jsx
import { useRef } from "react";

function Example2_NoRender() {
  const countRef = useRef(0);

  function increase() {
    countRef.current += 1;
    console.log("Current count:", countRef.current);
  }

  return (
    <div>
      <h3>useRef Example 2: No Re-render</h3>
      <button onClick={increase}>
        Increase Hidden Count
      </button>
    </div>
  );
}

export default Example2_NoRender;
```

Output:

* Console value increases
* UI does not change

---

## ✅ Example 3: Track Previous State Value

### Real case:

Compare old value vs new value.

```jsx
import { useState, useEffect, useRef } from "react";

function Example3_Previous() {
  const [count, setCount] = useState(0);
  const prevCount = useRef(0);

  useEffect(() => {
    prevCount.current = count;
  }, [count]);

  return (
    <div>
      <h3>useRef Example 3: Previous Value</h3>
      <p>Current: {count}</p>
      <p>Previous: {prevCount.current}</p>

      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </div>
  );
}

export default Example3_Previous;
```

Real use:

* Show last search
* Track input changes
* Undo logic

---

## ✅ Example 4: Stopwatch Timer

### Realistic advanced use

```jsx
import { useRef, useState } from "react";

function Example4_Stopwatch() {
  const timerRef = useRef(null);
  const [seconds, setSeconds] = useState(0);

  function startTimer() {
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        setSeconds(prev => prev + 1);
      }, 1000);
    }
  }

  function stopTimer() {
    clearInterval(timerRef.current);
    timerRef.current = null;
  }

  return (
    <div>
      <h3>Stopwatch using useRef</h3>
      <p>Time: {seconds}s</p>

      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}

export default Example4_Stopwatch;
```

Here:

* Timer stored in ref
* UI remains smooth
* Prevents multiple intervals

---

# Add to App.jsx

```jsx
import Example1_Focus from "./components/Example1_Focus";
import Example2_NoRender from "./components/Example2_NoRender";
import Example3_Previous from "./components/Example3_Previous";
import Example4_Stopwatch from "./components/Example4_Stopwatch";

function App() {
  return (
    <div>
      <h1>useRef Examples</h1>

      <Example1_Focus />
      <hr />

      <Example2_NoRender />
      <hr />

      <Example3_Previous />
      <hr />

      <Example4_Stopwatch />
    </div>
  );
}

export default App;
```

---

# When should you use useRef?

✅ Use when:

* DOM manipulation needed
* Preserve values between renders
* Performance-sensitive logic
* Timers or external objects

❌ Avoid when:

* UI needs updating (useState instead)

---

# Quick Comparison

| useState           | useRef         |
| ------------------ | -------------- |
| Triggers re-render | No re-render   |
| UI updates         | No UI update   |
| Reactive           | Silent storage |

---

## Quick Check

What will happen?

```js
const ref = useRef(0);
ref.current++;
```

A) UI updates
B) Value changes but UI does not
