# useReducer Hook – Deep, Clear & Practical Understanding

Think of **useReducer as the BIG BROTHER of useState**.

When state logic becomes complex, useState becomes messy.
useReducer brings **structure and control**.

---

## 1️⃣ Why useReducer Exists (Problem First)

With useState, complex logic looks like this:

```jsx
const [count, setCount] = useState(0);

setCount(count + 1);
setCount(count - 1);
setCount(count * 2);
```

Now imagine:

* 10 different state changes
* Many conditions
* Different actions

Code becomes:

* Hard to read
* Hard to debug
* Error-prone

This is where useReducer is needed.

---

## 2️⃣ Simple Definition

> useReducer manages state using a fixed logic system based on actions.

Instead of:

```
setState(value)
```

You say:

```
dispatch({ type: "INCREMENT" })
```

And a special function decides what to do.

---

## 3️⃣ Real-world analogy

useState:
You directly change things yourself.

useReducer:
You give instructions to a manager:
"Increase", "Decrease", "Reset"

Manager decides HOW to update.

---

## 4️⃣ Basic Structure of useReducer

```js
const [state, dispatch] = useReducer(reducerFunction, initialState);
```

Parts:

* state → current value
* dispatch → sends action
* reducer → brain of logic

---

# useReducer Core Concept

```
UI → dispatch(action) → reducer → newState → UI update
```

Everything flows predictably.

---

# Progressive Examples

We will start simple and increase level.

---

## ✅ Example 1: Simple Counter using useReducer

### Concept: Same counter but structured

### Example1_ReducerCounter.jsx

```jsx
import { useReducer } from "react";

// Reducer function (logic controller)
function reducer(state, action) {
  if (action.type === "increment") {
    return state + 1;
  }

  if (action.type === "decrement") {
    return state - 1;
  }

  return state;
}

function Example1_ReducerCounter() {
  const [count, dispatch] = useReducer(reducer, 0);

  return (
    <div>
      <h3>useReducer Counter</h3>
      <p>Count: {count}</p>

      <button onClick={() => dispatch({ type: "increment" })}>
        +
      </button>

      <button onClick={() => dispatch({ type: "decrement" })}>
        -
      </button>
    </div>
  );
}

export default Example1_ReducerCounter;
```

### Flow:

Click "+"
→ dispatch({type:"increment"})
→ reducer runs
→ updates state
→ UI re-renders

---

## ✅ Example 2: Multi-action State (Real Logic)

### Concept: Bank Account Simulation

### Example2_Bank.jsx

```jsx
import { useReducer } from "react";

function bankReducer(state, action) {
  switch (action.type) {
    case "deposit":
      return { balance: state.balance + 100 };

    case "withdraw":
      return { balance: state.balance - 100 };

    case "reset":
      return { balance: 0 };

    default:
      return state;
  }
}

function Example2_Bank() {
  const [state, dispatch] = useReducer(bankReducer, { balance: 0 });

  return (
    <div>
      <h3>Bank Account</h3>
      <p>Balance: ₹{state.balance}</p>

      <button onClick={() => dispatch({ type: "deposit" })}>
        Deposit ₹100
      </button>

      <button onClick={() => dispatch({ type: "withdraw" })}>
        Withdraw ₹100
      </button>

      <button onClick={() => dispatch({ type: "reset" })}>
        Reset
      </button>
    </div>
  );
}

export default Example2_Bank;
```

This is realistic:

* Payment apps
* Wallet systems
* Finance apps

---

## ✅ Example 3: Form with Multiple Fields

### Concept: Managing 3 fields with single reducer

```jsx
import { useReducer } from "react";

const initialState = {
  name: "",
  email: "",
  age: ""
};

function formReducer(state, action) {
  return {
    ...state,
    [action.field]: action.value
  };
}

function Example3_Form() {
  const [form, dispatch] = useReducer(formReducer, initialState);

  return (
    <div>
      <h3>Form using useReducer</h3>

      <input 
        placeholder="Name"
        value={form.name}
        onChange={(e) =>
          dispatch({ field: "name", value: e.target.value })
        }
      />

      <input 
        placeholder="Email"
        value={form.email}
        onChange={(e) =>
          dispatch({ field: "email", value: e.target.value })
        }
      />

      <input 
        placeholder="Age"
        value={form.age}
        onChange={(e) =>
          dispatch({ field: "age", value: e.target.value })
        }
      />

      <p>{JSON.stringify(form)}</p>
    </div>
  );
}

export default Example3_Form;
```

Used in:

* Login forms
* Registration panels
* Multi-field data systems

---

# Connecting to App.jsx

```jsx
import Example1_ReducerCounter from "./components/Example1_ReducerCounter";
import Example2_Bank from "./components/Example2_Bank";
import Example3_Form from "./components/Example3_Form";

function App() {
  return (
    <div>
      <h1>useReducer Examples</h1>

      <Example1_ReducerCounter />
      <hr />

      <Example2_Bank />
      <hr />

      <Example3_Form />
    </div>
  );
}

export default App;
```

---

# When to use useReducer instead of useState?

Use useReducer when:

* Many state transitions
* Complex logic
* Multiple conditions
* Predictable flow required

Use useState when:

* Simple isolated state

---

## Quick Comparison

| useState      | useReducer         |
| ------------- | ------------------ |
| Easy          | Structured         |
| Simple        | Scalable           |
| Direct update | Action-based logic |

---

# Mental Model

```
useState → small memory
useReducer → organised control system
```

---

## Quick Check (to confirm understanding)

Which is more suitable for complex logic?

A) useState
B) useReducer

