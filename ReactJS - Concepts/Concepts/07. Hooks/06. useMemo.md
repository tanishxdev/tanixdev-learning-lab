# useMemo Hook – Performance + Optimisation (Simple → Real → Practical)

Most learners misunderstand useMemo, so we’ll go step-by-step and VERY clearly.

---

## 1️⃣ The core problem useMemo solves

Every time state changes, React re-renders the component function.

That means:

* All calculations inside the component run again
* Even heavy logic re-runs unnecessarily

This can cause:

* Slow UI
* Lag
* Performance drop

Example problem:

```js
const total = heavyCalculation(count);
```

This runs again and again even when not required.

---

## 2️⃣ Simple definition

> useMemo remembers the result of a calculation and only recalculates when needed.

---

## 3️⃣ Mental model

```
Normal function → recalculates every render
useMemo → caches the result
```

So:

```
useMemo = Smart Calculator with Memory
```

---

## 4️⃣ Basic Syntax

```js
const value = useMemo(() => {
  return expensiveCalculation;
}, [dependencies]);
```

* First argument → function to run
* Second argument → when to recalculate

---

# Progressive Understanding

---

## ✅ Example 1: Without useMemo (Problem)

```jsx
import { useState } from "react";

function Example1_NoMemo() {
  const [count, setCount] = useState(0);

  function slowCalculation(num) {
    console.log("Heavy calculation running...");
    for (let i = 0; i < 100000000; i++) {}
    return num * 2;
  }

  const result = slowCalculation(count);

  return (
    <div>
      <h3>Without useMemo</h3>
      <p>Result: {result}</p>

      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </div>
  );
}

export default Example1_NoMemo;
```

Problem:

* Every render runs slowCalculation
* Even when nothing useful changes

---

## ✅ Example 2: Optimised with useMemo

```jsx
import { useState, useMemo } from "react";

function Example2_UseMemo() {
  const [count, setCount] = useState(0);

  function slowCalculation(num) {
    console.log("Heavy calculation running...");
    for (let i = 0; i < 100000000; i++) {}
    return num * 2;
  }

  const result = useMemo(() => {
    return slowCalculation(count);
  }, [count]);

  return (
    <div>
      <h3>With useMemo</h3>
      <p>Result: {result}</p>

      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </div>
  );
}

export default Example2_UseMemo;
```

Now:

* Calculation runs ONLY when count changes
* Not on every render

---

## ✅ Example 3: Real UI Case (Filtering List)

### Scenario:

Filter huge product list

```jsx
import { useState, useMemo } from "react";

function Example3_Filter() {
  const [search, setSearch] = useState("");
  const products = ["Laptop", "Phone", "Tablet", "Monitor", "Keyboard"];

  const filteredProducts = useMemo(() => {
    return products.filter(item =>
      item.toLowerCase().includes(search.toLowerCase())
    );
  }, [search]);

  return (
    <div>
      <h3>Search Products</h3>

      <input 
        placeholder="Search..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />

      <ul>
        {filteredProducts.map(item => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default Example3_Filter;
```

Here:

* Filter recalculates ONLY when search changes
* Not on other renders

---

## ✅ Example 4: Real Performance Use

### Scenario:

Total Price Calculation

```jsx
import { useState, useMemo } from "react";

function Example4_Cart() {
  const [items, setItems] = useState([
    { name: "Laptop", price: 50000 },
    { name: "Phone", price: 20000 }
  ]);

  const totalPrice = useMemo(() => {
    console.log("Calculating total...");
    return items.reduce((sum, item) => sum + item.price, 0);
  }, [items]);

  return (
    <div>
      <h3>Shopping Cart</h3>
      <p>Total: ₹{totalPrice}</p>

      <button onClick={() => setItems([...items, { name: "Mouse", price: 1000 }])}>
        Add Item
      </button>
    </div>
  );
}

export default Example4_Cart;
```

---

# Add All to App.jsx

```jsx
import Example1_NoMemo from "./components/Example1_NoMemo";
import Example2_UseMemo from "./components/Example2_UseMemo";
import Example3_Filter from "./components/Example3_Filter";
import Example4_Cart from "./components/Example4_Cart";

function App() {
  return (
    <div>
      <h1>useMemo Examples</h1>

      <Example1_NoMemo />
      <hr />

      <Example2_UseMemo />
      <hr />

      <Example3_Filter />
      <hr />

      <Example4_Cart />
    </div>
  );
}

export default App;
```

---

# Key Points You Must Remember

✅ useMemo:

* Optimises expensive calculations
* Prevents unnecessary re-runs
* Improves performance

❌ Do NOT use it everywhere
Only when calculation is heavy.

---

# Quick Understanding Check

When does useMemo recalculate value?

A) On every render
B) Only when dependency changes
