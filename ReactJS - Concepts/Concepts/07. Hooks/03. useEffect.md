# useEffect Hook – Lifecycle + Side Effects (Step-by-step Understanding)

We will follow the same style as useState:
Simple → Clear → Real → Progressive difficulty.

---

## 1. First Understand: What problem does useEffect solve?

React components re-render when state changes.
But sometimes we want to run **extra logic automatically** like:

- Fetch data from API
- Run code when page loads
- Sync data with localStorage
- Add event listeners
- Start timers
- Clean resources

These are called:

> Side Effects

And React gives useEffect to handle them.

---

## 2. Simple Definition

> useEffect lets you run code automatically after rendering.

It connects your component to the outside world.

---

## 3. Think like this

useState → controls data
useEffect → reacts to data changes

---

## 4. Basic Syntax

```js
useEffect(() => {
  // side effect logic
}, [dependencies]);
```

Structure:

- First parameter → function to run
- Second parameter → when to run

---

# The 3 Behaviour Types of useEffect

## TYPE 1: Runs on every render

```js
useEffect(() => {
  console.log("Runs every time");
});
```

No dependency array → always executes.

---

## TYPE 2: Runs only once (on page load)

```js
useEffect(() => {
  console.log("Runs only once");
}, []);
```

Empty array → componentDidMount behaviour.

---

## TYPE 3: Runs when specific value changes

```js
useEffect(() => {
  console.log("Runs when count changes");
}, [count]);
```

Runs only when `count` updates.

---

# Progressive Real Examples

Folder structure remains:

```
src/
  components/
    Effect1_PageLoad.jsx
    Effect2_Dependency.jsx
    Effect3_API.jsx
    Effect4_Timer.jsx
  App.jsx
```

---

## ✅ Example 1: Run code on page load

### Use case: Welcome / Initialization

**Effect1_PageLoad.jsx**

```jsx
import { useEffect } from "react";

function Effect1_PageLoad() {
  useEffect(() => {
    console.log("Component Mounted - Page Loaded");
  }, []);

  return (
    <div>
      <h3>Example 1: Page Load Effect</h3>
      <p>Check console to see effect</p>
    </div>
  );
}

export default Effect1_PageLoad;
```

What happens:

- Runs once when component loads
- Similar to: componentDidMount

---

## ✅ Example 2: Based on State Change

### Use case: React when count changes

**Effect2_Dependency.jsx**

```jsx
import { useState, useEffect } from "react";

function Effect2_Dependency() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Count changed to:", count);
  }, [count]);

  return (
    <div>
      <h3>Example 2: Dependency Effect</h3>
      <p>Count: {count}</p>

      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}

export default Effect2_Dependency;
```

Here:

- Effect only runs when count changes
- Logs each update

---

## ✅ Example 3: Fetch Data (Real-world API case)

### Use case: Load data when page opens

#### Code (with minimal comments)

```jsx
import { useState, useEffect } from "react";
// useState  -> to store API data in component state
// useEffect -> to run side-effect (API call) after component renders

function Effect3_API() {
  // State to store list of users fetched from API
  const [users, setUsers] = useState([]);

  useEffect(() => {
    // Fetch data from external API
    fetch("https://jsonplaceholder.typicode.com/users")
      .then((res) => res.json()) // convert response to JS object
      .then((data) => setUsers(data)); // store data in state
  }, []);
  // Empty dependency array => run only once (on component mount)

  return (
    <div>
      <h3>Example 3: API Data</h3>

      <ul>
        {users.map((user) => (
          // key helps React identify each list item uniquely
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default Effect3_API;
```

---

#### Step-by-Step Explanation (Mental Model)

#### 1. Why `useState` is needed

```js
const [users, setUsers] = useState([]);
```

- API data does **not exist initially**
- Component renders once with `users = []`
- After API call finishes → we update state
- Updating state causes **re-render**

Without `useState`, React would not remember the fetched data.

---

#### 2. Why `useEffect` is needed

```js
useEffect(() => {
  fetch(...)
}, []);
```

Rule:

> **API calls are side-effects → must go inside `useEffect`**

If you put `fetch()` directly in the component body:

- It will run on **every render**
- Infinite loop risk

`useEffect` lets you control **when** the API call runs.

---

#### 3. Meaning of empty dependency array `[]`

```js
}, []);
```

This means:

- Run effect **only once**
- When component is mounted for the first time

Equivalent to:

> “Call API when page loads”

---

#### 4. Flow of execution (VERY IMPORTANT)

1. Component renders first time
   - `users = []`
   - UI shows empty list

2. `useEffect` runs after render
3. `fetch()` gets data
4. `setUsers(data)` updates state
5. Component re-renders
6. `users.map(...)` now prints names

---

#### 5. Why `map()` is used

```js
users.map((user) => <li key={user.id}>{user.name}</li>);
```

- `users` is an array
- `map()` converts array → JSX list
- `key` helps React track items efficiently

---

#### Common Beginner Mistakes (you avoided)

- Calling API outside `useEffect`
- Forgetting empty dependency array
- Not using `key` in lists
- Trying to access `users.name` instead of looping

---

#### One-Line Summary (Interview Ready)

> `useEffect` with empty dependency array is used to fetch API data once when the component mounts, store it using `useState`, and re-render the UI with the fetched data.

---

## ✅ Example 4: Timer + Cleanup

### Use case: Clock / Countdown

**Effect4_Timer.jsx**

```jsx
import { useState, useEffect } from "react";

function Effect4_Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setSeconds((prev) => prev + 1);
    }, 1000);

    // Cleanup function
    return () => clearInterval(timer);
  }, []);

  return (
    <div>
      <h3>Example 4: Timer</h3>
      <p>Seconds: {seconds}</p>
    </div>
  );
}

export default Effect4_Timer;
```

Cleanup is important to avoid memory leaks.

---

# Add All Effects To App.jsx

**App.jsx**

```jsx
import Effect1_PageLoad from "./components/Effect1_PageLoad";
import Effect2_Dependency from "./components/Effect2_Dependency";
import Effect3_API from "./components/Effect3_API";
import Effect4_Timer from "./components/Effect4_Timer";

function App() {
  return (
    <div>
      <h1>useEffect Real Examples</h1>

      <Effect1_PageLoad />
      <hr />

      <Effect2_Dependency />
      <hr />

      <Effect3_API />
      <hr />

      <Effect4_Timer />
    </div>
  );
}

export default App;
```

---

# Key Understanding

Dependency array controls WHEN effect runs.

| Dependency | Behaviour              |
| ---------- | ---------------------- |
| none       | Runs every render      |
| []         | Runs once              |
| [data]     | Runs when data changes |

---

# Real World Mapping

useEffect replaces:

- componentDidMount
- componentDidUpdate
- componentWillUnmount

All in ONE hook.

---

# Mental Model

```
Render UI
↓
useEffect listens
↓
Runs side effect
↓
Updates state if needed
↓
Re-render
```

---

## Quick Check

Tell me:

Which useEffect will run only once?

A)

```js
useEffect(() => {}, []);
```

B)

```js
useEffect(() => {});
```
