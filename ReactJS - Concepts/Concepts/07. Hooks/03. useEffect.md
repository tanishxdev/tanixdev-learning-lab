
# useEffect Hook – Lifecycle + Side Effects (Step-by-step Understanding)

We will follow the same style as useState:
Simple → Clear → Real → Progressive difficulty.

---

## 1. First Understand: What problem does useEffect solve?

React components re-render when state changes.
But sometimes we want to run **extra logic automatically** like:

* Fetch data from API
* Run code when page loads
* Sync data with localStorage
* Add event listeners
* Start timers
* Clean resources

These are called:

> Side Effects

And React gives useEffect to handle them.

---

## 2. Simple Definition

> useEffect lets you run code automatically after rendering.

It connects your component to the outside world.

---

## 3. Think like this

useState → controls data
useEffect → reacts to data changes

---

## 4. Basic Syntax

```js
useEffect(() => {
   // side effect logic
}, [dependencies]);
```

Structure:

* First parameter → function to run
* Second parameter → when to run

---

# The 3 Behaviour Types of useEffect

## TYPE 1: Runs on every render

```js
useEffect(() => {
  console.log("Runs every time");
});
```

No dependency array → always executes.

---

## TYPE 2: Runs only once (on page load)

```js
useEffect(() => {
  console.log("Runs only once");
}, []);
```

Empty array → componentDidMount behaviour.

---

## TYPE 3: Runs when specific value changes

```js
useEffect(() => {
  console.log("Runs when count changes");
}, [count]);
```

Runs only when `count` updates.

---

# Progressive Real Examples

Folder structure remains:

```
src/
  components/
    Effect1_PageLoad.jsx
    Effect2_Dependency.jsx
    Effect3_API.jsx
    Effect4_Timer.jsx
  App.jsx
```

---

## ✅ Example 1: Run code on page load

### Use case: Welcome / Initialization

**Effect1_PageLoad.jsx**

```jsx
import { useEffect } from "react";

function Effect1_PageLoad() {

  useEffect(() => {
    console.log("Component Mounted - Page Loaded");
  }, []);

  return (
    <div>
      <h3>Example 1: Page Load Effect</h3>
      <p>Check console to see effect</p>
    </div>
  );
}

export default Effect1_PageLoad;
```

What happens:

* Runs once when component loads
* Similar to: componentDidMount

---

## ✅ Example 2: Based on State Change

### Use case: React when count changes

**Effect2_Dependency.jsx**

```jsx
import { useState, useEffect } from "react";

function Effect2_Dependency() {

  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Count changed to:", count);
  }, [count]);

  return (
    <div>
      <h3>Example 2: Dependency Effect</h3>
      <p>Count: {count}</p>

      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>
    </div>
  );
}

export default Effect2_Dependency;
```

Here:

* Effect only runs when count changes
* Logs each update

---

## ✅ Example 3: Fetch Data (Real-world API case)

### Use case: Load data when page opens

**Effect3_API.jsx**

```jsx
import { useState, useEffect } from "react";

function Effect3_API() {

  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []);

  return (
    <div>
      <h3>Example 3: API Data</h3>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default Effect3_API;
```

This is real:

* Dashboard data
* User list
* Product list

---

## ✅ Example 4: Timer + Cleanup

### Use case: Clock / Countdown

**Effect4_Timer.jsx**

```jsx
import { useState, useEffect } from "react";

function Effect4_Timer() {

  const [seconds, setSeconds] = useState(0);

  useEffect(() => {

    const timer = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);

    // Cleanup function
    return () => clearInterval(timer);

  }, []);

  return (
    <div>
      <h3>Example 4: Timer</h3>
      <p>Seconds: {seconds}</p>
    </div>
  );
}

export default Effect4_Timer;
```

Cleanup is important to avoid memory leaks.

---

# Add All Effects To App.jsx

**App.jsx**

```jsx
import Effect1_PageLoad from "./components/Effect1_PageLoad";
import Effect2_Dependency from "./components/Effect2_Dependency";
import Effect3_API from "./components/Effect3_API";
import Effect4_Timer from "./components/Effect4_Timer";

function App() {
  return (
    <div>
      <h1>useEffect Real Examples</h1>

      <Effect1_PageLoad />
      <hr />

      <Effect2_Dependency />
      <hr />

      <Effect3_API />
      <hr />

      <Effect4_Timer />
    </div>
  );
}

export default App;
```

---

# Key Understanding

Dependency array controls WHEN effect runs.

| Dependency | Behaviour              |
| ---------- | ---------------------- |
| none       | Runs every render      |
| []         | Runs once              |
| [data]     | Runs when data changes |

---

# Real World Mapping

useEffect replaces:

* componentDidMount
* componentDidUpdate
* componentWillUnmount

All in ONE hook.

---

# Mental Model

```
Render UI
↓
useEffect listens
↓
Runs side effect
↓
Updates state if needed
↓
Re-render
```

---

## Quick Check

Tell me:

Which useEffect will run only once?

A)

```js
useEffect(() => { }, []);
```

B)

```js
useEffect(() => { });
```
