# 12.5 COMMON FORM PATTERNS

These patterns appear in **every real app**, regardless of the industry:

* Authentication
* Checkout forms
* Search bars
* Multi-step forms
* Address forms
* Payment forms (card, CVV, expiry)
* Profile editors

We will cover the essential patterns used in production, with clean examples.

---

# PATTERNS WE WILL COVER

1. Controlled vs Uncontrolled Hybrid Pattern
2. handleChange and handleBlur Pattern
3. Disable Submit Button Until Valid
4. Dynamic Field Validation
5. Auto-formatting Input (Phone, Card Number)
6. Debounced Search Input
7. Showing Validation Only After User Interaction
8. Error Clearing Pattern
9. Controlled Textarea Pattern
10. Password Show/Hide Pattern

We will go through them one by one.

---

# 1. Controlled + Uncontrolled Hybrid Pattern

Best for large forms where some fields need real-time control and others don’t.

Example:

* Email (needs real-time validation) → controlled
* Name (simple) → uncontrolled
* Profile bio (big text) → uncontrolled
* Password → controlled

Create file:

`Pattern1_Hybrid.jsx`

```jsx
import { useRef, useState } from "react";

export default function Pattern1_Hybrid() {
  const nameRef = useRef(); // uncontrolled
  const [email, setEmail] = useState(""); // controlled

  const handleSubmit = () => {
    console.log({
      name: nameRef.current.value,
      email
    });
  };

  return (
    <div>
      <h3>Hybrid Form Pattern</h3>

      <input ref={nameRef} placeholder="Name (uncontrolled)" />

      <input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email (controlled)"
      />

      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}
```

This improves **performance** and **control**.

---

# 2. handleChange + handleBlur Pattern

Companies use this pattern to:

* Track touched fields
* Show errors only after blur
* Manage complex UI interactions

Create file:

`Pattern2_ChangeBlur.jsx`

```jsx
import { useState } from "react";

export default function Pattern2_ChangeBlur() {
  const [form, setForm] = useState({ email: "" });
  const [touched, setTouched] = useState({});

  const emailValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(form.email);

  const handleChange = (e) => {
    setForm({ ...form, email: e.target.value });
  };

  const handleBlur = (e) => {
    setTouched({ ...touched, [e.target.name]: true });
  };

  return (
    <div>
      <h3>handleChange + handleBlur Pattern</h3>

      <input
        name="email"
        placeholder="Email"
        value={form.email}
        onChange={handleChange}
        onBlur={handleBlur}
      />

      {!emailValid && touched.email && (
        <p style={{ color: "red" }}>Invalid email</p>
      )}
    </div>
  );
}
```

This prevents showing errors too early.

---

# 3. Disable Submit Button Until Valid

`Pattern3_DisableSubmit.jsx`

```jsx
import { useState } from "react";

export default function Pattern3_DisableSubmit() {
  const [email, setEmail] = useState("");

  const valid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

  return (
    <div>
      <h3>Disable Submit Until Valid</h3>

      <input
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />

      <button disabled={!valid}>Continue</button>
    </div>
  );
}
```

Common for:

* OTP
* Login
* Signup
* Checkout
* Payment

---

# 4. Dynamic Field Validation

Validation that updates based on earlier inputs.

Example: Show confirm password only after user enters password.

`Pattern4_DynamicFields.jsx`

```jsx
import { useState } from "react";

export default function Pattern4_DynamicFields() {
  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");

  const showConfirm = password.length >= 6;

  return (
    <div>
      <h3>Dynamic Field Validation</h3>

      <input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />

      {showConfirm && (
        <>
          <input
            type="password"
            placeholder="Confirm Password"
            value={confirm}
            onChange={(e) => setConfirm(e.target.value)}
          />

          {confirm && confirm !== password && (
            <p style={{ color: "red" }}>Passwords do not match</p>
          )}
        </>
      )}
    </div>
  );
}
```

This is used in signup forms often.

---

# 5. Auto-formatting Input (Phone Number)

We now automatically add hyphens:

`Pattern5_AutoFormatPhone.jsx`

```jsx
import { useState } from "react";

export default function Pattern5_AutoFormatPhone() {
  const [phone, setPhone] = useState("");

  const formatPhone = (value) => {
    return value
      .replace(/\D/g, "")
      .replace(/(\d{3})(\d{3})(\d{0,4})/, "$1-$2-$3")
      .trim();
  };

  const handleChange = (e) => {
    setPhone(formatPhone(e.target.value));
  };

  return (
    <div>
      <h3>Auto-format Phone Number</h3>

      <input
        maxLength={12}
        value={phone}
        onChange={handleChange}
        placeholder="123-456-7890"
      />
    </div>
  );
}
```

This is used in checkout and payment forms.

---

# 6. Debounced Search Input (Important for Performance)

Debouncing prevents API calls on each keystroke.

`Pattern6_DebouncedSearch.jsx`

```jsx
import { useState, useEffect } from "react";

export default function Pattern6_DebouncedSearch() {
  const [query, setQuery] = useState("");
  const [debounced, setDebounced] = useState("");

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebounced(query);
    }, 500);

    return () => clearTimeout(timer);
  }, [query]);

  useEffect(() => {
    if (debounced) {
      console.log("Search API called with:", debounced);
    }
  }, [debounced]);

  return (
    <div>
      <h3>Debounced Search</h3>

      <input
        placeholder="Search..."
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
    </div>
  );
}
```

Used in:

* Search bars
* Filters
* Autocomplete boxes
* E-commerce

---

# 7. Show Error Only After User Interaction

Common UX rule: do not show error until the user types something.

`Pattern7_ErrorOnTouch.jsx`

```jsx
import { useState } from "react";

export default function Pattern7_ErrorOnTouch() {
  const [value, setValue] = useState("");
  const [touched, setTouched] = useState(false);

  const invalid = value.trim() === "";

  return (
    <div>
      <h3>Error Only After Touch</h3>

      <input
        value={value}
        onChange={(e) => setValue(e.target.value)}
        onBlur={() => setTouched(true)}
        placeholder="Name"
      />

      {touched && invalid && (
        <p style={{ color: "red" }}>Name is required</p>
      )}
    </div>
  );
}
```

---

# 8. Error Clearing Pattern

Clear message when input becomes valid again.

`Pattern8_ErrorClearing.jsx`

```jsx
import { useState } from "react";

export default function Pattern8_ErrorClearing() {
  const [value, setValue] = useState("");
  const [error, setError] = useState("");

  const handleChange = (e) => {
    const v = e.target.value;
    setValue(v);

    if (v.trim() === "") setError("Required");
    else setError("");
  };

  return (
    <div>
      <h3>Error Clearing Pattern</h3>

      <input value={value} onChange={handleChange} />

      {error && <p style={{ color: "red" }}>{error}</p>}
    </div>
  );
}
```

---

# 9. Controlled Textarea Pattern

`Pattern9_Textarea.jsx`

```jsx
import { useState } from "react";

export default function Pattern9_Textarea() {
  const [bio, setBio] = useState("");

  return (
    <div>
      <h3>Controlled Textarea</h3>

      <textarea
        rows={4}
        value={bio}
        onChange={(e) => setBio(e.target.value)}
        placeholder="Write something..."
      />
    </div>
  );
}
```

---

# 10. Password Show/Hide Pattern

Common in signup and login forms.

`Pattern10_ShowHidePassword.jsx`

```jsx
import { useState } from "react";

export default function Pattern10_ShowHidePassword() {
  const [visible, setVisible] = useState(false);
  const [password, setPassword] = useState("");

  return (
    <div>
      <h3>Password Show/Hide Pattern</h3>

      <input
        type={visible ? "text" : "password"}
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />

      <button type="button" onClick={() => setVisible(!visible)}>
        {visible ? "Hide" : "Show"}
      </button>
    </div>
  );
}
```

---

# Summary of Form Patterns

You learned the **10 most common patterns** used in real-world forms:

* Hybrid controlled/uncontrolled
* Change + Blur
* Disable submit until valid
* Dynamic fields
* Auto-formatting
* Debouncing
* Error after touch
* Error clearing
* Textarea control
* Show/hide password

You now understand 80 percent of enterprise form logic.

---
