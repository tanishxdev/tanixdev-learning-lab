# 14.4 HOOKS LAYER (Custom Hooks Architecture)

This layer is extremely important because **custom hooks** allow you to separate logic from UI.

React UI = presentation
Hooks = logic

Modern React apps depend heavily on custom hooks.

Let’s go step-by-step.

---

# 1. What is the Hooks Layer?

Hooks layer is where you store **reusable logic** that multiple components or pages need.

Folder:

```
src/hooks/
    useToggle.js
    useFetch.js
    useLocalStorage.js
    useDebounce.js
    useAuth.js
    useTheme.js
```

Hooks are NOT UI components.

They are pure logic.

---

# 2. Why Do We Need Custom Hooks?

To avoid repeating logic.

For example:

You fetch data in:

- HomePage
- ProductPage
- DashboardPage

You don’t want to copy the same fetch logic into every file.

Instead, create a hook:

```
useFetch(url)
```

This reduces:

- Duplicate code
- Complexity
- Bugs
- Maintenance problems

Custom hooks follow the **DRY Principle**:
Do Not Repeat Yourself.

---

# 3. Rules of Custom Hooks

1. Hook name must start with "use"
2. Hooks can use state and effects
3. Hooks cannot return JSX
4. Hooks cannot be called inside loops or conditions
5. Hooks are only for logic, not UI

---

# 4. Example 1: useToggle

A very common reusable hook.

File: `src/hooks/useToggle.js`

```jsx
import { useState } from "react";

export default function useToggle(initial = false) {
  const [value, setValue] = useState(initial);

  const toggle = () => setValue((v) => !v);

  return [value, toggle];
}
```

Use it in any component:

```jsx
const [isOpen, toggleOpen] = useToggle();
```

Now you can toggle:

- Modal
- Sidebar
- Dropdown
- Accordion

Reusable logic.

---

# 5. Example 2: useFetch (Reusable API Hook)

File: `useFetch.js`

```jsx
import { useEffect, useState } from "react";

export default function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);

    fetch(url)
      .then((res) => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);

  return { data, loading, error };
}
```

Use it:

```jsx
const { data, loading, error } = useFetch("https://fakestoreapi.com/products");
```

You can reuse this everywhere.

---

# 6. Example 3: useLocalStorage

Used in:

- Theme saving
- Cart saving
- Auth tokens
- Saved preferences

File: `useLocalStorage.js`

```jsx
import { useState, useEffect } from "react";

export default function useLocalStorage(key, initial) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initial;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}
```

Use it:

```jsx
const [theme, setTheme] = useLocalStorage("theme", "light");
```

---

# 7. Example 4: useDebounce

Used in search bars (API calls):

File: `useDebounce.js`

```jsx
import { useState, useEffect } from "react";

export default function useDebounce(value, delay = 500) {
  const [debounced, setDebounced] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebounced(value), delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debounced;
}
```

Use:

```jsx
const debouncedQuery = useDebounce(query, 600);
```

---

# 8. Example 5: useAuth (Authentication Logic Hook)

File: `useAuth.js`

```jsx
import { useContext } from "react";
import { AuthContext } from "../context/AuthContext";

export default function useAuth() {
  return useContext(AuthContext);
}
```

Use:

```jsx
const { user, login, logout } = useAuth();
```

This keeps auth logic separate from pages.

---

# 9. Summary: Why Hooks Layer Is Powerful

Hooks let you:

- Separate business logic from UI
- Reuse logic across components
- Keep components clean
- Improve code maintainability
- Reduce duplication
- Build scalable architecture

Hooks are the **logic brain** of your React app.
