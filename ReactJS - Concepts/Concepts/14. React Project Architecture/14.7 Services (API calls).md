

# 14.7 SERVICES LAYER

This layer handles **all API communication**, and is critical for clean, scalable, professional code.

If you do this wrong, your project becomes:

* Hard to maintain
* Difficult to debug
* Scattered with API calls
* Prone to duplication
* Impossible to scale

If you do this right, your project becomes:

* Clean
* Organized
* Scalable
* Easy to extend
* Professional-quality

Let’s break it down clearly and slowly.

---

# 1. What is the Services Layer?

Service layer contains **all API communication logic**, separated from components.

A service:

* Makes API calls
* Handles errors
* Sends data to server
* Performs CRUD operations
* Acts as a middle layer between UI and backend

Folder structure:

```
src/services/
    authService.js
    productService.js
    cartService.js
    userService.js
    apiClient.js
```

---

# 2. Why API Calls Should NOT Be Inside Components

Bad example inside ProductPage.jsx:

```jsx
useEffect(() => {
  fetch("/api/products")
    .then(res => res.json())
    .then(setProducts);
}, []);
```

Problems:

* Hard to reuse
* Cannot test
* Mixed UI + data logic
* Difficult to maintain when app grows
* Must rewrite logic everywhere

Professional apps NEVER put API logic inside components.

---

# 3. Create an HTTP Client (Recommended)

Using axios is industry standard:

Install:

```
npm install axios
```

Create `src/services/apiClient.js`

```jsx
import axios from "axios";

export const api = axios.create({
  baseURL: "https://fakestoreapi.com"
});
```

Optionally add interceptors later (auth tokens, errors).

---

# 4. Build Feature-based Services

Each feature gets its own service file.

## Example: Product Service

`src/services/productService.js`

```jsx
import { api } from "./apiClient";

export const getProducts = () => api.get("/products");
export const getProductById = (id) => api.get(`/products/${id}`);
```

## Example: Auth Service

`src/services/authService.js`

```jsx
import { api } from "./apiClient";

export const loginUser = (data) => api.post("/auth/login", data);
export const registerUser = (data) => api.post("/auth/register", data);
```

## Example: Cart Service

`src/services/cartService.js`

```jsx
import { api } from "./apiClient";

export const getCart = (userId) => api.get(`/carts/${userId}`);
export const addToCart = (data) => api.post("/carts", data);
```

Now your UI does not know anything about API structure.

---

# 5. Using Services Inside Components

This keeps components clean.

Example: ProductPage.jsx

```jsx
import { useEffect, useState } from "react";
import { getProducts } from "../services/productService";

export default function ProductPage() {
  const [products, setProducts] = useState([]);

  useEffect(() => {
    getProducts().then((res) => setProducts(res.data));
  }, []);

  return (
    <div>
      <h2>Products</h2>
      {products.map((p) => (
        <div key={p.id}>{p.title}</div>
      ))}
    </div>
  );
}
```

No API URLs here.
No fetch logic here.
Only UI logic.

---

# 6. Error Handling in Services

Improve services by handling errors:

```jsx
import { api } from "./apiClient";

export async function getProducts() {
  try {
    const res = await api.get("/products");
    return res.data;
  } catch (err) {
    console.error("Failed to get products:", err);
    throw err;
  }
}
```

Now components only catch the final error:

```jsx
useEffect(() => {
  getProducts().then(setProducts).catch(() => alert("Error"));
}, []);
```

---

# 7. Centralized API Client (Advanced Setup)

Add interceptors for auth:

`src/services/apiClient.js`

```jsx
import axios from "axios";

export const api = axios.create({
  baseURL: "https://fakestoreapi.com"
});

// add token
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});

// handle global errors
api.interceptors.response.use(
  (res) => res,
  (err) => {
    if (err.response?.status === 401) {
      console.log("Unauthorized");
    }
    return Promise.reject(err);
  }
);
```

Now:

* All HTTP requests automatically include token
* Error handling is centralized
* No repetition in services

This is real-world quality.

---

# 8. Services in Feature-Based Architecture

Modern best practice:

```
src/features/products/
    ProductPage.jsx
    productService.js
    productSlice.js
```

Feature folder contains:

* UI
* Service
* State slice

Clean and maintainable.

---

# 9. Summary of the Services Layer

You learned:

* Why API logic must be separated
* How to build an axios apiClient
* Feature-based services
* Clean API functions
* Error handling
* Proper architecture for scalable apps

Services layer is your app’s connection to the backend.
Building it correctly is crucial.

