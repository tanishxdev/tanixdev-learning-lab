# 14.10 ROUTER LAYER (Deep Architecture)

Many developers only know basic React Router, but **real-world apps require a router architecture**, not just inline routes in App.jsx.

A dedicated router layer improves:

* Organization
* Scalability
* Maintainability
* Route security
* Layout handling
* Performance (lazy loading)

We will build this step-by-step.

---

# 1. Why the Router Should Be in a Separate File?

Beginners put routes inside `App.jsx`:

```jsx
<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/products" element={<Products />} />
    <Route path="/profile" element={<Profile />} />
  </Routes>
</BrowserRouter>
```

This becomes a problem:

* Hard to maintain when app grows
* App.jsx becomes cluttered
* Difficult to manage layouts
* No separation of concerns
* Hard to create protected routes
* No lazy loading

Professional apps use:

```
src/router/AppRouter.jsx
```

This keeps routing logic in its own layer.

---

# 2. Folder Structure for Router Layer

```
src/router/
    AppRouter.jsx
    routes.js               (optional)
    ProtectedRoute.jsx
    AuthRoutes.jsx
    PublicRoutes.jsx
```

This is used in large-scale apps.

---

# 3. Example: AppRouter.jsx (Core Router File)

`src/router/AppRouter.jsx`

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";

import PublicLayout from "../layouts/PublicLayout";
import DashboardLayout from "../layouts/DashboardLayout";

import HomePage from "../pages/HomePage";
import LoginPage from "../pages/LoginPage";
import DashboardPage from "../pages/DashboardPage";
import ProfilePage from "../pages/ProfilePage";

export default function AppRouter() {
  return (
    <BrowserRouter>
      <Routes>

        {/* Public Routes */}
        <Route element={<PublicLayout />}>
          <Route path="/" element={<HomePage />} />
          <Route path="/login" element={<LoginPage />} />
        </Route>

        {/* Dashboard Routes */}
        <Route element={<DashboardLayout />}>
          <Route path="/dashboard" element={<DashboardPage />} />
          <Route path="/profile" element={<ProfilePage />} />
        </Route>

      </Routes>
    </BrowserRouter>
  );
}
```

This is clean and scalable.

---

# 4. Protected Routes (Route Guards)

Every real app has:

* Dashboard
* Profile
* Orders

These should only be accessible if logged in.

Create:

`src/router/ProtectedRoute.jsx`

```jsx
import { Navigate } from "react-router-dom";
import useAuth from "../hooks/useAuth";

export default function ProtectedRoute({ children }) {
  const { user } = useAuth();

  if (!user) return <Navigate to="/login" replace />;

  return children;
}
```

Use in router:

```jsx
<Route
  path="/dashboard"
  element={
    <ProtectedRoute>
      <DashboardPage />
    </ProtectedRoute>
  }
/>
```

Now Dashboard is locked.

---

# 5. PublicRoute (Prevent logged-in users from going to login again)

Example:

```
If user is already logged in â†’ redirect from /login to /dashboard
```

`src/router/PublicRoute.jsx`

```jsx
import { Navigate } from "react-router-dom";
import useAuth from "../hooks/useAuth";

export default function PublicRoute({ children }) {
  const { user } = useAuth();

  if (user) return <Navigate to="/dashboard" replace />;

  return children;
}
```

Router:

```jsx
<Route
  path="/login"
  element={
    <PublicRoute>
      <LoginPage />
    </PublicRoute>
  }
/>
```

---

# 6. Lazy Loading (Code Splitting for Performance)

Large apps require lazy loading.

Example:

```jsx
import { lazy, Suspense } from "react";

const HomePage = lazy(() => import("../pages/HomePage"));
const DashboardPage = lazy(() => import("../pages/DashboardPage"));
```

Modify AppRouter:

```jsx
<Suspense fallback={<div>Loading...</div>}>
  <Routes>
    <Route path="/" element={<HomePage />} />
    <Route path="/dashboard" element={<DashboardPage />} />
  </Routes>
</Suspense>
```

This improves performance by loading pages only when needed.

---

# 7. Nested Routes in Router Layer

Dashboard layouts usually contain nested pages:

```
/dashboard
/dashboard/profile
/dashboard/orders
/dashboard/settings
```

Router:

```jsx
<Route element={<DashboardLayout />}>
  <Route path="/dashboard" element={<DashboardHome />} />
  <Route path="/dashboard/profile" element={<ProfilePage />} />
  <Route path="/dashboard/orders" element={<OrdersPage />} />
  <Route path="/dashboard/settings" element={<SettingsPage />} />
</Route>
```

DashboardLayout must have:

```jsx
<Outlet />
```

---

# 8. Route Configuration File (Optional Advanced Pattern)

Instead of hardcoding routes:

`src/router/routes.js`

```jsx
export const routes = [
  {
    path: "/",
    element: "HomePage",
    layout: "PublicLayout"
  },
  {
    path: "/dashboard",
    element: "DashboardPage",
    layout: "DashboardLayout"
  }
];
```

Useful for very large teams.

---

# 9. 404 Route (Not Found)

Always add this:

```jsx
<Route path="*" element={<h2>Page Not Found</h2>} />
```

---

# 10. Summary of Router Layer

You now understand:

* Why routing belongs in a separate layer
* AppRouter architecture
* Layout-based routing
* Protected routes
* Public routes
* Lazy loading
* Nested routes
* Clean, scalable routing

This is exactly how professional React apps structure routing.
