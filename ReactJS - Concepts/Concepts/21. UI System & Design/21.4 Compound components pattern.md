# **21.4 Compound Components Pattern**

A complete, production-grade explanation of **the Compound Components Pattern**, why modern UI libraries use it, how it solves the “prop explosion problem”, how it enables flexible and scalable UI systems, how to implement it with context, and how to build real components like Tabs, Modal, Dropdown, Accordion using this pattern.

This chapter focuses entirely on **React design-system architecture**.

---

# 1. What Are Compound Components?

Compound Components are a group of components that **work together as a single unit** and share state internally.

Example:

```jsx
<Tabs>
  <Tabs.List>
    <Tabs.Trigger>Tab 1</Tabs.Trigger>
    <Tabs.Trigger>Tab 2</Tabs.Trigger>
  </Tabs.List>

  <Tabs.Content>Content 1</Tabs.Content>
</Tabs>
```

You do not pass complex props.
You compose the UI using child components.

The library handles:

* communication between parts
* state sharing
* accessibility
* behavior

This pattern powers:

* Radix UI
* Headless UI
* Chakra UI
* Material UI Tabs / Accordion
* Shopify Polaris

---

# 2. What Problem Does the Pattern Solve?

### Problem: Prop Explosion

Bad API:

```jsx
<Tabs
  activeTab={1}
  onChange={setTab}
  listItems={[...]}
  tabContent={[...]}
/>
```

Too many props. Hard to scale.

### Solution: Composition

```jsx
<Tabs>
  <Tabs.List>...</Tabs.List>
  <Tabs.Content>...</Tabs.Content>
</Tabs>
```

Advantages:

* readable
* flexible
* scalable
* easier for teams
* avoids giant configuration props

UI becomes **composable**, not configurable.

---

# 3. How Compound Components Work Internally

Core idea:

* Parent component creates a **context store**
* Child components consume that context
* No props drilling
* Child position defines structure

Flow:

1. Parent sets up shared state
2. Children use state through context
3. Children render content
4. UI works as one complete component

---

# 4. Building a Simple Compound Component (Tabs Example)

## Step 1: Create context

```jsx
const TabsContext = createContext();
```

## Step 2: Parent provides context

```jsx
function Tabs({ children }) {
  const [active, setActive] = useState(0);

  return (
    <TabsContext.Provider value={{ active, setActive }}>
      <div>{children}</div>
    </TabsContext.Provider>
  );
}
```

## Step 3: Create List component

```jsx
Tabs.List = function List({ children }) {
  return <div className="flex gap-2">{children}</div>;
};
```

## Step 4: Create Trigger component

```jsx
Tabs.Trigger = function Trigger({ index, children }) {
  const { active, setActive } = useContext(TabsContext);

  return (
    <button
      className={active === index ? "font-bold" : "text-gray-500"}
      onClick={() => setActive(index)}
    >
      {children}
    </button>
  );
};
```

## Step 5: Create Content component

```jsx
Tabs.Content = function Content({ index, children }) {
  const { active } = useContext(TabsContext);

  if (active !== index) return null;

  return <div className="mt-4">{children}</div>;
};
```

## Usage:

```jsx
<Tabs>
  <Tabs.List>
    <Tabs.Trigger index={0}>General</Tabs.Trigger>
    <Tabs.Trigger index={1}>Billing</Tabs.Trigger>
  </Tabs.List>

  <Tabs.Content index={0}>General Settings</Tabs.Content>
  <Tabs.Content index={1}>Billing Settings</Tabs.Content>
</Tabs>
```

This is the foundation of compound components.

---

# 5. Building a Modal With Compound Components

## Modal system:

```jsx
function Modal({ children, open, onClose }) {
  if (!open) return null;

  return (
    <div className="backdrop" onClick={onClose}>
      <div className="modal" onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
}

Modal.Header = ({ children }) => (
  <div className="border-b pb-2 font-semibold">{children}</div>
);

Modal.Body = ({ children }) => <div className="py-4">{children}</div>;

Modal.Footer = ({ children }) => (
  <div className="border-t pt-2 flex justify-end gap-2">
    {children}
  </div>
);
```

Usage:

```jsx
<Modal open={isOpen} onClose={close}>
  <Modal.Header>Delete File</Modal.Header>
  <Modal.Body>Are you sure?</Modal.Body>
  <Modal.Footer>
    <Button>Cancel</Button>
    <Button>Delete</Button>
  </Modal.Footer>
</Modal>
```

Each section is composable and flexible.

---

# 6. Dropdown Using Compound Components

Parent with context:

```jsx
const DropdownContext = createContext();

function Dropdown({ children }) {
  const [open, setOpen] = useState(false);

  return (
    <DropdownContext.Provider value={{ open, setOpen }}>
      <div className="relative">{children}</div>
    </DropdownContext.Provider>
  );
}
```

Trigger:

```jsx
Dropdown.Trigger = function Trigger({ children }) {
  const { open, setOpen } = useContext(DropdownContext);

  return (
    <button onClick={() => setOpen(!open)}>
      {children}
    </button>
  );
};
```

Menu:

```jsx
Dropdown.Menu = function Menu({ children }) {
  const { open } = useContext(DropdownContext);

  if (!open) return null;

  return (
    <div className="absolute mt-2 bg-white shadow p-2 rounded">
      {children}
    </div>
  );
};
```

Item:

```jsx
Dropdown.Item = function Item({ children, onSelect }) {
  return (
    <button className="block w-full text-left" onClick={onSelect}>
      {children}
    </button>
  );
};
```

Usage:

```jsx
<Dropdown>
  <Dropdown.Trigger>Actions</Dropdown.Trigger>

  <Dropdown.Menu>
    <Dropdown.Item onSelect={() => console.log("Edit")}>
      Edit
    </Dropdown.Item>
    <Dropdown.Item onSelect={() => console.log("Delete")}>
      Delete
    </Dropdown.Item>
  </Dropdown.Menu>
</Dropdown>
```

This is how real UI systems are built.

---

# 7. Why Teams Use Compound Components

### 1. Highly flexible

Users decide layout and structure.

### 2. Predictable internal state

State is controlled at parent and consumed by children.

### 3. Customizable

Developers can add icons, wrappers, tooltips.

### 4. No prop explosion

Complex UI behavior, simple API.

### 5. Works with any styling solution

Tailwind, Styled-components, Emotion, CSS Modules, vanilla CSS.

### 6. Design system friendly

This pattern produces scalable APIs.

---

# 8. Important Supporting Concepts

### 1. React Context

Enables communication between child components.

### 2. React.Children

Useful for filtering or validating children.

### 3. Component identity

Attaching children via properties:

```jsx
Tabs.Trigger = ...
Tabs.Content = ...
```

### 4. Controlled vs uncontrolled

Parent controls active state.

---

# 9. Anti-patterns

Avoid:

1. Using too many nested contexts
2. Making child components depend on the DOM of siblings
3. Making compound components too opinionated
4. Mixing layout + behavior in the root component
5. Passing too many props to children (breaks pattern)

Correct design keeps behavior in the parent, layout in children.

---

# 10. Full Production Example: Stepper Component

Parent:

```jsx
const StepContext = createContext();

function Steps({ children, active }) {
  return (
    <StepContext.Provider value={{ active }}>
      <div>{children}</div>
    </StepContext.Provider>
  );
}
```

Child:

```jsx
Steps.Step = function Step({ index, children }) {
  const { active } = useContext(StepContext);

  return (
    <div className={index === active ? "font-bold" : "opacity-50"}>
      {children}
    </div>
  );
};
```

Usage:

```jsx
<Steps active={1}>
  <Steps.Step index={0}>Account</Steps.Step>
  <Steps.Step index={1}>Billing</Steps.Step>
  <Steps.Step index={2}>Review</Steps.Step>
</Steps>
```

This pattern scales extremely well.

---

# 11. Follow-up Questions

1. Which components in your app can benefit from the compound pattern?
2. Are you currently facing prop explosion in any UI components?
3. Do you need Tabs, Modal, Dropdown, or Stepper systems?
4. Would your design system benefit from context-based communication?
5. Should your UI framework be built with compound components?
6. How much flexibility do you want to give developers using your components?
7. Are some components mixing layout with behavior incorrectly?
8. Do you need accessible compound components (ARIA roles)?
9. Should variants be implemented using props or composition?
10. Do you want examples for Radix-style or Material-UI-style patterns?
