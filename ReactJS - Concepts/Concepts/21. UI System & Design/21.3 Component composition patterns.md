# **21.3 Component Composition Patterns**

A complete, production-grade explanation of **how to architect reusable, scalable, flexible UI components in React using composition**, why composition is preferred over inheritance, how patterns like “Children”, “Slots”, “Layout Wrappers”, “Render Props”, and “Component Injection” work, and how they are used to build real design systems.

This chapter focuses on **React UI engineering**, not just patterns.

---

# 1. What Is Component Composition?

Composition means **building UI by combining small, independent components** instead of creating monolithic, deeply configured components.

React encourages:

```
Compose → override → extend
Not configure → mutate → inherit
```

Composition leads to:

* reusable components
* flexible UI systems
* separation of concerns
* more maintainable code
* predictable architecture

This is foundational to professional React design systems.

---

# 2. Why Composition Instead of Props Explosion?

Bad pattern: “props explosion”

```jsx
<Card
  title="Hi"
  showBorder
  shadowType="lg"
  padding="md"
  rounded="lg"
  textColor="gray"
  align="center"
  layout="horizontal"
  iconLeft
/>
```

This leads to:

* too many props
* brittle API
* unreadable components
* limited customizability

Composition solves this by letting developers **assemble UI** instead of configuring every detail.

---

# 3. Pattern 1: Children Composition (Most Important)

This is the simplest and most powerful pattern.

Component:

```jsx
function Card({ children }) {
  return <div className="p-4 border rounded">{children}</div>;
}
```

Usage:

```jsx
<Card>
  <h1>Title</h1>
  <p>Description</p>
</Card>
```

Benefits:

* infinite flexibility
* reusable structure
* UI elements can be arranged freely

This is the core of React’s composition model.

---

# 4. Pattern 2: Component Slots (Named Children)

Useful when children need predefined positions.

Example: Modal

```jsx
function Modal({ Header, Body, Footer }) {
  return (
    <div className="modal">
      <div>{Header}</div>
      <div>{Body}</div>
      <div>{Footer}</div>
    </div>
  );
}
```

Usage:

```jsx
<Modal
  Header={<h1>Confirm</h1>}
  Body={<p>Are you sure?</p>}
  Footer={<button>Yes</button>}
/>
```

This is similar to Vue/Angular slots.

---

# 5. Pattern 3: Compound Components (Advanced)

Used in major UI libraries (Radix UI, Headless UI).

Example:

```jsx
function Tabs({ children }) {
  return <div>{children}</div>;
}

Tabs.List = function List({ children }) {
  return <div className="flex">{children}</div>;
};

Tabs.Trigger = function Trigger({ children }) {
  return <button className="px-3 py-1">{children}</button>;
};

Tabs.Content = function Content({ children }) {
  return <div className="mt-4">{children}</div>;
};
```

Usage:

```jsx
<Tabs>
  <Tabs.List>
    <Tabs.Trigger>Tab 1</Tabs.Trigger>
    <Tabs.Trigger>Tab 2</Tabs.Trigger>
  </Tabs.List>

  <Tabs.Content>Content for Tab</Tabs.Content>
</Tabs>
```

Benefits:

* intuitive API
* highly scalable
* structure guaranteed
* easy for teams to use

This is the foundation of design systems.

---

# 6. Pattern 4: Render Props (Behavior Injection)

Render props allow components to pass logic to children.

```jsx
function Hover({ children }) {
  const [hovered, setHovered] = useState(false);

  return children({
    hovered,
    eventHandlers: {
      onMouseEnter: () => setHovered(true),
      onMouseLeave: () => setHovered(false)
    }
  });
}
```

Usage:

```jsx
<Hover>
  {({ hovered, eventHandlers }) => (
    <div {...eventHandlers}>
      {hovered ? "Hovering" : "Not hovering"}
    </div>
  )}
</Hover>
```

Useful for:

* controlled behavior
* animation states
* reusable logic layers

---

# 7. Pattern 5: Component Injection (Dependency Injection for UI)

Parent injects a component into child.

Component:

```jsx
function List({ items, renderItem }) {
  return (
    <div>
      {items.map((item, i) => (
        <div key={i}>{renderItem(item)}</div>
      ))}
    </div>
  );
}
```

Usage:

```jsx
<List
  items={[1, 2, 3]}
  renderItem={(num) => <span>Item {num}</span>}
/>
```

Professional usage:

* custom rows in tables
* custom cards in grids
* flexible layout tools

---

# 8. Pattern 6: Layout Composition (Page Architecture Pattern)

Example:

```jsx
function PageLayout({ header, sidebar, children }) {
  return (
    <div className="grid grid-cols-[200px_1fr] min-h-screen">
      <aside>{sidebar}</aside>
      <main>
        {header}
        <div>{children}</div>
      </main>
    </div>
  );
}
```

Usage:

```jsx
<PageLayout
  header={<Header />}
  sidebar={<Sidebar />}
>
  <Dashboard />
</PageLayout>
```

Enables scalable layout architecture.

---

# 9. Pattern 7: Higher-Order Components (Legacy but still useful)

```jsx
function withLogger(Component) {
  return function Wrapper(props) {
    console.log("props:", props);
    return <Component {...props} />;
  };
}
```

Usage:

```jsx
const LoggedButton = withLogger(Button);
```

Mostly replaced by hooks, but still used in some design systems.

---

# 10. Example: Building a Real Reusable Card System

Base component:

```jsx
function Card({ children }) {
  return <div className="border p-4 rounded">{children}</div>;
}

Card.Title = function Title({ children }) {
  return <h1 className="font-bold text-xl">{children}</h1>;
};

Card.Body = function Body({ children }) {
  return <p className="text-gray-600">{children}</p>;
};

Card.Actions = function Actions({ children }) {
  return <div className="mt-4 flex gap-2">{children}</div>;
};
```

Usage:

```jsx
<Card>
  <Card.Title>Product</Card.Title>
  <Card.Body>This is a product.</Card.Body>
  <Card.Actions>
    <button>Edit</button>
    <button>Delete</button>
  </Card.Actions>
</Card>
```

This is compound components + composition combined.

---

# 11. Component Composition vs Configuration Props

Bad pattern:

```jsx
<Table
  showSearch
  searchPosition="top"
  actionAlignment="right"
  variant="large"
  hasPagination
  paginationType="numbers"
/>
```

Good pattern:

```jsx
<Table>
  <Table.Header>
    <SearchBar />
    <Actions />
  </Table.Header>
  <Table.Body>
    <Rows />
  </Table.Body>
  <Table.Footer>
    <Pagination />
  </Table.Footer>
</Table>
```

Composition reduces complexity and maximizes flexibility.

---

# 12. Composition in Design Systems (Real Companies)

This pattern is used by:

* Radix UI
* Headless UI
* Shopify Polaris
* Material UI (partially)
* Chakra UI
* Stripe Dashboard internal system

Composition is the foundation of scalable UI.

---

# 13. Anti-patterns in Composition

Avoid:

1. deeply nesting too many wrapper components
2. using composition when a simple prop is enough
3. mixing children + props unpredictably
4. passing raw elements that should be components
5. compositing unrelated responsibilities

Use composition intentionally.

---

# 14. When to Use Which Pattern

| Pattern             | Use Case                                   |
| ------------------- | ------------------------------------------ |
| Children            | Free/custom layouts                        |
| Slots               | Fixed structure with replaceable parts     |
| Compound Components | Design systems (Tabs, Modal, Dropdown)     |
| Render Props        | Behavior and state injection               |
| Component Injection | Custom rendering (tables, lists)           |
| Layout Composition  | Page-level architecture                    |
| HOC                 | Augmenting components (logging, analytics) |

Understanding these patterns is critical for advanced React.

---

# 15. Full Production Example: Modal Using Composition

```jsx
function Modal({ children }) {
  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center">
      <div className="bg-white rounded p-6">{children}</div>
    </div>
  );
}

Modal.Header = ({ children }) => (
  <div className="font-semibold text-lg border-b pb-2">{children}</div>
);

Modal.Body = ({ children }) => <div className="my-4">{children}</div>;

Modal.Footer = ({ children }) => (
  <div className="flex justify-end gap-2 border-t pt-2">{children}</div>
);
```

Usage:

```jsx
<Modal>
  <Modal.Header>Confirm</Modal.Header>
  <Modal.Body>Are you sure you want to continue?</Modal.Body>
  <Modal.Footer>
    <Button>Cancel</Button>
    <Button primary>Confirm</Button>
  </Modal.Footer>
</Modal>
```

This exact pattern is used in enterprise apps.

---

# 16. Follow-up Questions

1. Which components in your app suffer from prop explosion and should switch to composition?
2. Do you need compound components for Tabs, Accordion, Modal, Dropdown, Steps?
3. Are you mixing layout and behavior inside one component?
4. Would render props simplify your logic sharing?
5. Do you have highly repetitive UI patterns that can be abstracted into components?
6. Should your design system adopt slots or compound components?
7. Which components require custom layout injection (component injection)?
8. Are there any nested UI structures that can be flattened using composition?
9. Would layout composition simplify your page-level structure?
10. Are your UI components too rigid or too configurable?

---