# 10.4 React Reconciliation

How React decides **what to update**, **when to update**, and **how efficiently to update the UI**.

This section is the heart of React performance.
Once you understand Reconciliation, you will understand:

* Why React needs keys
* Why re-renders are cheap
* Why DOM updates are expensive
* Why React re-runs your component but updates only small DOM parts
* How optimization techniques work

We will go slow and build your understanding layer by layer.

---

# 1. What is Reconciliation?

Reconciliation is:

> The process by which React compares the Virtual DOM with the previous Virtual DOM to decide what changes should be made to the Real DOM.

In simple terms:

```
React Render → Virtual DOM (new)
Compare → Virtual DOM (old)
Find Differences → Apply only necessary updates to Real DOM
```

React never updates the entire page.
It only updates **what changed**.

---

# 2. Why React uses Virtual DOM?

Updating the real DOM is slow.

Browser DOM operations like:

* Creating a new element
* Changing attributes
* Changing styles
* Removing nodes
* Rebuilding layout

are **expensive**.

React avoids unnecessary DOM operations by:

1. Generating a Virtual DOM (cheap, pure JavaScript object)
2. Comparing old and new Virtual DOM (diffing)
3. Applying minimal changes to Real DOM

---

# 3. How React's Diffing Algorithm Works

React uses two main rules for efficient diffing:

### Rule 1:

If the element type is different, React destroys old node and creates a new one.

Example:

Old:

```html
<div>Hello</div>
```

New:

```html
<p>Hello</p>
```

React removes div and creates p.
Full replacement.

### Rule 2:

If element type is same, React compares **props and children**.

Example:

Old:

```html
<button class="a">Click</button>
```

New:

```html
<button class="b">Click</button>
```

React updates only class.

---

# 4. Key Role in Lists (Critical for Reconciliation)

This is where the concept of **keys** becomes essential.

React identifies each list item using the key.
Key helps React understand which element:

* stayed same
* moved
* removed
* added

Without good keys, React cannot reliably update lists.

---

# 5. Bad Example: Using Index as key

```jsx
items.map((item, index) => (
  <li key={index}>{item}</li>
))
```

If items change order:

* React gets confused
* It reuses wrong DOM nodes
* Input boxes jump
* UI behaves strangely

Index keys break reconciliation.

---

# 6. Good Example: Unique Stable ID

```jsx
items.map(item => (
  <li key={item.id}>{item.name}</li>
))
```

Now React can correctly match old and new items.

---

# 7. Reconciliation Step-by-Step

Let's take a simple example.

Initial UI:

```jsx
<div>
  <p>A</p>
  <p>B</p>
</div>
```

Update UI:

```jsx
<div>
  <p>A</p>
  <p>C</p>
</div>
```

React process:

1. div is same → keep it
2. first p is same → text "A" unchanged
3. second p → text changed from B to C → update only text

React updates only the changed text node.

---

# 8. Component Example: Visualizing Reconciliation

Create file:

`src/components/10.RenderingDeepDive/Render6_Reconciliation.jsx`

```jsx
import { useState } from "react";

export default function Render6_Reconciliation() {
  const [text, setText] = useState("A");

  console.log("Component Rendered");

  return (
    <div>
      <h3>Reconciliation Demo</h3>

      <p>{text}</p>

      <button onClick={() => setText("B")}>
        Change to B
      </button>

      <button onClick={() => setText("A")}>
        Change back to A
      </button>
    </div>
  );
}
```

Even though the whole component re-renders:

* React sees `<p>` is same type
* Only text content changes
* DOM update = minimal

---

# 9. Parent-Child Reconciliation Example

Create:

### Parent: Render7_Parent.jsx

### Child: Render7_Child.jsx

Child component:

```jsx
function Render7_Child() {
  console.log("Child rendered");
  return <p>Child Component</p>;
}

export default Render7_Child;
```

Parent:

```jsx
import { useState } from "react";
import Render7_Child from "./Render7_Child";

export default function Render7_Parent() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  return (
    <div>
      <h3>Parent-Child Reconciliation</h3>

      <p>Count: {count}</p>

      <button onClick={() => setCount(count + 1)}>
        Increase
      </button>

      <Render7_Child />
    </div>
  );
}
```

Even though Parent renders again:

* Child is same type
* React re-renders the child
* DOM updates only text of count

This shows how reconciliation works together with rendering.

---

# 10. Summary of Reconciliation

Reconciliation is React's process of:

1. Rendering new Virtual DOM
2. Comparing with old Virtual DOM
3. Updating only what changed in Real DOM

React uses:

* Element type comparison
* Props comparison
* Children comparison
* Keys in lists

This system makes React fast and predictable.

---
