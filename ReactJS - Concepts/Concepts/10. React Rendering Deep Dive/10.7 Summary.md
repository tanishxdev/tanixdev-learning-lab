# 10.7 REACT RENDERING — FULL SUMMARY & MENTAL MODEL

The goal is simple:

> If you understand this section completely, you will never be confused about any React rendering behavior again.

We will cover:

* Rendering pipeline
* Why re-renders happen
* How re-renders flow
* How reconciliation decides DOM operations
* How Fiber schedules rendering
* How to optimize
* Architecture mindset

---

# PART 1 — THE COMPLETE REACT RENDERING PIPELINE

React works in **3 steps**:

## Step 1: Render Phase

React executes your component functions.

Input:

* state
* props
* context

Output:

* Virtual DOM

This phase:

* Can be paused
* Can be abandoned
* Can be resumed
* Does not touch browser DOM

This is where:

* Every component function is run
* JSX is converted to objects
* useMemo and memo checks occur
* useState returns the latest value

---

## Step 2: Reconciliation (Diffing Phase)

React compares **old virtual DOM** with **new virtual DOM**.

React checks:

* Is the element type same?
* Are props same?
* Are children same?
* Do keys match?

Output:

* A list of DOM operations to run

This step decides WHAT must change.

---

## Step 3: Commit Phase

React mutates the real DOM.

This phase:

* Cannot pause
* Must finish quickly
* Runs useLayoutEffect + DOM updates
* Runs useEffect after commit

This is when your UI actually updates.

---

# PART 2 — THE ONLY 4 RE-RENDER TRIGGERS

React re-renders a component ONLY if:

1. Its state changes
2. Its props change
3. Its parent re-renders
4. Its context value changes

If a component re-renders for any other reason, it means one of the above happened indirectly.

There are no hidden or magical reasons.

---

# PART 3 — THE RELATIONSHIP BETWEEN RENDERING & DOM UPDATES

Important:

> Re-rendering does not mean DOM changes.

React may run your component function, but if virtual DOM is identical:

* Reconciliation finds no difference
* Commit phase is empty
* No DOM change is made

This is why React is fast.

---

# PART 4 — FIBER MENTAL MODEL (Internal Engine)

Fiber gives React:

* Ability to split work
* Scheduling
* Pausing long renders
* Resuming work
* Aborting old renders
* Prioritizing urgent updates

Fiber makes rendering smooth on slow devices and large apps.

---

# PART 5 — OPTIMIZATION STRATEGIES (Tools and When to Use)

You now know the four tools:

| Tool        | Purpose                                    |
| ----------- | ------------------------------------------ |
| React.memo  | Prevent child re-render if props unchanged |
| useCallback | Stabilize functions                        |
| useMemo     | Stabilize object/array values              |
| Keys        | Help React track list items                |

Used together, they eliminate all unnecessary re-renders.

We can categorize scenarios:

### Scenario 1: Parent re-rendering child for no reason

Solution: React.memo

### Scenario 2: Child re-renders because parent recreated functions

Solution: useCallback

### Scenario 3: Child re-renders because parent recreated objects/arrays

Solution: useMemo

### Scenario 4: List items re-rendering incorrectly

Solution: Unique keys

---

# PART 6 — ARCHITECTURE MINDSET

How to structure components to minimize re-renders?

Follow these rules:

1. Keep parent components small
2. Move stable data outside component if possible
3. Memoize expensive calculations
4. Wrap pure UI components in React.memo
5. Separate logic from UI using custom hooks
6. Avoid inline objects and inline functions when passing to children
7. Split context into smaller contexts
8. Avoid storing large objects in state unless necessary

This type of thinking is what makes React apps smooth and scalable.

---

# PART 7 — THE SINGLE MOST IMPORTANT MENTAL MODEL

Here is the entire rendering logic boiled down:

1. Component function runs
2. React builds new virtual DOM
3. React compares with old virtual DOM
4. React updates only changed DOM parts
5. React runs effects
6. React waits for next update

And re-renders happen only when:

* State changes
* Props change
* Parent re-renders
* Context changes

You now have the complete mental model of React rendering.

---

# PART 8 — PRACTICE COMPONENTS

Inside folder:

```
src/components/10.RenderingDeepDive
```

You now have these:

* Render1_Basic
* Render2_State
* Render3_Parent
* Render3_Child
* Render4_InlineObject
* Render5_UseMemoObject
* Render6_Reconciliation
* Render7_Parent
* Render7_Child
* Render8_FiberPhases
* Render9_NoMemo
* Render10_WithMemo
* Render11_UseCallback
* Render12_UseMemoValues
