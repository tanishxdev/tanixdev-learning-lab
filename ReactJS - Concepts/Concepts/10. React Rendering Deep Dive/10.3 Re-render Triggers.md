# 10.3 RE-RENDER TRIGGERS (Deep Explanation)

This section explains the core rules React follows to decide **when** a component should re-render.

We will go step-by-step:

1. The 4 official triggers
2. Why each trigger causes rendering
3. Visual breakdown of how React thinks
4. Common developer mistakes
5. Components that demonstrate incorrect vs correct behavior

The goal is to build a mental model so you always know:

* Will this cause a re-render?
* Why did this component render again?
* How to prevent unnecessary re-renders?

---

# Part 1: The 4 Re-render Triggers (Deep Explanation)

You already know the list.
Now we deepen each one.

---

## 1. State Change (setState)

State is stored inside the component.
When you call:

```js
setCount(count + 1)
```

React marks this component as "dirty" and schedules it for a re-render.

React logic:

1. Component's state changed
2. The UI based on state is now outdated
3. React re-runs the component function to get the new UI

Important note:

React will re-render even if the new value equals the old value:

```js
setCount(0)
setCount(0)
```

Still triggers re-render, because React does not check deep equality for primitive state values.

Example:

```
count = 0 → setCount(0) → re-render
```

Even though value is same.

---

## 2. Parent Re-render

If a parent re-renders, React re-renders all of its children by default.

Why?

Because React cannot assume the child output will stay the same unless you explicitly tell it (using React.memo).

Parent → child re-render happens even when:

* Child has no props
* Child props did not change
* Child UI stays the same

Reason:

On every render, React re-executes the parent component function.
Inside that function, child components are referenced again.

React treats child components as part of the parent's output tree, so it renders them again.

---

## 3. Props Change

If a child receives a new prop value, it must re-render.

Example:

```jsx
<Child value={count} />
```

Every time `count` changes, Child re-renders.

Important detail:

Even if prop is an object that looks "same" but is recreated each render:

```jsx
<Child data={{name: "Tanish"}} />
```

Child re-renders always because `{name: "Tanish"}` is a new object every render.

React does shallow comparison (===).
Objects are never equal unless same reference.

---

## 4. Context Value Change

If you use:

```js
const theme = useContext(ThemeContext)
```

And ThemeContext.Provider updates value:

```jsx
<ThemeContext.Provider value={themeObject}>
```

Every consumer re-renders.

Context is powerful but can cause global re-renders if not used carefully.

---

# Part 2: Build Mental Model (Critical)

Think of React like this:

```
If anything the component depends on changes (state, props, context),
React re-renders the component.
```

Component dependency map:

* Own state
* Props from parent
* Context values

React re-renders when any dependency changes.

---

# Part 3: Developer Mistakes that Cause Unnecessary Re-renders

Below are the common mistakes developers make.
We will make components to demonstrate each mistake.

---

## Mistake 1: Creating objects/arrays inline

Example:

```jsx
<Child user={{name: "John"}} />
```

Every render creates a new object.
Child re-renders every time.

Better:

```js
const user = useMemo(() => ({ name: "John" }), []);
<Child user={user} />
```

---

## Mistake 2: Passing functions inline

```jsx
<Child handleClick={() => setCount(count + 1)} />
```

Bad because function gets recreated every render.

Child always re-renders.

Solution:

```js
const handleClick = useCallback(() => setCount(count + 1), [count]);
```

Then:

```jsx
<Child handleClick={handleClick} />
```

---

## Mistake 3: Using Context for everything

Context re-renders all consumers.

Better: Split into multiple small contexts or use libraries like Zustand/Recoil.

---

## Mistake 4: Large parent component

If parent has:

* Huge logic
* Many child components

Every small update causes massive re-rendering.

Solution:

* Split components
* Use React.memo
* Use useCallback

---

# Part 4: Components Demonstrating Triggers

Create folder:

```
src/components/10.RenderingDeepDive/Triggers/
```

---

## Component A: Object Inline Re-render (Bad Example)

`Render4_InlineObject.jsx`

```jsx
function Child({ user }) {
  console.log("Child rendered with user:", user);
  return <p>User: {user.name}</p>;
}

export default function Render4_InlineObject() {
  console.log("Parent rendered");

  return (
    <div>
      <h3>Inline Object Problem</h3>

      <Child user={{ name: "Tanish" }} />
    </div>
  );
}
```

Every render logs child even though nothing changed.

---

## Component B: Corrected Using useMemo

`Render5_UseMemoObject.jsx`

```jsx
import { useMemo } from "react";

function Child({ user }) {
  console.log("Child rendered with user:", user);
  return <p>User: {user.name}</p>;
}

export default function Render5_UseMemoObject() {
  console.log("Parent rendered");

  const user = useMemo(() => ({ name: "Tanish" }), []);

  return (
    <div>
      <h3>Optimized Object</h3>

      <Child user={user} />
    </div>
  );
}
```

Now child renders only once.

---

# Part 5: Summary

A component re-renders when:

* Its state changes
* Its parent re-renders
* Its props change
* Its context changes

React does not re-render randomly.

---
