# **22.7 Controlled vs Uncontrolled Pattern**

A complete, production-grade explanation of **what Controlled and Uncontrolled components are**, why the distinction matters in real applications, how it affects re-renders, forms, component API design, and how design systems use this pattern to create flexible UI.

This is one of the most fundamental React patterns and directly influences performance, usability, and reusability.

---

# 1. What Is the Controlled vs Uncontrolled Pattern?

React components can manage their value in two ways:

### **1. Controlled Components**

The parent controls the state.

```jsx
<input value={value} onChange={e => setValue(e.target.value)} />
```

The input cannot change itself.
The state lives outside.

### **2. Uncontrolled Components**

The component manages its own state internally.

```jsx
<input defaultValue="hello" />
```

React does not track changes.
State lives inside the DOM element or component.

This pattern defines **who owns the state**.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Parent needs full control

Forms must reflect exactly what React state contains.

### Problem 2: Parent wants no control

Some inputs are independent (search bar, uncontrolled text fields).

### Problem 3: Reusable components must support both

Design systems (MUI, Chakra, Ant Design, Radix) must allow:

* controlled mode
* uncontrolled mode

### Problem 4: Controlled vs uncontrolled affects performance

Controlled components re-render on every character typed.
Uncontrolled components do not.

---

# 3. Controlled Components (Deep Understanding)

In controlled mode:

* value is stored in React state
* component receives value via props
* parent updates via onChange
* UI is always equal to React state

Example:

```jsx
function ControlledInput() {
  const [text, setText] = useState("");

  return (
    <input
      value={text}
      onChange={(e) => setText(e.target.value)}
    />
  );
}
```

Benefits:

* predictable
* easy validation
* easy masking
* easy form submission
* easy to sync with external systems

Downside:

* re-renders on every keystroke
* performance cost in large forms

---

# 4. Uncontrolled Components (Deep Understanding)

Uncontrolled components store their state internally (DOM or internal state):

```jsx
<input defaultValue="hello" ref={ref} />
```

React does not track changes.
To read value → access via ref.

Example:

```jsx
function UncontrolledForm() {
  const inputRef = useRef();

  function handleSubmit() {
    console.log(inputRef.current.value);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input defaultValue="" ref={inputRef} />
    </form>
  );
}
```

Benefits:

* fewer re-renders
* faster forms
* simple independent inputs

Downside:

* harder to validate
* not synced with React state
* less predictable

---

# 5. Design System Requirement: Support Both Modes

Reusable components **must detect** controlled vs uncontrolled mode.

Example: Input component in a design library.

```jsx
function Input({ value, defaultValue, onChange }) {
  const [internal, setInternal] = useState(defaultValue);

  const isControlled = value !== undefined;

  const val = isControlled ? value : internal;

  function handleChange(e) {
    if (!isControlled) setInternal(e.target.value);
    onChange?.(e);
  }

  return <input value={val} onChange={handleChange} />;
}
```

Now the component supports:

### Controlled usage:

```jsx
<Input value={name} onChange={setName} />
```

### Uncontrolled usage:

```jsx
<Input defaultValue="hello" />
```

This is exactly how MUI, Chakra, and AntD implement components.

---

# 6. When Should You Use Controlled Components?

Use controlled mode when:

* you need validation
* you need masking (credit card input)
* you need dynamic disabling
* you need the parent to store final values
* you need to compute derived state
* the value must sync across components
* the value must reset when props change
* building a serious form

Controlled mode = React is source of truth.

---

# 7. When Should You Use Uncontrolled Components?

Use uncontrolled mode when:

* performance is important (search boxes, large forms)
* you don’t care about validation
* input is short-lived
* the parent should not re-render on every keystroke
* component is low-level and generic
* you want DOM to manage the state

Uncontrolled = DOM is the source of truth.

---

# 8. Hybrid Pattern (Highly Useful)

Some components use controlled logic for important aspects but leave others uncontrolled.

Example:
Search bar where parent tracks final query but typing stays uncontrolled.

```jsx
function SearchBox({ onSubmit }) {
  const ref = useRef();

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        onSubmit(ref.current.value);
      }}
    >
      <input ref={ref} defaultValue="" />
    </form>
  );
}
```

Parent gets meaningful state
User types without React re-renders.

---

# 9. This Pattern and Performance

### Controlled inputs:

Re-render on every keystroke.
Bad for large forms or slow components.

### Uncontrolled inputs:

DOM handles typing → smooth performance.

Design systems often use **hybrid models**:

* uncontrolled for typing
* controlled for commit/change events

Example: before-input and after-input validation.

---

# 10. Anti-Patterns

Avoid:

### 1. Switching between controlled and uncontrolled

React throws warnings.

```jsx
value={undefined} → becomes uncontrolled
value="text" → becomes controlled
```

### 2. Using controlled inputs when not needed

Creates unnecessary re-renders.

### 3. Using uncontrolled inputs in complex forms

Hard to validate and manage.

### 4. Mixing modes incorrectly

Determine mode once at mount time.

---

# 11. Real Production Example: Reusable Checkbox

Checkbox must allow:

### Controlled Usage

```jsx
<Checkbox checked={isSelected} onChange={toggle} />
```

### Uncontrolled Usage

```jsx
<Checkbox defaultChecked />
```

Implementation:

```jsx
function Checkbox({ checked, defaultChecked, onChange }) {
  const [internal, setInternal] = useState(defaultChecked);
  const isControlled = checked !== undefined;
  const value = isControlled ? checked : internal;

  function handleChange(e) {
    if (!isControlled) setInternal(e.target.checked);
    onChange?.(e);
  }

  return <input type="checkbox" checked={value} onChange={handleChange} />;
}
```

This pattern is essential for flexible UI components.

---

# 12. Follow-up Questions

1. Should your design system support both controlled and uncontrolled modes?
2. Which components in your project currently re-render too much due to controlled state?
3. Do you need hybrid controlled/uncontrolled inputs?
4. Should your form system use React Hook Form or custom logic?
5. Do any components accidentally switch between controlled and uncontrolled?
6. Should you add internal state fallback like libraries do?
7. Do you want controlled vs uncontrolled applied to dropdowns, checkboxes, or sliders?
8. Should controlled mode trigger validation automatically?
9. Do you want a reusable `useControllableState` hook?
10. Should we combine this pattern with State Reducer pattern next?
