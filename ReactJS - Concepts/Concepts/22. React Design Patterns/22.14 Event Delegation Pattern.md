# **22.14 Event Delegation Pattern**

A complete, production-grade explanation of **what the Event Delegation Pattern is**, how it works inside browsers and React, why React abstracts it, how to use it to improve performance in large lists or deeply nested components, and when you should or should not use it.

This is a pattern more relevant to **performance**, **DOM control**, and **interaction-heavy UIs**.

---

# 1. What Is the Event Delegation Pattern?

Event Delegation is a pattern where:

### Instead of attaching event listeners to many child elements,

### you attach **one** listener to a parent element and detect the target.

Browser example:

```js
document.querySelector("#list").addEventListener("click", (e) => {
  if (e.target.matches(".item")) {
    console.log("Item clicked:", e.target);
  }
});
```

Events bubble up the DOM.
You use the parent listener to handle all children events.

This pattern saves memory, improves performance, and simplifies logic.

---

# 2. Why Does This Pattern Matter in React?

Even though React handles event delegation automatically at the root level, we face real UI problems:

### Problem 1: Large or dynamic lists

Attaching thousands of event handlers:

```jsx
items.map(item => <li onClick={...}>...</li>)
```

is unnecessary and expensive for large virtualized UIs.

### Problem 2: Elements created dynamically

Event delegation handles elements added/removed without re-attaching listeners.

### Problem 3: Low-level DOM custom interactions

Game UI, canvas, SVGs, interactive editors, drag-and-drop.

### Problem 4: Need centralized control over user interaction

One parent should manage the logic for all children.

---

# 3. How React Implements Event Delegation Internally

React historically used a single event listener at the root:

```
document.addEventListener("click", reactHandler)
```

React mapped events to components internally.

React 17+ uses **root-level delegation per React root** instead of one global listener.

Even so:

* events bubble
* React catches event at a parent
* React dispatches synthetic events to the component that registered the handler

This is why React components can register events declaratively.

---

# 4. When You Need Manual Event Delegation in React

Even though React handles synthetic events, you may need explicit delegation when:

1. You render thousands of items and want minimal event listeners
2. You need to manage events outside React’s synthetic system
3. You need to detect child interactions without attaching handlers to each
4. You are integrating with DOM-heavy libraries
5. You need finer control over event propagation

Examples:

* Virtualized tables
* Infinite scrolling lists
* Kanban boards
* Custom drag-and-drop systems
* Tree views with deep nesting

---

# 5. Implementation Pattern in React (Modern)

### Example: A List with Event Delegation

Instead of:

```jsx
<ul>
  {items.map(item => (
    <li key={item.id} onClick={() => handleClick(item.id)}>
      {item.name}
    </li>
  ))}
</ul>
```

Use one delegated event:

```jsx
function ItemList({ items }) {
  function handleClick(e) {
    const id = e.target.getAttribute("data-id");
    if (id) console.log("Clicked:", id);
  }

  return (
    <ul onClick={handleClick}>
      {items.map((item) => (
        <li key={item.id} data-id={item.id}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}
```

Now:

* only **one** event listener
* new items require no new listeners
* better performance in large lists

---

# 6. Advanced Example: Delegating Multiple Event Types

A parent can delegate multiple interactions:

```jsx
function Menu({ items }) {
  function handleEvent(e) {
    const target = e.target.closest("[data-action]");
    if (!target) return;

    const action = target.dataset.action;

    if (action === "edit") editItem(target.dataset.id);
    if (action === "delete") deleteItem(target.dataset.id);
  }

  return (
    <div onClick={handleEvent} onMouseOver={handleEvent}>
      {items.map((item) => (
        <div key={item.id}>
          <span>{item.name}</span>
          <button data-action="edit" data-id={item.id}>Edit</button>
          <button data-action="delete" data-id={item.id}>Delete</button>
        </div>
      ))}
    </div>
  );
}
```

A single handler manages all interactions.

---

# 7. Event Delegation in Custom UI Systems

If you're building:

* dropdown menus
* nested menus
* context menus
* drag-and-drop
* timeline editors
* SVG canvases
* diagram editors

Event delegation avoids flooding components with handlers that re-render on every state change.

Instead, a single stable handler manages the entire UI region.

---

# 8. Event Delegation + useRef (Important Pattern)

If you need to listen at document level:

```jsx
function useDocumentClick(handler) {
  useEffect(() => {
    document.addEventListener("click", handler);
    return () => document.removeEventListener("click", handler);
  }, [handler]);
}
```

Useful for:

* closing modals
* closing dropdown when clicked outside
* handling escape key events

This is delegation at the document level.

---

# 9. Performance Considerations

### Use event delegation when:

* list > 1000 items
* items are interactive
* items change dynamically
* event handlers are causing re-renders

### Benefits:

* fewer React re-renders
* lower memory usage
* better responsiveness
* stable event handlers

### Important note:

Delegate only stable interactions.
More complex internal logic can stay local.

---

# 10. Anti-Patterns

Avoid:

### 1. Overusing delegation in small lists

No need for complexity.

### 2. Handling layout-specific logic in the delegate

Delegate should focus on events, not UI logic.

### 3. Using delegation when event.target can be ambiguous

Hard-to-maintain code.

### 4. Delegating deeply nested components without using `closest`

Use:

```js
e.target.closest("[selector]")
```

for reliability.

### 5. Forgetting cleanup for global listeners

Leads to memory leaks.

---

# 11. When Should You Use the Event Delegation Pattern?

Use when:

* rendering huge lists
* building complex interactive widgets
* integrating with DOM-heavy third-party libraries
* controlling events manually outside React’s synthetic system
* building performance-critical UI

Avoid when:

* list is small
* logic is simple
* React’s normal event system is sufficient

Delegation is a specialized performance pattern.

---

# 12. Follow-up Questions

1. Do you want to build a high-performance list using event delegation?
2. Are you planning infinite scroll, tables, or nested menus?
3. Should event delegation be combined with virtualization?
4. Do you want delegation examples with pointer events or keyboard events?
5. Should we integrate event delegation with a custom drag-and-drop system?
6. Do you want a delegate that handles both click and keyboard navigation?
7. Should we demonstrate delegation inside a canvas or SVG editor?
8. Do you prefer delegation using `closest()` or data attributes?
9. Should event delegation be wrapped into a custom hook?
10. Do you want TypeScript-based implementations?
