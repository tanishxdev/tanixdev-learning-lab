# **22.12 Custom Hook Pattern**

A complete, production-grade explanation of **what the Custom Hook Pattern is**, why it is the backbone of modern React architecture, how it separates business logic from UI, how large codebases use it to enable reuse and composability, and how to implement it correctly with performance in mind.

This is one of the most important patterns in React after hooks were introduced.

---

# 1. What Is the Custom Hook Pattern?

A **custom hook** is a function that extracts reusable logic out of components.

Rules:

* its name must start with `use`
* it can call other hooks inside it
* it returns state, functions, or derived values

Example:

```jsx
function useCounter() {
  const [count, setCount] = useState(0);
  return { count, inc: () => setCount(c => c + 1) };
}
```

Components can now share this logic:

```jsx
function Counter() {
  const { count, inc } = useCounter();
  return <button onClick={inc}>{count}</button>;
}
```

The UI becomes extremely clean.

---

# 2. Why Does the Custom Hook Pattern Exist?

### Problem 1: Components contain too much logic

Fetching, validation, calculations → messy.

### Problem 2: Logic duplication

You copy-paste the same logic across many components.

### Problem 3: Hard to test logic inside UI

Business logic buried inside UI makes unit testing difficult.

### Problem 4: Hard to replace state management

Hook-based architecture makes logic portable.

### Problem 5: Needed for every scalable React app

Modern React apps push all:

* data fetching
* business rules
* derived logic
* state transitions

into custom hooks.

UI should be the final layer only.

---

# 3. What Should Custom Hooks Contain?

A custom hook encapsulates:

1. Business logic
2. State & transitions
3. API calls
4. Validation
5. Derived/computed values
6. Event handlers
7. Local caches
8. Reusable synchronous utilities

A custom hook should never contain:

* JSX
* styling
* layout logic

Hooks are for **brains**, components are for **faces**.

---

# 4. Basic Example: useCounter (Logic Extraction)

### Instead of:

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  const inc = () => setCount(c => c + 1);
  return <button onClick={inc}>{count}</button>;
}
```

Extract logic:

```jsx
function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  const inc = () => setCount((c) => c + 1);
  const dec = () => setCount((c) => c - 1);
  return { count, inc, dec };
}
```

Component becomes:

```jsx
function Counter() {
  const { count, inc } = useCounter(10);
  return <button onClick={inc}>{count}</button>;
}
```

Cleaner. Reusable.

---

# 5. Real Example: Custom Hook for API Fetching

Use React Query inside a custom hook:

```jsx
export function useProducts() {
  return useQuery({
    queryKey: ["products"],
    queryFn: () => api.get("/products").then(r => r.data)
  });
}
```

Usage:

```jsx
const { data } = useProducts();
```

Benefits:

* API logic is centralized
* Component stays focused on UI
* Tests target the hook instead of UI

---

# 6. Custom Hook Pattern + Container–Presenter Pattern

Pairing these two patterns makes components extremely clean.

### Hook (logic)

```jsx
export function useUserProfile(id) {
  return useQuery({
    queryKey: ["user", id],
    queryFn: () => api.get(`/users/${id}`).then(r => r.data)
  });
}
```

### Container

```jsx
export function UserProfileContainer({ id }) {
  const { data, isLoading } = useUserProfile(id);
  if (isLoading) return <Skeleton />;
  return <UserProfileUI user={data} />;
}
```

### Presenter

```jsx
export function UserProfileUI({ user }) {
  return <h1>{user.name}</h1>;
}
```

Hooks are foundational to this architecture.

---

# 7. Custom Hook Pattern for Forms

```jsx
function useFormFields(initialValues) {
  const [values, setValues] = useState(initialValues);

  function update(name, value) {
    setValues((prev) => ({ ...prev, [name]: value }));
  }

  return { values, update };
}
```

Component:

```jsx
const { values, update } = useFormFields({ email: "", password: "" });

<input onChange={(e) => update("email", e.target.value)} />
```

Form logic extracted cleanly.

---

# 8. Custom Hook Pattern for Derived Logic

```jsx
function useFilteredProducts(products) {
  const [query, setQuery] = useState("");

  const filtered = useMemo(() => {
    return products.filter((p) =>
      p.title.toLowerCase().includes(query.toLowerCase())
    );
  }, [products, query]);

  return { query, setQuery, filtered };
}
```

Components become simple orchestrators.

---

# 9. How Big Companies Use Custom Hooks

### Shopify

Every domain has its own hooks:

```
useProducts
useInventory
useCollections
useCheckout
```

### Stripe Dashboard

Every page uses hooks for fetching and business logic.

### Meta / Instagram

Hooks manage derived logic across feed, stories, comments, reels.

### Radix & Headless UI

All headless logic is built inside hooks.

Hooks are the fundamental architectural unit.

---

# 10. Anti-Patterns

Avoid:

### 1. Creating hooks that do not abstract anything

If only 1 component uses it, don’t extract prematurely.

### 2. Hooks with mixed responsibilities

Hook should handle one domain.

### 3. Returning unstable callbacks

Use `useCallback` when necessary.

### 4. Naming hooks without `use`

Breaks React’s rules.

### 5. Hooks that depend on component-specific UI logic

Hooks should stay UI-independent.

---

# 11. When Should You Use the Custom Hook Pattern?

Use when:

* multiple components need same logic
* API logic needs isolation
* UI needs to stay clean
* building reusable business logic
* building design systems
* separating major domains

Avoid when:

* logic is trivial
* over-engineering small components
* hook becomes more complicated than the component itself

---

# 12. Follow-up Questions

1. Should your app have domain-based hooks like `useAuth`, `useCart`, `useUser`?
2. Should hooks live in `/hooks` folder or within feature folders?
3. Do you want your layout, container, and presenter layers to use hooks exclusively?
4. Do you want to create a hook library for your app?
5. Should hooks include caching (React Query) or local state only?
6. Should hooks expose actions (mutations) or derived state only?
7. Do you want a performance-optimized hook template?
8. Should hooks be written in TypeScript for better DX?
9. Do you want examples of advanced hooks like `usePagination`, `useDebounce`, `useInfiniteScroll`?
10. Should hooks integrate Zustand or Jotai with React Query?

---