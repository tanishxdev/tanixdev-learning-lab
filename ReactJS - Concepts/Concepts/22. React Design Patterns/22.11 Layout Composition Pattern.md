# **22.11 Layout Composition Pattern**

A complete, production-grade explanation of **what the Layout Composition Pattern is**, why real React apps rely on it, how it organizes UI structure, and how to build modular, reusable page layouts using composition instead of prop-heavy components.

Used in large apps like **Next.js, Shopify Admin, Stripe Dashboard, Notion, GitHub**.

---

# 1. What Is the Layout Composition Pattern?

It is a React pattern where **layouts themselves are components**, and pages or child components pass their UI into predefined layout “slots”.

Instead of making one giant layout component with many props:

```jsx
<Layout
  header={<Header />}
  sidebar={<Sidebar />}
  content={<Content />}
  footer={<Footer />}
/>
```

We use **composition**:

```jsx
<Layout>
  <Layout.Header>...</Layout.Header>
  <Layout.Sidebar>...</Layout.Sidebar>
  <Layout.Content>...</Layout.Content>
</Layout>
```

The layout defines the structure.
Children define the content.

This avoids prop explosion and gives full freedom.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Large pages need consistent but flexible layouts

Dashboards include:

* header
* sidebar
* content
* toolbar
* filters
* footer

Different pages rearrange or hide sections.
Props are not enough for this flexibility.

### Problem 2: Layouts should provide structure, not UI content

Logic stays in layout.
Content stays in page.

### Problem 3: Avoid giant wrapper components with too many props

Old approach:

```jsx
<DashboardLayout
  showSidebar
  customToolbar={<Toolbar />}
  title="Analytics"
  footer={<Footer />}
/>
```

Difficult to scale.

### Problem 4: Needed for multi-layout React apps

Example:

* MarketingLayout
* DashboardLayout
* AuthLayout
* AdminLayout

Each provides structure but accepts content via composition.

---

# 3. Layout Composition vs Slot Pattern vs Compound Components

These three patterns overlap, but differ:

| Pattern             | Purpose                                |
| ------------------- | -------------------------------------- |
| Compound Components | Multi-part reusable component behavior |
| Slot Pattern        | Named slots inside a component         |
| Layout Composition  | Page-level structural composition      |

Layout Composition is the **macro-level** version of Slots.

---

# 4. Basic Example: Dashboard Layout

### Parent Component: Layout

```jsx
function Layout({ children }) {
  let header = null;
  let sidebar = null;
  let content = null;

  React.Children.forEach(children, (child) => {
    if (child.type === Layout.Header) header = child;
    if (child.type === Layout.Sidebar) sidebar = child;
    if (child.type === Layout.Content) content = child;
  });

  return (
    <div className="layout">
      <div className="header">{header}</div>
      <div className="sidebar">{sidebar}</div>
      <main className="content">{content}</main>
    </div>
  );
}
```

### Define Sub-Components (slots)

```jsx
Layout.Header = ({ children }) => <>{children}</>;
Layout.Sidebar = ({ children }) => <>{children}</>;
Layout.Content = ({ children }) => <>{children}</>;
```

### Page Usage

```jsx
<Layout>
  <Layout.Header>
    <DashboardTopBar />
  </Layout.Header>

  <Layout.Sidebar>
    <SidebarNavigation />
  </Layout.Sidebar>

  <Layout.Content>
    <AnalyticsCharts />
  </Layout.Content>
</Layout>
```

This matches the structure of real dashboards.

---

# 5. Real Example: Next.js App Router Layouts

Next.js uses a built-in version of this pattern.

Folder structure:

```
app/
  layout.jsx
  page.jsx
  dashboard/
    layout.jsx
    page.jsx
```

Layouts wrap pages automatically:

```jsx
export default function Layout({ children }) {
  return (
    <div>
      <Header />
      <main>{children}</main>
    </div>
  );
}
```

Every deeper route composes layouts by nesting them.
This is Layout Composition Pattern in action.

---

# 6. Composing Multiple Layouts (Layout Stacking)

Example:

```jsx
<AuthLayout>
  <DashboardLayout>
     <ReportsPage />
  </DashboardLayout>
</AuthLayout>
```

Top-level layout:

* authentication wrapper
* theming wrapper
* global UI

Inner layout provides:

* sidebar
* header
* content grid

This allows large apps to layer concerns.

---

# 7. Dynamic Layout Composition (Optional)

Different pages can choose different layouts:

```jsx
const Page = () => <Reports />;

Page.getLayout = (page) => (
  <DashboardLayout>
    <ChartLayout>{page}</ChartLayout>
  </DashboardLayout>
);

export default Page;
```

This is widely used in Next.js + React Router custom setups.

---

# 8. Layout Composition in Design Systems

UI systems often expose composable layout primitives:

```
PageLayout
  PageLayout.Header
  PageLayout.Sidebar
  PageLayout.Section
  PageLayout.Toolbar
  PageLayout.Footer
```

Developers assemble their own screens using these building blocks.

---

# 9. Performance Considerations

### 1. Layouts should avoid internal re-renders

Don’t put changing state inside layout unless required.

### 2. Use memoized values in providers inside layouts

Prevents re-render storms.

### 3. Avoid expensive effects inside Layout

Layouts are widely used; keep them lightweight.

---

# 10. Anti-Patterns

Avoid:

### 1. Putting business logic inside Layout

Layout should focus on structure, not logic.

### 2. Passing UI through props instead of children

Defeats the compositional API.

### 3. Too many layout layers

Keep layering meaningful.

### 4. Mixing layout responsibilities

Example: Authentication logic inside dashboard layout.

### 5. Hard-coding layout-specific markup

Allow users to choose layout structure.

---

# 11. When Should You Use Layout Composition?

Use when:

* Building dashboards
* Building large multi-section UI
* Supporting multiple layouts per route
* Creating reusable layout primitives
* Building admin panels or enterprise apps
* Need customizable structure but predictable layout

Avoid when:

* Component is small
* Layout is always identical
* Only one layout exists in the entire app

This pattern shines at **scale**.

---

# 12. Follow-up Questions

1. Do you want your app to support multiple layouts (Dashboard, Auth, Marketing)?
2. Should your layouts include built-in slots (header, sidebar, footer)?
3. Do you want to integrate this pattern with Next.js App Router layouts?
4. Should layouts also include providers (user, theme, settings)?
5. Should layout composition be dynamic or static?
6. Do you need nested layouts (e.g., Dashboard → Reports → Charts)?
7. Should layouts enforce grid or flex structure?
8. Should we build a real DashboardLayout using this pattern?
9. Should layout composition combine with Slot Pattern?
10. Do you want TypeScript versions of layout components?
