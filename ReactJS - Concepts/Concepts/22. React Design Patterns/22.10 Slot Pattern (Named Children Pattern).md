# **22.10 Slot Pattern (Named Children Pattern)**

A complete, production-grade explanation of **what the Slot Pattern is**, why it exists, how it improves component flexibility, how design systems use it, and how to implement it in React using children, props, and composition.

This pattern is heavily used in **Radix UI, Chakra UI, Headless UI, and modern design systems**.

---

# 1. What Is the Slot Pattern?

The **Slot Pattern** allows a parent component to define *places* (slots) where users can inject custom UI.

Example:

```jsx
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
  <Card.Footer>Actions</Card.Footer>
</Card>
```

Each sub-component fills a **slot** in the parent’s layout.

The parent decides structure.
The consumer decides content.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Components need flexible markup

Developers want to control layout and content:

```
header → title, avatar, action button
body → text, images
footer → buttons, stats
```

Rigid props like:

```jsx
<Card header={} footer={} />
```

don’t scale.

### Problem 2: Avoid deeply nested props

Passing rendering props for everything becomes messy.

### Problem 3: Parent must enforce layout but not content

Slots let you provide structure **without dictating UI**.

### Problem 4: Needed in design systems

Common in:

* cards
* modals
* lists
* dialogs
* menus
* steps

Slots make these components extremely flexible.

---

# 3. How the Slot Pattern Works (Architecture Overview)

A parent component:

* provides layout
* scans `children`
* finds which child corresponds to which slot
* renders them in correct position

Children:

* signal their slot via component type
* contain user-provided UI

Flow:

```
Parent Layout → identifies slots → inserts child content
```

---

# 4. Basic Example: Card Component with Slots

### Parent Component

```jsx
function Card({ children }) {
  let header = null;
  let body = null;
  let footer = null;

  React.Children.forEach(children, (child) => {
    if (child.type === Card.Header) header = child;
    if (child.type === Card.Body) body = child;
    if (child.type === Card.Footer) footer = child;
  });

  return (
    <div className="card">
      {header}
      {body}
      {footer}
    </div>
  );
}
```

### Slot components

```jsx
Card.Header = function ({ children }) {
  return <div className="card-header">{children}</div>;
};

Card.Body = function ({ children }) {
  return <div className="card-body">{children}</div>;
};

Card.Footer = function ({ children }) {
  return <div className="card-footer">{children}</div>;
};
```

### Usage

```jsx
<Card>
  <Card.Header>
    <h1>My Card</h1>
  </Card.Header>

  <Card.Body>
    <p>Hello world</p>
  </Card.Body>

  <Card.Footer>
    <button>Submit</button>
  </Card.Footer>
</Card>
```

---

# 5. Why This Pattern Is Powerful

### 1. Structure is fixed, but content is flexible

Perfect balance between control and freedom.

### 2. Readable API

Declarative, intuitive, and clean.

### 3. No prop-drilling

Slots identify themselves automatically.

### 4. Parent enforces layout integrity

Children cannot rearrange internal structure incorrectly.

### 5. Great for design systems

Used for:

* Cards
* Modals
* Menus
* Dialogs
* Lists
* Tables

### 6. Zero prop collisions

Slots don’t share props unless needed.

---

# 6. Slot Pattern + Compound Components

Slot pattern is usually implemented **using compound components**.

Flow:

```
Compound Components = exposes static sub-components
Slot Pattern        = defines placement of static sub-components
```

They work together perfectly.

---

# 7. Real Production Example: Modal Component

### Parent

```jsx
function Modal({ children }) {
  let header = null;
  let body = null;
  let footer = null;

  React.Children.forEach(children, (child) => {
    if (child.type === Modal.Header) header = child;
    if (child.type === Modal.Body) body = child;
    if (child.type === Modal.Footer) footer = child;
  });

  return (
    <div className="modal">
      <div className="modal-content">
        {header}
        {body}
        {footer}
      </div>
    </div>
  );
}
```

### Children

```jsx
Modal.Header = ({ children }) => <div className="modal-header">{children}</div>;
Modal.Body = ({ children }) => <div className="modal-body">{children}</div>;
Modal.Footer = ({ children }) => <div className="modal-footer">{children}</div>;
```

### Usage

```jsx
<Modal>
  <Modal.Header>Profile Settings</Modal.Header>
  <Modal.Body>Form goes here</Modal.Body>
  <Modal.Footer>
    <button>Save</button>
  </Modal.Footer>
</Modal>
```

Extremely flexible dialog design.

---

# 8. Optional: Passing Data Into Slots

Slots can also receive data.

Example: Parent provides controlled values.

```jsx
function Card({ children, status }) {
  return React.Children.map(children, (child) => {
    return React.cloneElement(child, { status });
  });
}
```

Now slot components can read `status`:

```jsx
<Card status="success">
  <Card.Body>Status is {status}</Card.Body>
</Card>
```

This improves compositional flexibility.

---

# 9. Anti-Patterns

Avoid:

### 1. Too many slot types

Makes the API heavy.

### 2. Passing unrelated props to slot components

Breaks separation.

### 3. Deep nesting of slots inside slots

Hard to maintain.

### 4. Not validating child types

Unknown components cause rendering bugs.

### 5. Using props instead of children for slot content

Defeats the purpose of the pattern.

---

# 10. When Should You Use the Slot Pattern?

Use when:

* your component has multiple structural regions
* layout must be consistent
* UI must be custom inside each region
* you are building a design system
* you want a declarative, self-describing API

Avoid when:

* component is simple and flat
* you do not want to enforce a strict structure
* only one region needs customization

---

# 11. Follow-up Questions

1. Do you want your design system components (Card, Modal, Tabs) to use the Slot Pattern?
2. Should slots allow passing additional props (like `status` or `size`)?
3. Do your components need validation for allowed child types?
4. Should we combine Slot Pattern with Compound Components for complete headless UI?
5. Do you want a TypeScript version of Slot Pattern?
6. Should we implement advanced slot resolution (fallback defaults)?
7. Do you want nested Slots for more complex components (like Layout)?
8. Should Slot components forward refs?
9. Should slot injection be memoized to avoid re-renders?
10. Do you want to build a real UI component using this pattern next (Modal, Card, Accordion)?
