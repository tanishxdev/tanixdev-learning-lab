# **22.6 Compound Components Pattern**

A complete, production-grade explanation of **what the Compound Components Pattern is**, why it is used in real UI libraries, how it enables flexible “headless” component APIs, and how to implement it using modern React (Context, hooks, composition).

This pattern powers many libraries: **Radix UI, Headless UI, Chakra UI, React Aria**.

---

# 1. What Is the Compound Components Pattern?

Compound Components are a group of related components that work together as a single unit.

Example:

```jsx
<Tabs>
  <Tabs.List>
    <Tabs.Trigger>Tab 1</Tabs.Trigger>
    <Tabs.Trigger>Tab 2</Tabs.Trigger>
  </Tabs.List>

  <Tabs.Panel>Content 1</Tabs.Panel>
  <Tabs.Panel>Content 2</Tabs.Panel>
</Tabs>
```

Each sub-component:

* is independent
* is flexible
* gets state from the parent (Tabs)
* knows how to behave based on shared context

The parent manages logic
The children control UI.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Components with many props become messy

Example bad API:

```jsx
<Tabs
  active={0}
  onChange={...}
  listClass="..."
  triggerClass="..."
  panelClass="..."
/>
```

Too many unrelated props.

### Problem 2: Users want full UI control

Developers often need:

* custom markup
* custom layout
* custom styling

Single-component APIs cannot provide this flexibility.

### Problem 3: Children must coordinate behavior

Tabs, modals, dropdowns, accordions require **multiple parts**:

* trigger
* list
* panel
* overlay

Compound components solve this with:

```
Shared state → Context
UI freedom → Composition
```

---

# 3. How the Pattern Works (Architecture Overview)

1. Parent component holds logic

2. Parent exposes sub-components as static properties:

   ```
   Tabs.List
   Tabs.Trigger
   Tabs.Panel
   ```

3. Sub-components read shared logic via **Context**

4. User composes UI freely using JSX children

---

# 4. Minimal Example: Toggle

### Logic container

```jsx
const ToggleContext = createContext();

export function Toggle({ children }) {
  const [on, setOn] = useState(false);
  const toggle = () => setOn((v) => !v);

  return (
    <ToggleContext.Provider value={{ on, toggle }}>
      {children}
    </ToggleContext.Provider>
  );
}
```

### Sub-components

```jsx
Toggle.Button = function () {
  const { on, toggle } = useContext(ToggleContext);
  return <button onClick={toggle}>{on ? "On" : "Off"}</button>;
};

Toggle.Message = function ({ when, children }) {
  const { on } = useContext(ToggleContext);
  return on === when ? children : null;
};
```

### Usage

```jsx
<Toggle>
  <Toggle.Button />
  <Toggle.Message when={true}>Enabled</Toggle.Message>
</Toggle>
```

Free layout, clean API.

---

# 5. Compound Example: Tabs Component (Real World)

### 1. Create context

```jsx
const TabsContext = createContext();
```

### 2. Parent logic

```jsx
export function Tabs({ children, defaultIndex = 0 }) {
  const [active, setActive] = useState(defaultIndex);

  return (
    <TabsContext.Provider value={{ active, setActive }}>
      {children}
    </TabsContext.Provider>
  );
}
```

### 3. Sub-components

#### Tabs.List

```jsx
Tabs.List = function ({ children }) {
  return <div className="tabs-list">{children}</div>;
};
```

#### Tabs.Trigger

```jsx
Tabs.Trigger = function ({ index, children }) {
  const { active, setActive } = useContext(TabsContext);

  return (
    <button
      className={active === index ? "active" : ""}
      onClick={() => setActive(index)}
    >
      {children}
    </button>
  );
};
```

#### Tabs.Panel

```jsx
Tabs.Panel = function ({ index, children }) {
  const { active } = useContext(TabsContext);
  return active === index ? <div>{children}</div> : null;
};
```

### Usage

```jsx
<Tabs defaultIndex={0}>
  <Tabs.List>
    <Tabs.Trigger index={0}>Overview</Tabs.Trigger>
    <Tabs.Trigger index={1}>Billing</Tabs.Trigger>
  </Tabs.List>

  <Tabs.Panel index={0}>Overview Content</Tabs.Panel>
  <Tabs.Panel index={1}>Billing Content</Tabs.Panel>
</Tabs>
```

This is identical to Radix UI-style architecture.

---

# 6. Why Compound Components Are Powerful

### 1. Flexible structure

Users choose markup order.

### 2. Flexible styling

Users apply their own classes or UI frameworks.

### 3. No prop drilling

Sub-components get data from context.

### 4. Declarative

Components mirror UI structure naturally.

### 5. Perfect for headless UI

Logic is reusable without UI restrictions.

---

# 7. Comparison with Other Patterns

| Pattern             | Purpose                         |
| ------------------- | ------------------------------- |
| Container–Presenter | Separate UI from logic          |
| Smart–Dumb          | Categorize components           |
| Render Props        | Pass logic to child UI          |
| Props Getter        | Provide props for flexible HTML |
| Compound Components | Compose multiple related parts  |

Compound components are the **cleanest way** to expose reusable multi-part UI.

---

# 8. Real-World Use Cases

This pattern is ideal for:

* Tabs
* Accordion
* Dropdown
* Modal
* Tooltip
* Menu
* Wizard / Steps
* Pagination
* Select components

Any UI with multiple dependent parts benefits from this pattern.

---

# 9. Anti-Patterns

Avoid:

### 1. Putting heavy logic inside sub-components

Logic belongs to parent.

### 2. Passing state through props instead of context

Breaks the purpose of this pattern.

### 3. Hard-coding DOM structure

Users must control layout.

### 4. Deep nesting of contexts

Use one context per component domain only.

### 5. Mixing CSS/styling logic into parent

UI belongs to child components.

---

# 10. When Should You Use This Pattern?

Use when:

* your component has multiple interdependent parts
* you want high customizability
* you want to build a reusable design system
* layout must be user-controlled
* you are designing a headless library

Avoid when:

* component has only one UI part
* logic is simple
* using it makes API over-engineered

---

# 11. Follow-up Questions

1. Do you want to build your own Tabs/Accordion/Dropdown using this pattern?
2. Should compound components in your system be headless or include built-in UI?
3. Do you want TypeScript versions of this pattern?
4. Will your design system need nested compound components?
5. Should compound components also use Props Getter pattern internally?
6. Do you want to integrate React Query or Zustand logic into a compound architecture?
7. Should sub-components support forwarding refs for accessibility?
8. Do you need examples for Modal, Accordion, Pagination?
9. Are you planning to build Radix-style primitives?
10. Do you want error boundaries integrated into compound components?

---