# 16.10 Testing Redux Logic

A complete, production-ready guide focused on **testing slices, reducers, actions, async thunks, and selectors** — with a clean, developer-first mindset.

No fluff. Only practical, high-quality testing patterns used in real teams.

---

# 1. Why Test Redux Logic?

### The core problem

Redux logic manages **critical application state**:

* Authentication
* Cart
* Payments
* User preferences
* API data
* UI logic

If reducers or thunks fail → app behaves unpredictably.

Common breaks:

1. Reducer modifies wrong field
2. Async thunk handles errors incorrectly
3. Slice initial state is wrong
4. Loading/error states not updated properly
5. Selector returns wrong derived values

Testing ensures:

* Reducers behave predictably
* Thunks handle success + error cases
* Selectors compute correct derived values
* Deep refactors do not break state behavior

---

# 2. What to Test in Redux?

You should test:

1. **Slice reducers**
2. **Actions generated by createSlice**
3. **Async thunks**
4. **Extra reducers (for thunks)**
5. **Selectors**
6. **Integration of reducer in store**

You do NOT test:

* React components here
* Implementation details
* UI rendering

Redux logic = pure logic.
Tests should also be pure.

---

# 3. Tools to Use

Recommended:

* Jest (default test runner)
* Redux Toolkit’s predictable reducer behavior
* MSW (Mock Service Worker) for API mocking (optional)

None of these require setting up React Testing Library.

---

# 4. Developer Mindset Thinking

Before writing tests, ask:

1. What is the initial state supposed to be?
2. What should happen when this action is dispatched?
3. What should not happen?
4. Do async thunks handle both success and failure?
5. Are selectors computing correct derived state?

Testing mindset:

* Focus on **behavior**, not implementation
* Ensure reducers are deterministic
* Ensure thunks call correct async logic

---

# 5. Example Slice to Test (Counter)

### counterSlice.js

```jsx
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export const fetchCount = createAsyncThunk(
  "counter/fetchCount",
  async () => {
    const res = await Promise.resolve({ value: 10 });
    return res.value;
  }
);

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0, status: "idle" },
  reducers: {
    increment: (state) => { state.value += 1; },
    decrement: (state) => { state.value -= 1; }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchCount.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchCount.fulfilled, (state, action) => {
        state.status = "success";
        state.value = action.payload;
      })
      .addCase(fetchCount.rejected, (state) => {
        state.status = "error";
      });
  }
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

---

# 6. Testing Reducers (Pure Logic)

## counterSlice.test.js

```jsx
import reducer, { increment, decrement } from "./counterSlice";

describe("counter reducer", () => {
  test("should return initial state", () => {
    const initialState = { value: 0, status: "idle" };
    expect(reducer(undefined, { type: "unknown" })).toEqual(initialState);
  });

  test("should handle increment", () => {
    const state = reducer({ value: 0, status: "idle" }, increment());
    expect(state.value).toBe(1);
  });

  test("should handle decrement", () => {
    const state = reducer({ value: 1, status: "idle" }, decrement());
    expect(state.value).toBe(0);
  });
});
```

### What we tested:

* Initial state
* Pure reducers
* Mutation logic via Immer

No store required.

---

# 7. Testing Async Thunks

To test thunks, mock API calls.

### Mocking fetchCount

```jsx
import reducer, { fetchCount } from "./counterSlice";

describe("async thunk: fetchCount", () => {
  test("sets status to loading when pending", () => {
    const action = { type: fetchCount.pending.type };
    const state = reducer({ value: 0, status: "idle" }, action);
    expect(state.status).toBe("loading");
  });

  test("sets value when fulfilled", () => {
    const action = { type: fetchCount.fulfilled.type, payload: 10 };
    const state = reducer({ value: 0, status: "loading" }, action);
    expect(state).toEqual({ value: 10, status: "success" });
  });

  test("sets error when rejected", () => {
    const action = { type: fetchCount.rejected.type };
    const state = reducer({ value: 0, status: "loading" }, action);
    expect(state.status).toBe("error");
  });
});
```

### Purpose:

* Tests async logic transformation inside reducers
* Does NOT perform real API calls
* Ensures correct lifecycle handling

---

# 8. Testing Full Thunk Execution (with mocked API)

Using Jest mocks:

```jsx
test("fetchCount thunk resolves and returns data", async () => {
  const dispatch = jest.fn();
  const getState = jest.fn();

  await fetchCount()(dispatch, getState, undefined);

  expect(dispatch).toHaveBeenCalledWith(expect.objectContaining({
    type: fetchCount.pending.type
  }));

  expect(dispatch).toHaveBeenCalledWith(expect.objectContaining({
    type: fetchCount.fulfilled.type,
    payload: 10
  }));
});
```

This verifies:

* The thunk dispatches pending → fulfilled
* Async logic returns correct payload

---

# 9. Testing Selectors

Example selector:

```jsx
export const selectCounterValue = (state) => state.counter.value;
```

Test:

```jsx
test("selectCounterValue returns correct value", () => {
  const state = { counter: { value: 5 } };
  expect(selectCounterValue(state)).toBe(5);
});
```

Selectors should always be tested because they often contain logic.

---

# 10. Integration Test — Reducer Inside Store

Sometimes you want to test Redux end-to-end.

```jsx
import { configureStore } from "@reduxjs/toolkit";
import reducer, { increment } from "./counterSlice";

test("store integration test", () => {
  const store = configureStore({ reducer: { counter: reducer } });

  store.dispatch(increment());

  expect(store.getState().counter.value).toBe(1);
});
```

Confirms:

* Slice works inside real store
* Actions update real state tree

---

# 11. Common Mistakes

1. Testing implementation instead of behavior
2. Mocking Redux Toolkit internals
3. Testing Immer behavior (unnecessary)
4. Testing UI + Redux together (mixing concerns)
5. Forgetting to test rejected cases in async thunks
6. Not mocking API calls correctly
7. Writing giant integration tests instead of unit tests

---

# 12. When NOT to Test Redux

You can skip testing when:

* Slice is extremely simple (e.g., toggling dark mode)
* State update is trivial
* Derived logic belongs in selectors

Usually test:

* Business-critical reducers
* Async thunks
* Complex derived state
* Enterprise flows (cart, checkout, auth, payment)

---

# 13. Best Practices

1. Test reducers as pure functions
2. Test async thunks with mocked dispatch
3. Test every edge case of extraReducers
4. Test selectors separately
5. Don’t test Immer (RTK handles it)
6. Keep tests small and isolated
7. Focus on behavior, not implementation detail
8. Write tests only for logic that can break

---

# 14. Comparison: Testing Redux vs Testing React Components

| Aspect            | Redux Logic | React Components |
| ----------------- | ----------- | ---------------- |
| Isolation         | High        | Low              |
| Complexity        | Low         | Medium           |
| Requires DOM      | No          | Yes              |
| Tests behavior    | Yes         | Yes              |
| Integration tests | Optional    | Common           |

Redux logic should remain easily testable.

---

# 15. Follow-up Questions

1. Why are reducers easy to unit test?
2. How does RTK simplify async thunk testing?
3. Why should selectors be tested separately?
4. When should you NOT test Redux logic?
5. What is the difference between pending/fulfilled/rejected in thunks?
6. Why do we mock dispatch when testing thunks?
7. How to test thunks with rejected promises?
8. Why is testing Immer behavior unnecessary?
9. How do you test a slice inside a real store?
10. Why avoid testing UI in Redux unit tests?

---