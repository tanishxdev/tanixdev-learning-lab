# 16.7 Feature-Based Redux Structure

---

# 1. Why Feature-Based Structure?

### The core problem

Old Redux projects commonly used **file-type based structure**:

```
actions/
reducers/
types/
store/
```

Issues with this:

1. Logic for one feature is scattered across 3–4 folders
2. Hard to navigate
3. Hard to scale
4. Difficult onboarding for new developers
5. Features become tightly coupled
6. Cross-file jumping slows development
7. No clear separation of feature domains

Modern applications need:

* Modularity
* Clear ownership
* Independent features
* Separation based on domain, not file type

Feature-based structure solves all problems.

---

# 2. What is Feature-Based Redux Structure?

A structure where **each feature (domain)** owns its:

* Slice
* Async thunks
* Selectors
* Components
* API service (if any)
* Types (if using TS)

Everything for a feature lives in one folder.

Example:

```
src/
 └── features/
      ├── auth/
      │    ├── authSlice.js
      │    ├── authAPI.js
      │    ├── LoginForm.jsx
      │    └── selectors.js
      ├── todos/
      │    ├── todosSlice.js
      │    ├── todosApi.js (RTK Query)
      │    ├── TodoList.jsx
      │    └── selectors.js
```

Store imports all feature slices:

```
store.js
```

This architecture is used in:

* Real production apps
* Large-scale SaaS
* Enterprise dashboards
* Collaborative teams

---

# 3. When to use Feature-based Structure?

Use it when:

* You work in a team
* App grows beyond 3–5 slices
* You have multiple domains (auth, cart, products, users, UI)
* You need predictable code organization
* You want isolated, maintainable features
* You want scalable architecture for years

Do NOT use it when:

* App is tiny and only one slice exists
* You don’t need global state
* Zustand or Jotai suits your needs better

---

# 4. Analogy

Think of your app as a big company:

* Auth = HR department
* Products = Manufacturing
* Cart = Sales
* Users = Customer service

Each department keeps:

* Its own documents
* Its own staff
* Its own rules

They don’t dump everything into one giant folder.

Feature-based architecture is exactly this separation.

---

# 5. How It Works Internally

1. Each feature folder contains everything its domain needs
2. createSlice provides local reducer logic
3. asyncThunks stay alongside slice
4. RTK Query services stay in same domain
5. Components import directly from their feature folder
6. Store combines all slices in one place
7. Each feature is **independent** and **reusable**

In large apps (> 20–30 slices), this structure becomes critical.

---

# 6. Developer Mindset Thinking

Ask:

1. Is this behavior part of a distinct domain?
2. Does this type of data belong together?
3. Will this code change independently from others?
4. Should future developers quickly find everything related?

If YES → create a feature folder.

This prevents "spaghetti Redux".

---

# 7. Full Example Feature-Based Structure

### Folder: `src/features/todos/`

```
todosSlice.js
todosThunks.js
todosApi.js
selectors.js
TodoList.jsx
TodoItem.jsx
```

### todosSlice.js

```jsx
import { createSlice } from "@reduxjs/toolkit";
import { fetchTodos } from "./todosThunks";

const todosSlice = createSlice({
  name: "todos",
  initialState: {
    items: [],
    status: "idle"
  },
  reducers: {
    addTodo(state, action) {
      state.items.push(action.payload);
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = "success";
        state.items = action.payload;
      });
  }
});

export const { addTodo } = todosSlice.actions;
export default todosSlice.reducer;
```

### todosThunks.js

```jsx
import { createAsyncThunk } from "@reduxjs/toolkit";

export const fetchTodos = createAsyncThunk(
  "todos/fetch",
  async () => {
    const res = await fetch("/api/todos");
    return res.json();
  }
);
```

---

# 8. Dry Run of Feature Behavior

1. User interacts with `<TodoList />`
2. TodoList dispatches `fetchTodos()`
3. Thunk fetches data
4. Slice reducer updates state
5. UI automatically re-renders
6. TodoList imports from its own folder:
   – thunks
   – selectors
   – slice actions

The feature is self-contained.

---

# 9. Example: Multi-feature Application Structure

```
src/
 └── features/
      ├── auth/
      │    ├── authSlice.js
      │    ├── LoginForm.jsx
      │    └── authAPI.js
      ├── todos/
      │    ├── todosSlice.js
      │    ├── TodoList.jsx
      └── cart/
           ├── cartSlice.js
           ├── cartAPI.js
           ├── CartView.jsx
└── app/
     └── store.js
```

### store.js

```jsx
import { configureStore } from "@reduxjs/toolkit";
import authReducer from "../features/auth/authSlice";
import todosReducer from "../features/todos/todosSlice";
import cartReducer from "../features/cart/cartSlice";

export const store = configureStore({
  reducer: {
    auth: authReducer,
    todos: todosReducer,
    cart: cartReducer
  }
});
```

---

# 10. Common Mistakes

1. Mixing feature logic in shared folders
2. One giant slice storing everything
3. Naming slices generically (slice1, slice2)
4. Putting UI components outside feature folder
5. Over-normalization when not needed
6. Duplicate API logic across features
7. Dumping thunks in random folders

Maintain strict separation by domain.

---

# 11. When NOT to Use Feature-Based Structure

* Small toy apps
* Only one slice exists
* State is local or minimal
* Zustand handles global state better

---

# 12. Best Practices

1. One folder per domain
2. Keep slice logic inside that folder
3. API logic should be colocated
4. Use selectors to avoid leaking structure
5. Name folders by business domain (auth, cart, todos)
6. Keep components related to the feature inside the feature folder
7. Keep reducers small and targeted
8. Avoid coupling between feature folders

---

# 13. Compare: File-Type vs Feature-Based Structure

| Category                 | File-Type Structure | Feature-Based Structure |
| ------------------------ | ------------------- | ----------------------- |
| Organization             | By file type        | By domain               |
| Navigation               | Hard                | Easy                    |
| Scalability              | Difficult           | Excellent               |
| Team collaboration       | Hard                | Smooth                  |
| Boilerplate              | More                | Less                    |
| Readability              | Poor                | Clear                   |
| Component-slice coupling | Weak                | Strong                  |
| Best practice            | No                  | Yes (industry standard) |

Feature-based is the current standard for Redux.

---

# 14. Follow-up Questions

1. Why is a feature-based structure easier to scale?
2. How does colocating slice + API improve maintainability?
3. What problems occur when all Redux logic lives in one folder?
4. Why should selectors be inside feature folder?
5. How do feature domains help team collaboration?
6. When is feature-based structure unnecessary?
7. How do components benefit from domain-level organization?
8. Why does Redux Toolkit recommend feature-first structure?
9. How does it integrate with RTK Query?
10. Should UI components always be inside feature folders?

---