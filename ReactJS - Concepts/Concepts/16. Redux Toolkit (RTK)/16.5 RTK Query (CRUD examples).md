# 16.5 RTK Query (CRUD Examples)

---

# 1. Why RTK Query?

### The core problem

`createAsyncThunk` is good for async actions, but **not ideal for server state**.

Server state has unique challenges:

* Needs caching
* Needs invalidation
* Needs automatic refetching
* Needs to handle stale/fresh data
* Needs de-duplication of identical requests
* Needs retries, polling, pagination
* Needs loading/error/success states
* Needs caching per argument
* Needs easy global access

Without RTK Query, developers often:

* Re-fetch data unnecessarily
* Duplicate API logic across components
* Manually handle caching
* Write loading/error logic every time
* Get stale UI issues
* Over-fetch because no proper invalidation

RTK Query solves all of this with a **built-in server state cache** + automated fetching.

---

# 2. What is RTK Query?

RTK Query is a powerful **data fetching & caching system** built into Redux Toolkit.

It provides:

* Automatic API calls
* Automatic caching
* Automatic invalidation
* Automatic re-fetching
* Automatic loading/error states
* Automatic data management across components
* Mutations (POST, PUT, DELETE)
* Query lifecycle events
* Optimistic updates

RTK Query eliminates almost all boilerplate for server state.

---

# 3. When to use RTK Query?

Use RTK Query when:

* Your data comes from an API
* You want built-in caching
* You need automatic refetch
* Multiple components need the same data
* You want to avoid prop-drilling API results
* Data changes often
* You want a professional, production-grade server state layer

Do NOT use RTK Query when:

* You only need local or client state
* API data is extremely simple and not shared
* You are using React Query (similar solution)

---

# 4. Analogy

Think of RTK Query as a **smart waiter** in a restaurant:

* If the kitchen has the food cached → serve instantly
* If not → fetch once and cache it
* If data changes → invalidate and fetch fresh
* If multiple tables order same item → fetch only once
* If ingredient changes → update all relevant dishes

RTK Query manages everything intelligently so you don’t have to.

---

# 5. How RTK Query Works Internally

1. You define an API slice using `createApi`

2. RTK Query auto-generates hooks:
   – `useGetTodosQuery()`
   – `useAddTodoMutation()`
   – etc.

3. When called in a component:

   * It triggers the API request
   * Caches the response based on input arguments
   * Tracks loading/error states
   * Re-fetches only when needed

4. When data is mutated:

   * RTK Query invalidates cache
   * Automatically triggers refetch in relevant queries

Everything is declarative and centralized.

---

# 6. Folder Structure (Recommended)

```
src/
 └── services/
      ├── api.js
      └── todosApi.js
 └── features/
      └── components...
```

---

# 7. RTK Query Setup

## File: api.js (Base API)

```jsx
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const api = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({ baseUrl: "https://jsonplaceholder.typicode.com" }),
  endpoints: () => ({})
});
```

Add to store:

```jsx
import { api } from "../services/api";

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer
  },
  middleware: (getDefault) =>
    getDefault().concat(api.middleware)
});
```

---

# 8. CRUD Examples (Complete)

---

# 8.1 READ (GET) — Fetch Todos

## File: todosApi.js

```jsx
import { api } from "./api";

export const todosApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getTodos: builder.query({
      query: () => "/todos"
    })
  })
});

export const { useGetTodosQuery } = todosApi;
```

## Component

```jsx
export default function Todos() {
  const { data, isLoading, error } = useGetTodosQuery();

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error loading todos</p>;

  return (
    <ul>
      {data.slice(0, 10).map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

### Dry Run

1. Component calls `useGetTodosQuery()`
2. RTK Query fetches `/todos`
3. Caches result
4. Reuses cache on re-render
5. If cache expires or arg changes → re-fetch

---

# 8.2 CREATE (POST) — Add Todo

## In todosApi.js

```jsx
addTodo: builder.mutation({
  query: (todo) => ({
    url: "/todos",
    method: "POST",
    body: todo
  }),
  invalidatesTags: ["Todos"]
})
```

Add tags to your GET:

```jsx
getTodos: builder.query({
  query: () => "/todos",
  providesTags: ["Todos"]
})
```

## Component

```jsx
const [addTodo] = useAddTodoMutation();

<button onClick={() => addTodo({ title: "New Todo", completed: false })}>
  Add Todo
</button>;
```

### Dry Run

1. POST request sent
2. addTodo resolves
3. RTK Query invalidates "Todos" tag
4. getTodos auto-refetches
5. UI updates with fresh list

---

# 8.3 UPDATE (PUT/PATCH)

```jsx
updateTodo: builder.mutation({
  query: ({ id, data }) => ({
    url: `/todos/${id}`,
    method: "PATCH",
    body: data
  }),
  invalidatesTags: ["Todos"]
})
```

Usage:

```jsx
updateTodo({ id: 1, data: { completed: true } });
```

---

# 8.4 DELETE

```jsx
deleteTodo: builder.mutation({
  query: (id) => ({
    url: `/todos/${id}`,
    method: "DELETE"
  }),
  invalidatesTags: ["Todos"]
})
```

Usage:

```jsx
deleteTodo(1);
```

---

# 9. Tag System Explained (Critical Concept)

Tags help RTK Query automatically refetch data.

### providesTags

Used in queries (GET):

```jsx
providesTags: ["Todos"]
```

### invalidatesTags

Used in mutations:

```jsx
invalidatesTags: ["Todos"]
```

When a mutation invalidates a tag, all queries that provide that tag **auto-refresh**.

This is what makes RTK Query powerful.

---

# 10. Common Mistakes

1. Forgetting to add api.reducer and api.middleware in store
2. Not using providesTags / invalidatesTags
3. Writing fetch logic manually instead of using query/mutation
4. Mutating server state but not invalidating cache
5. Using RTK Query for local UI state
6. Calling mutation without invalidation → stale UI
7. Not using selectFromResult for optimization

---

# 11. When NOT to Use RTK Query

* For local UI state: toggles, forms, modal visibility
* If API responses aren’t shared across components
* When using React Query instead
* When API doesn’t require caching

---

# 12. Best Practices

1. One API slice per domain
2. Use providesTags and invalidatesTags correctly
3. Use selectFromResult for fine-grained re-renders
4. Prefer PATCH over PUT for minimal updates
5. Always handle loading & error states
6. Use mutation lifecycle events for side actions
7. Co-locate API slices inside `services/` folder

---

# 13. Comparison: createAsyncThunk vs RTK Query

| Feature              | createAsyncThunk     | RTK Query    |
| -------------------- | -------------------- | ------------ |
| Purpose              | Client state updates | Server state |
| Caching              | No                   | Yes          |
| Auto refetch         | No                   | Yes          |
| Auto loading/error   | No                   | Yes          |
| Boilerplate          | Medium               | Very low     |
| Tags & invalidation  | No                   | Yes          |
| Optimistic updates   | Manual               | Built-in     |
| Multiple subscribers | Manual               | Automatic    |

RTK Query is the modern solution for server state.

---

# 14. Follow-up questions

1. Why is RTK Query better than createAsyncThunk for server state?
2. How do providesTags and invalidatesTags work internally?
3. When should you not use RTK Query?
4. How does RTK Query reduce over-fetching?
5. What is the difference between query and mutation?
6. Why does RTK Query require its middleware?
7. How does caching improve performance?
8. What happens when multiple components use the same query?
9. How can you optimize rerenders using selectFromResult?
10. Which problem does RTK Query solve that Redux never solved well?

---