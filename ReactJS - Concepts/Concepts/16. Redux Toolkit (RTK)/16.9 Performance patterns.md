# 16.9 Performance Patterns (Redux Toolkit)

A practical, developer-focused guide for **preventing unnecessary re-renders**, organizing state for speed, using selectors correctly, and writing scalable Redux logic.

This topic is about **how to keep Redux apps fast**, not just working.

---

# 1. Why Performance Patterns?

### The core problems in typical Redux apps:

1. **Too many component re-renders**
2. **Large slices causing global tree updates**
3. **Inefficient selectors**
4. **Overusing useSelector**
5. **Deriving data inside components**
6. **Deeply nested state = slow updates**
7. **Storing wrong type of state in Redux**
8. **Components subscribed to entire slices**
9. **Not memoizing derived state**
10. **Incorrect store structuring**

These issues cause:

* Janky UI
* Slow updates
* Wasted re-renders
* Memory overhead
* Hard-to-scale performance

Performance patterns help you avoid all of this.

---

# 2. What is Performance Optimization in Redux?

Redux update cycle:

```
Action dispatched
→ Slice reducer updates state
→ Redux compares previous and next states (shallow comparison)
→ Trigger re-render if slice reference changed
→ Components subscribed to that slice re-render
```

Goal:

* Reduce how often components re-render
* Reduce how much state changes
* Structure slices for faster updates
* Prevent accidental global updates

Performance pattern = designing slices and selectors to **minimize re-render scope**.

---

# 3. When Do Performance Issues Happen?

Ask yourself:

1. Do multiple components subscribe to the same slice?
2. Does one state update re-render too many components?
3. Am I using large arrays or nested objects?
4. Am I deriving expensive values in components?
5. Am I using Context + Redux incorrectly?
6. Are selectors returning new objects every time?

If YES → performance patterns required.

---

# 4. Analogy

Think of your Redux store as an office.

If one employee moves a chair:

* Should the entire building get evacuated?
* No.

Similarly:

* Updating a small piece of state shouldn't re-render the whole React tree.

Performance patterns ensure that **only the affected rooms re-render**, not the whole building.

---

# 5. How Redux Performance Works Internally

Re-render happens when:

* The value returned by `useSelector` changes (shallow compare)
* A slice reducer returns a new reference
* Parent component re-renders without memoization

To optimize performance:

1. Keep slices small
2. Keep selectors granular
3. Keep state normalized
4. Memoize everything derived
5. Use proper store structure

---

# 6. Developer Mindset Thinking

Before writing Redux state, ask:

1. Should this be in Redux or local component state?
2. Will many components subscribe to this?
3. Can this state be split into small slices?
4. Should I normalize large data using Entity Adapter?
5. Should I store raw data or derive it with selectors?

If you think performance-first, you avoid problems later.

---

# 7. Performance Pattern #1

## Slice Granularity — Small Slices, Not One Big Slice

Bad:

```js
const initialState = {
  auth: {},
  cart: [],
  products: [],
  ui: { modalOpen: false }
};
```

Problem:

* Any small update re-renders everything that uses this root slice.

Good:

Separate features:

```
authSlice
cartSlice
productSlice
uiSlice
```

Each slice re-renders **only its consumers**.

---

# 8. Performance Pattern #2

## Use Entity Adapter for Lists

Reason:

* Normalized state causes minimal updates
* Updating one entity doesn't update the entire array
* Selectors are memoized
* Performance remains O(1)

Use:

```jsx
const usersAdapter = createEntityAdapter();
```

---

# 9. Performance Pattern #3

## Use Granular Selectors (Never Select Whole Slice)

Bad:

```jsx
useSelector((state) => state.cart);
```

Good:

```jsx
useSelector((state) => state.cart.totalPrice);
```

Better:

```jsx
const total = useSelector(selectCartTotal);
```

Selecting the entire slice causes unnecessary re-renders.

---

# 10. Performance Pattern #4

## Memoized Selectors (createSelector)

Use Reselect:

```jsx
export const selectExpensiveValue = createSelector(
  (state) => state.items,
  (items) => items.filter(x => x.active)
);
```

Benefits:

* Expensive recalculation runs only when inputs change
* Prevents wasted renders
* Cleaner logic

---

# 11. Performance Pattern #5

## Never Store Derived Data in Redux

Bad:

```js
totalPrice: items.reduce(...)
```

This causes:

* Double source of truth
* More updates
* Higher re-render frequency

Good:

Compute using selector:

```js
export const selectCartTotal = createSelector(
  (state) => state.cart.items,
  (items) => items.reduce((t, i) => t + i.price * i.qty, 0)
);
```

Only recalculated when items change.

---

# 12. Performance Pattern #6

## Avoid Deeply Nested State

Bad:

```js
state.user.profile.address.city = "Delhi";
```

Good:

```js
state.user.city = "Delhi";
```

Deep structures → Deep updates → More work
Flatten state for fast updates.

---

# 13. Performance Pattern #7

## Avoid Storing Large UI State in Redux

Bad candidates:

* Modal open/close
* Small form fields
* Dropdown open
* Hover state

Instead:

Use local state:

```jsx
const [open, setOpen] = useState(false);
```

Redux should store:

* App-wide state
* Data shared across components

---

# 14. Performance Pattern #8

## Avoid Overuse of useSelector

Bad:

```jsx
const cart = useSelector((s) => s.cart);
const products = useSelector((s) => s.products);
```

Better:

Use selectors:

```jsx
const total = useSelector(selectCartTotal);
const items = useSelector(selectCartItems);
```

---

# 15. Performance Pattern #9

## Memoize React Components

If component depends on very specific values:

```jsx
export default React.memo(CartSummary);
```

Prevents re-render when unrelated state changes.

---

# 16. Performance Pattern #10

## Use selectFromResult (RTK Query)

```jsx
const { data } = useGetPostsQuery(undefined, {
  selectFromResult: ({ data }) => ({
    post: data?.find((p) => p.id === 1)
  })
});
```

Only re-renders when the selected “post” changes.

---

# 17. Performance Pattern #11

## Avoid Recreating Objects Inside Selectors

Bad:

```jsx
useSelector((s) => ({ count: s.counter.value }));
```

Always returns new object → always re-renders.

Good:

```jsx
useSelector(selectCounterValue);
```

---

# 18. Performance Pattern #12

## Split Reducers for Faster State Update

Instead of:

```js
updateUser(state, action) {
  state.user = action.payload;
  state.cart = [];
}
```

Split into separate slices:

```
userSlice
cartSlice
```

Each reducer affects only its own tree.

---

# 19. Example: Good vs Bad Component

### Bad

```jsx
const { items, total, coupon } = useSelector((s) => s.cart);
```

Re-renders when any part of cart changes.

### Good

```jsx
const items = useSelector(selectCartItems);
const total = useSelector(selectCartTotal);
```

Component updates only when needed.

---

# 20. Common Mistakes

1. Selecting entire slice
2. Storing UI state in Redux
3. Deep nests inside slice
4. No normalization for lists
5. Components using multiple selectors unnecessarily
6. Using Context for fast-changing state
7. Writing expensive logic inside selectors without memoization

---

# 21. When NOT to Optimize

Avoid premature optimization.

Don't optimize if:

* State updates are rare
* Component tree is small
* No performance complaints exist
* Simpler architecture is more important

Only optimize when needed.

---

# 22. Best Practices Summary

1. Create small slices
2. Normalize data with Entity Adapter
3. Use granular memoized selectors
4. Avoid storing derived data
5. Keep UI state local
6. Avoid deep nesting
7. Memoize components
8. Use RTK Query for server state
9. Use selectFromResult in RTK Query
10. Structure state around features

---

# 23. Follow-up Questions

1. Why does selecting entire slices cause re-renders?
2. How does Entity Adapter improve update performance?
3. When should you flatten state structures?
4. Why should derived data not be stored in Redux?
5. How do memoized selectors reduce processing cost?
6. Why should local UI state stay in components?
7. How do shallow vs deep comparisons affect performance?
8. How do RTK Query selectors reduce re-renders?
9. How do React.memo and Redux selectors work together?
10. What mistakes make Redux applications slow?
