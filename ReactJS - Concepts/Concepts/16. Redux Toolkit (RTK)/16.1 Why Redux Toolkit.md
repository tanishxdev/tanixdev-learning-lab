# 16.1 Why Redux Toolkit

---

# 1. Why Redux Toolkit?

### The core problem

Before Redux Toolkit (RTK), developers used **classic Redux**, which had several issues:

1. Too much boilerplate
2. Action types, action creators, reducers all manually written
3. Immutable updates required deep cloning
4. Large, repetitive switch-case reducers
5. Hard to scale in large apps
6. Async logic complicated (redux-thunk, redux-saga setup)
7. Error-prone patterns (mutating state accidentally)
8. No standard project structure → every team reinvented Redux architecture

Classic Redux was:

* Verbose
* Hard for beginners
* Bug-prone
* Not developer-friendly

Redux Toolkit solves these problems.

---

# 2. What is Redux Toolkit?

Redux Toolkit (RTK) is the **official, recommended way** to write Redux logic.

It provides:

* Less boilerplate
* Preconfigured best practices
* Built-in reducers, actions, middleware
* Simplified async handling
* Immer-based immutable updates
* Opinionated architecture
* Fast development workflow
* Cleaner code

RTK replaces old Redux patterns with modern APIs like:

* `configureStore()`
* `createSlice()`
* `createAsyncThunk()`
* `createEntityAdapter()`
* `RTK Query`

RTK is not a separate tool.
It is **Redux, but without the pain**.

---

# 3. When to use Redux Toolkit?

Use RTK when:

* Your app has complex global state
* Multiple components need shared state
* You need predictable state management
* You need caching, query, and async API handling
* You want structure, maintainability, scalability
* You want to avoid prop-drilling
* React Context becomes too slow or complex

Good for:

* Dashboards
* Medium–large applications
* E-commerce
* Admin panels
* Authentication systems
* Multi-step flows
* Real-time apps

Do NOT use Redux Toolkit when:

* App is very small
* Only a few components need shared state
* Zustand or Jotai covers your use case more elegantly

---

# 4. Analogy

Classic Redux = manually assembling every ingredient for a pizza:

* Dough
* Sauce
* Cheese
* Toppings
* Oven setup

Redux Toolkit = ready-made pizza base + prepped ingredients:

* Just add your toppings and bake

Cleaner, faster, fewer errors.

---

# 5. How Redux Toolkit works internally

Key features:

### a) createSlice

Automatically generates:

* Action creators
* Action types
* Reducers

This avoids switch-case boilerplate.

### b) Immer.js

RTK uses Immer to allow “mutation-like syntax” while keeping true immutability.

Example:

```js
state.value += 1;
```

Looks like mutation but internally produces an immutable update.

### c) configureStore

Preconfigures:

* Redux DevTools
* Thunk middleware
* Good defaults for performance

### d) createAsyncThunk

Handles async API calls with:

* pending
* fulfilled
* rejected

No manual action types needed.

### e) RTK Query

Built-in data fetching, caching, and invalidation system.

Internal result:

* Less code
* More consistency
* Better performance
* Predictable async flow

---

# 6. Developer Mindset Thinking

Ask:

1. Is state needed across many components?
2. Does the state have complex relationships?
3. Do I need a predictable, global store?
4. Do I want maintainable architecture?
5. Do I want a standard approach across the team?
6. Is Context API becoming slow or messy?

If YES → use Redux Toolkit.

If your app is small → Zustand or Context might be simpler.

---

# 7. Simple Code Example

## File: store.js

```jsx
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice";

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});
```

## File: counterSlice.js

```jsx
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    }
  }
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

## File: Counter.jsx

```jsx
import { useSelector, useDispatch } from "react-redux";
import { increment, decrement } from "./counterSlice";

export default function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Count: {count}</p>

      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

---

# 8. Dry Run of the Example

1. Store is created using configureStore
2. counterSlice generates:
   – reducer
   – increment action
   – decrement action
3. React component subscribes via useSelector
4. Dispatch triggers reducer logic
5. State updates immutably via Immer
6. React re-renders with new value

No boilerplate.
No switch-case.
No manual action types.

---

# 9. Example 2: Async API with createAsyncThunk

```jsx
export const fetchUsers = createAsyncThunk(
  "users/fetch",
  async () => {
    const res = await fetch("/api/users");
    return res.json();
  }
);
```

RTK automatically generates:

* fetchUsers.pending
* fetchUsers.fulfilled
* fetchUsers.rejected

No manual async handling required.

---

# 10. Common Mistakes

1. Using RTK for very small apps unnecessarily
2. Mixing classic Redux patterns with RTK
3. Mutating nested objects incorrectly (Immer handles but be careful)
4. Using Context + Redux together unnecessarily
5. Writing too many slices instead of grouping related logic

---

# 11. When NOT to Use Redux Toolkit

* Small apps with minimal shared state
* Apps where local component state is enough
* When Zustand or Jotai give cleaner patterns
* For UI-level state like toggles, modal open/close
* When managing async server state (React Query is better)

RTK is great for complex client-side state, not server cache.

---

# 12. Best Practices

1. One slice per domain (authSlice, cartSlice, userSlice)
2. Use createAsyncThunk for API calls
3. Avoid deeply nested state
4. Keep reducers pure and predictable
5. Use RTK Query for server state
6. Keep slices small and focused
7. Organize state features inside `/features/<domain>` folder

---

# 13. Compare: Classic Redux vs RTK

| Feature           | Classic Redux | Redux Toolkit      |
| ----------------- | ------------- | ------------------ |
| Boilerplate       | Very high     | Very low           |
| Immutable updates | Manual        | Built-in via Immer |
| Async logic       | Complex       | createAsyncThunk   |
| Store setup       | Multi-step    | configureStore     |
| Error-prone       | High          | Low                |
| Productivity      | Medium        | High               |
| Learning curve    | Steep         | Easier             |

RTK is simply a modern, improved Redux.

---

# 14. Follow-up questions

1. Why did Redux Toolkit become the recommended way to use Redux?
2. How does Immer improve reducer logic?
3. What problems does createSlice solve?
4. When should you choose RTK Query over createAsyncThunk?
5. Why is RTK better for large-scale applications?
6. Why is Context not a replacement for Redux?
7. How does RTK reduce boilerplate compared to classic Redux?
8. Why should reducers avoid deep nested structures?
9. What is the role of configureStore?p
10. What are the limits of Redux Toolkit?

---
