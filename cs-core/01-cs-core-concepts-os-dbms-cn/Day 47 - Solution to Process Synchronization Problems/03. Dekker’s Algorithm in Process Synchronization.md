# Dekker’s Algorithm in Process Synchronization


---

## 1. Introduction

**Dekker’s Algorithm** is the **first known correct software solution** to the **critical section problem** for **two processes**.

It is historically important because it:

* Uses **only shared memory** (no hardware support)
* Avoids **strict alternation**
* Guarantees:

  * Mutual Exclusion
  * Progress
  * Bounded Waiting

Dekker’s Algorithm laid the **foundation for Peterson’s Algorithm**.

---

## 2. Problem Context: Critical Section

Each process follows this structure:

```c
do {
    // entry section
        critical section
    // exit section
        remainder section
} while (true);
```

A correct solution must satisfy:

1. **Mutual Exclusion**
2. **Progress**
3. **Bounded Waiting**

Dekker’s Algorithm achieves all three **in its final form**.

---

## 3. Shared Variables Used

Dekker’s Algorithm uses:

```c
flag[0..1]   // Boolean array
turn        // Integer (0 or 1)
```

* `flag[i] = true` → Process `Pi` wants to enter critical section
* `turn` → Indicates which process is favored in case of conflict

---

## 4. Why Dekker’s Algorithm Exists

Early approaches failed due to:

* **Strict alternation** → no progress
* **Only flags** → deadlock
* **Backoff-only solutions** → starvation

Dekker’s Algorithm evolved through **five versions** to fix these issues step by step.

---

## 5. Evolution of Dekker’s Algorithm

Understanding the **evolution** is more important than memorizing code.

---

### Version 1: Turn Variable Only (Strict Alternation)

#### Idea

* Use a shared `turn` variable
* Only the process whose turn it is may enter

#### Problem

* If one process never enters, the other **waits forever**

❌ Violates **Progress**

---

### Version 2: Flags After Entry Section

#### Idea

* Each process sets a flag when entering

#### Problem

* If preempted at wrong time, **both may enter**
* Mutual exclusion fails

❌ Violates **Mutual Exclusion**

---

### Version 3: Flags Before Entry Section

#### Idea

* Set `flag[i] = true` **before** waiting

#### Problem

* If both set flags simultaneously → **deadlock**

❌ Violates **Progress**

---

### Version 4: Flags + Backoff

#### Idea

* If conflict, temporarily reset flag and retry

#### Problem

* One process may repeatedly back off

❌ Violates **Bounded Waiting (Starvation)**

---

### Version 5: Final Dekker’s Algorithm (Correct Solution)

#### Idea

* Combine:

  * **Intent** (flags)
  * **Priority** (turn)

✅ Satisfies **all three conditions**

---

## 6. Final Dekker’s Algorithm (Correct Version)

---

### Pseudocode for Process `Pi`

```c
do {
    flag[i] = true;

    while (flag[j]) {
        if (turn == j) {
            flag[i] = false;
            while (turn == j)
                ;   // busy wait
            flag[i] = true;
        }
    }

    // -------- Critical Section --------

    turn = j;
    flag[i] = false;

    // -------- Remainder Section --------

} while (true);
```

---

## 7. Why Final Dekker’s Algorithm Works

---

### Mutual Exclusion

* Only one process can pass the `while(flag[j])` loop

---

### Progress

* If one process exits, the other can enter
* No deadlock

---

### Bounded Waiting

* `turn` ensures fairness
* No starvation

---

## 8. Comparison with Peterson’s Algorithm

| Feature               | Dekker        | Peterson          |
| --------------------- | ------------- | ----------------- |
| Complexity            | High          | Simple            |
| Readability           | Hard          | Easy              |
| Hardware assumptions  | None          | None              |
| Processes supported   | 2             | 2                 |
| Historical importance | First correct | Cleaner successor |

Peterson’s Algorithm is essentially a **simplified Dekker’s Algorithm**.

---

## 9. Limitations

* Works only for **two processes**
* Uses **busy waiting**
* Not scalable
* Not used in modern OS

---

## 10. Interview Corner

### Common Questions

1. Why is Dekker’s Algorithm important?
2. Why is `turn` required?
3. Difference between Dekker and Peterson?
4. Why isn’t Dekker used in practice?

---

## 11. Key Takeaways

* Dekker’s Algorithm is **historically foundational**
* First complete software-only synchronization solution
* Teaches:

  * Why naive approaches fail
  * How correctness is achieved step by step
* Replaced by Peterson’s Algorithm in theory
* Replaced by hardware primitives in practice

---

### Step 1: What Problem Is Dekker Solving?

Two processes want to use **one shared resource**.

Without rules:

* Both may enter → **race condition**
* One may starve → **unfair**
* Both may wait → **deadlock**

Dekker’s Algorithm answers:

> “How can two processes coordinate using only shared memory?”

---

### Step 2: Why Evolution Was Necessary

Every early idea fixed **one problem** but introduced **another**.

That’s why Dekker’s Algorithm evolved:

* Turn only → unfair
* Flags only → deadlock
* Backoff → starvation

Final version combines **intent + priority**.

---

### Step 3: Core Intuition of Final Algorithm

Each process follows **three rules**:

1. **Declare intent** → `flag[i] = true`
2. **Respect priority** → check `turn`
3. **Hand over priority after exit**

This discipline ensures:

* No collision
* No starvation
* No deadlock

---

### Step 4: Why `turn` Is Crucial

If both processes want to enter:

* Flags alone → deadlock
* `turn` breaks the tie

> `turn` is the *polite agreement*:
> “You go first this time.”

---

### Step 5: Why Dekker Is Harder Than Peterson

Dekker:

* Handles **all corner cases manually**
* More complex logic

Peterson:

* Cleaner logic
* Same guarantees

That’s why Peterson is preferred **academically**.

---

## Final Mental Model (Very Important)

| Concept      | Meaning                              |
| ------------ | ------------------------------------ |
| Flags        | Who wants to enter                   |
| Turn         | Who should wait                      |
| Busy waiting | CPU wasted but correctness preserved |
| Evolution    | Proof of correctness thinking        |
