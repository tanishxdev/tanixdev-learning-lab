# **Priority Inversion in Operating Systems**

---

## 1. Introduction

In a priority-based scheduling system, **tasks with higher priority are expected to run before lower-priority tasks**.

However, sometimes the opposite happens.

A **high-priority task is forced to wait**, while lower or medium-priority tasks execute.

This problem is known as **Priority Inversion**.

> **Priority Inversion** occurs when a **low-priority task blocks a high-priority task**, directly or indirectly, due to resource locking.

This is a **serious scheduling problem**, especially in **real-time operating systems (RTOS)**.

---

## 2. Why Priority Inversion Is a Problem

Operating systems use priorities to:

* Meet real-time deadlines
* Ensure critical tasks run first
* Maintain system responsiveness

If priorities are ignored indirectly:

* High-priority tasks may miss deadlines
* System behavior becomes unpredictable
* Critical systems may fail (spacecraft, medical systems)

---

## 3. Core Intuition Behind Priority Inversion

Priority inversion happens due to **resource sharing + preemptive scheduling**.

Key idea:

> A task with **lower priority holds a resource** that a **higher-priority task needs**,
> and **another task interferes**.

This temporarily **reverses the intended priority order**.

---

## 4. The Classic Three-Task Scenario

Consider **three tasks**:

| Task | Priority | Needs Shared Resource |
| ---- | -------- | --------------------- |
| L    | Low      | Yes                   |
| M    | Medium   | No                    |
| H    | High     | Yes                   |

---

## 5. How Priority Inversion Occurs (Step-by-Step)

---

### Step 1: Low-Priority Task Starts

* Task **L** starts executing
* L acquires a **mutex / lock** on a shared resource
* L enters its **critical section**

---

### Step 2: High-Priority Task Arrives

* Task **H** becomes ready
* H needs the same resource
* But the resource is **locked by L**
* H gets **blocked**

At this point:

* H (highest priority) is waiting
* L (lowest priority) must run to release the lock

---

### Step 3: Medium-Priority Task Arrives (Key Problem)

* Task **M** becomes ready
* M has higher priority than L
* Scheduler **preempts L**
* M starts executing

Important detail:

* M does **not** need the shared resource
* But M prevents L from running

---

### Step 4: Priority Gets Inverted

Now the situation is:

* H is blocked waiting for L
* L cannot run because M is running
* M runs even though it has lower priority than H

This means:

> **Medium-priority task runs before high-priority task**

This is **Priority Inversion**.

---

## 6. Types of Priority Inversion

---

## 6.1 Bounded Priority Inversion

### Definition

The delay experienced by the high-priority task is **limited and predictable**.

---

### Example Flow

1. L acquires the lock
2. H blocks waiting for L
3. M preempts L and runs
4. M finishes
5. L resumes and releases the lock
6. H finally runs

---

### Key Point

* Delay = execution time of **L (critical section) + M**
* Delay is **finite and bounded**

---

## 6.2 Unbounded Priority Inversion

### Definition

The delay experienced by the high-priority task is **unpredictable or potentially infinite**.

---

### Example Flow

1. L acquires the lock
2. H blocks
3. M preempts L
4. Another medium task arrives
5. Another one arrives again
6. L never gets CPU time
7. Lock is never released

---

### Outcome

* H waits indefinitely
* System may fail
* Watchdog timers may trigger

This is **extremely dangerous** in real-time systems.

---

## 7. Why This Happens (Root Causes)

Priority inversion occurs due to the **combination** of:

* Preemptive scheduling
* Shared resources (locks, mutexes)
* No priority-aware locking policy

Schedulers alone **cannot fix this** without additional rules.

---

## 8. Real-World Example (Conceptual)

This problem famously occurred in:

* **NASAâ€™s Mars Pathfinder Mission**

A low-priority task held a resource needed by a high-priority task.
Medium-priority tasks kept preempting it.
The system repeatedly reset due to missed deadlines.

Solution used:
ðŸ‘‰ **Priority Inheritance**

---

## 9. Solutions to Priority Inversion

---

## 9.1 Priority Inheritance Protocol (Most Important)

### Core Idea

If a low-priority task is blocking a high-priority task:

> Temporarily **raise the priority of the low-priority task**.

---

### How It Works

* L holds a lock needed by H
* H blocks
* OS boosts Lâ€™s priority to Hâ€™s level
* L runs immediately
* L releases the lock
* Lâ€™s priority returns to normal
* H proceeds

---

### Result

* No medium task can preempt L
* Priority inversion is resolved

---

## 9.2 Priority Ceiling Protocol

### Core Idea

* Each resource is assigned a **priority ceiling**
* Only tasks with priority â‰¤ ceiling can lock it

---

### Effect

* Prevents lower-priority tasks from blocking higher-priority ones
* Avoids inversion **before it happens**

Used mainly in **real-time systems**.

---

## 9.3 Avoiding Blocking (Design-Level)

* Reduce shared resources
* Use lock-free or non-blocking algorithms
* Keep critical sections very short

---

## 10. Is Priority Inversion a Deadlock?

**No.**

Difference:

| Aspect           | Priority Inversion   | Deadlock            |
| ---------------- | -------------------- | ------------------- |
| Resource release | Eventually possible  | Never               |
| Cause            | Scheduling + locking | Circular wait       |
| Solution         | Priority protocols   | Deadlock prevention |

---

## 11. Interview Questions

### Basic

1. What is priority inversion?
2. Why does it occur?
3. Where is it most dangerous?

---

### Conceptual

1. Explain priority inversion using L, M, H tasks
2. Difference between bounded and unbounded priority inversion
3. Why canâ€™t the scheduler alone fix it?

---

### Tricky

1. How does priority inheritance solve inversion?

2. Is priority inversion possible without shared resources?
   â†’ No.

3. Is priority inversion a deadlock?
   â†’ No.

---

## 12. Key Takeaways

* Priority inversion is a **scheduling anomaly**
* High-priority tasks may wait due to resource locking
* Medium-priority tasks make the problem worse
* Can be:

  * Bounded
  * Unbounded
* Solved using:

  * Priority Inheritance
  * Priority Ceiling Protocol

> **Priority inversion is not a theory problem â€” it has caused real system failures.**
