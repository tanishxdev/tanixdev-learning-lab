# **Classical IPC Problems (Inter-Process Communication)**

---

## 1. Introduction

In an operating system, **multiple processes often need to communicate and share resources**.

This interaction is called **Inter-Process Communication (IPC)**.

However, when processes run concurrently and share data, several problems arise:

* Race conditions
* Inconsistent data
* Deadlocks
* Starvation

To study and solve these issues, OS theory uses **Classical IPC Problems**.

> These are **model problems**, not real applications, designed to teach **correct synchronization thinking**.

---

## 2. Why Classical IPC Problems Are Important

Classical IPC problems help us understand:

* Why synchronization is necessary
* How incorrect ordering causes bugs
* How tools like **semaphores, mutexes, and monitors** are used
* How deadlock and starvation occur

They form the **foundation of process synchronization** in exams and interviews.

---

## 3. List of Classical IPC Problems

The most important classical problems are:

1. **Producer–Consumer Problem**
2. **Readers–Writers Problem**
3. **Dining Philosophers Problem**
4. **Sleeping Barber Problem**

Each problem focuses on a **different synchronization challenge**.

---

## 4. Producer–Consumer Problem

---

## 4.1 Problem Statement

There are two types of processes:

* **Producer**: produces data items
* **Consumer**: consumes data items

They share a **buffer** of finite size.

---

## 4.2 Core Challenges

* **Buffer Overflow**
  Producer tries to add data when buffer is full
* **Buffer Underflow**
  Consumer tries to remove data when buffer is empty
* **Race Conditions**
  Concurrent access to buffer

---

## 4.3 Key Requirements

* Producer must wait if buffer is full
* Consumer must wait if buffer is empty
* Only one process modifies the buffer at a time

---

## 4.4 Common Solutions

* Semaphores (`empty`, `full`, `mutex`)
* Mutex + condition variables
* Monitors

---

## 4.5 What This Problem Teaches

* Coordination between processes
* Correct ordering of wait and signal
* Use of counting semaphores

---

## 5. Readers–Writers Problem

---

## 5.1 Problem Statement

A shared resource (e.g., database) is accessed by:

* **Readers**: only read data
* **Writers**: modify data

---

## 5.2 Core Rules

* Multiple readers can read **simultaneously**
* Only **one writer** can write at a time
* Readers must not read while a writer is writing

---

## 5.3 Main Challenges

* Balancing performance and correctness
* Preventing starvation

---

## 5.4 Variants of the Problem

### 1. Readers-Preference

* Readers are given priority
* Writers may starve

### 2. Writers-Preference

* Writers are given priority
* Readers may starve

(Some systems use **fair solutions** to balance both.)

---

## 5.5 What This Problem Teaches

* Priority handling
* Starvation issues
* Trade-off between fairness and performance

---

## 6. Dining Philosophers Problem

---

## 6.1 Problem Statement

* Five philosophers sit around a circular table
* Each philosopher needs **two chopsticks** to eat
* Chopsticks are shared between neighbors

---

## 6.2 Core Challenges

* **Deadlock**
  Everyone picks one chopstick and waits forever
* **Starvation**
  Some philosophers never get to eat

---

## 6.3 Why This Problem Is Important

It models:

* Circular wait
* Resource allocation
* Deadlock conditions

---

## 6.4 Common Solutions

* Limit number of philosophers eating
* Asymmetric picking of chopsticks
* Semaphores
* Monitors

---

## 6.5 What This Problem Teaches

* Deadlock prevention
* Resource hierarchy
* Correct locking order

---

## 7. Sleeping Barber Problem

---

## 7.1 Problem Statement

A barber shop has:

* One barber
* One barber chair
* A limited number of waiting chairs

---

## 7.2 Rules

* If no customers → barber sleeps
* If customers arrive and chairs are available → they wait
* If chairs are full → customers leave

---

## 7.3 Core Challenges

* Synchronizing barber and customers
* Avoiding deadlock
* Ensuring fairness

---

## 7.4 Common Solutions

* Semaphores for:

  * Customers
  * Barber
  * Waiting chairs

---

## 7.5 What This Problem Teaches

* Producer-consumer variation
* Fair service scheduling
* Resource availability management

---

## 8. Comparison of Classical IPC Problems

| Problem             | Focus Area       | Main Issue              |
| ------------------- | ---------------- | ----------------------- |
| Producer–Consumer   | Shared buffer    | Overflow / underflow    |
| Readers–Writers     | Shared data      | Read/write conflicts    |
| Dining Philosophers | Shared resources | Deadlock / starvation   |
| Sleeping Barber     | Service system   | Fairness / coordination |

---

## 9. Why These Problems Are “Classical”

They are called *classical* because:

* They appear repeatedly in OS textbooks
* They model real synchronization patterns
* They are language-independent
* They are commonly asked in exams and interviews

---

## 10. Interview Questions

### Basic

1. What are classical IPC problems?
2. Why are they studied?
3. Name some classical IPC problems.

---

### Conceptual

1. What problem does Producer–Consumer model?
2. Difference between readers-preference and writers-preference?
3. Why does Dining Philosophers lead to deadlock?

---

### Tricky

1. Are classical IPC problems real applications?
   → No, they are conceptual models.

2. Which IPC problem best explains deadlock?
   → Dining Philosophers.

---

## 11. Key Takeaways

* Classical IPC problems model **real synchronization challenges**
* Each problem focuses on a **different aspect**:

  * Coordination
  * Fairness
  * Deadlock
  * Starvation
* They teach correct use of:

  * Semaphores
  * Mutexes
  * Monitors
* Understanding them is **mandatory for OS mastery**

> **If you understand classical IPC problems, synchronization becomes intuitive.**
