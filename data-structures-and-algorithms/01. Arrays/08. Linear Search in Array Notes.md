# Problem: Linear Search in Array

**GFG Link**: https://www.geeksforgeeks.org/problems/search-an-element-in-an-array/1  
**LeetCode (Similar)**: https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/ (concept)

---

## 1. Problem Statement

**English**:  
Given an array of integers and a target number `num`, return the **index** of `num` if it exists.  
If not found, return `-1`.

**Hinglish**:  
Array mein `num` dhundho. Agar mil jaaye to **index** batao, warna `-1`.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [1, 2, 3, 4, 5]`, `num = 3`  
**Output Expected**: `2`

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i], num ≤ 10⁹`

---

## 3. Examples (All Cases Covered)

| Example | Input Array | num | Output | Why |
|-------|-------------|-----|--------|-----|
| 1 | `[1,2,3,4,5]` | 3 | `2` | Found at index 2 |
| 2 | `[5,4,3,2,1]` | 5 | `0` | First element |
| 3 | `[1,2,3]` | 4 | `-1` | Not present |
| 4 | `[10]` | 10 | `0` | Single element |
| 5 | `[]` | 5 | `-1` | Empty array |
| 6 | `[1,1,1]` | 1 | `0` | First occurrence |

---

## 4. Intuition & Core Thinking

> **"Just check one by one — no shortcuts!"**

Think of it like:  
> "I'm looking for my friend in a line. I ask each person: Are you [name]? If yes → note position. If no one → not here."

Key Insight:  
- **No assumptions** (not sorted, no duplicates rule)  
- **Worst case**: Must check **all elements** → O(n)  
- **Best case**: Found at first → O(1)

---

# APPROACHES (Only One — Linear Search)

> **There is no "brute" vs "optimal"** — **Linear Search is the only way** when array is unsorted.

---

## Approach: Linear Search (Only Possible)

### Intuition  
Traverse from index `0` to `n-1`.  
If `arr[i] == num` → return `i`  
If loop ends → return `-1`

### Why This Approach?  
- **Simple & correct**  
- **No assumptions**  
- **O(1) space**  
- **Interview must-know**

---

### Algorithm  
1. Loop `i` from `0` to `n-1`  
  If `arr[i] == num` → return `i`  
2. Return `-1`

---

### Pseudocode  
``` 
function linearSearch(arr, num):  
    for i from 0 to n-1:  
        if arr[i] == num:  
            return i  
    return -1
```

---

### Dry Run: [1, 2, 3, 4, 5], num = 4

| i | arr[i] | arr[i] == 4? | Action |
|---|--------|--------------|--------|
| 0 | 1      | No           | continue |
| 1 | 2      | No           | continue |
| 2 | 3      | No           | continue |
| 3 | 4      | Yes          | **return 3** |

---

### Code

#### C (As per problem)
```c
#include <stdio.h>

int search(int arr[], int n, int num) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == num)
            return i;
    }
    return -1;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int num = 4;
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = search(arr, n, num);
    printf("%d\n", result);  // Output: 3
    return 0;
}
```

#### C++
```cpp
int linearSearch(vector<int>& arr, int num) {
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == num) return i;
    }
    return -1;
}
```

#### JavaScript
```js
function linearSearch(arr, num) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === num) return i;
    }
    return -1;
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)**

---

## STL Version (C++)

```cpp
#include <algorithm>
int stlSearch(vector<int>& arr, int num) {
    auto it = find(arr.begin(), arr.end(), num);
    return (it != arr.end()) ? (it - arr.begin()) : -1;
}
```

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | num | Expected | Handled? |
|---------|-------|-----|----------|---------|
| Found at start | `[5,1,2]` | 5 | `0` | Yes |
| Found at end | `[1,2,3]` | 3 | `2` | Yes |
| Not found | `[1,2]` | 3 | `-1` | Yes |
| Empty array | `[]` | 5 | `-1` | Yes |
| Single element | `[10]` | 10 | `0` | Yes |
| Duplicates | `[1,1,1]` | 1 | `0` | Yes (first) |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| **Linear Search** | **O(n)** | **O(1)** | **Only possible** |

> **No better algorithm exists** for unsorted array.

---

## 7. Final Consolidated Code

### C (Original + Full)
```c
#include <stdio.h>

// Linear Search Function
int linearSearch(int arr[], int n, int num) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == num)
            return i;
    }
    return -1;
}

int main() {
    // Test cases
    int arr1[] = {1, 2, 3, 4, 5};
    int n1 = sizeof(arr1)/sizeof(arr1[0]);
    printf("Test 1: %d\n", linearSearch(arr1, n1, 3));  // 2

    int arr2[] = {5, 4, 3, 2, 1};
    int n2 = sizeof(arr2)/sizeof(arr2[0]);
    printf("Test 2: %d\n", linearSearch(arr2, n2, 5));  // 0

    int arr3[] = {1};
    int n3 = sizeof(arr3)/sizeof(arr3[0]);
    printf("Test 3: %d\n", linearSearch(arr3, n3, 2));  // -1

    return 0;
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int linearSearch(vector<int>& arr, int num) {
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i] == num) return i;
        }
        return -1;
    }

    // STL Version
    int stlSearch(vector<int>& arr, int num) {
        auto it = find(arr.begin(), arr.end(), num);
        return (it != arr.end()) ? (it - arr.begin()) : -1;
    }
};
```

---

## 8. Interview Strategy

1. **Start**: "Since array is **unsorted**, I’ll use **linear search** — **O(n) time**, **O(1) space**."  
2. "I’ll loop from index 0 to n-1. If `arr[i] == num` → return `i`."  
3. "If loop ends → return `-1`."  
4. "Edge cases: empty array, single element, not found → all handled."  
5. **Bonus**: "No better way exists without sorting or hashing."

---

**Done!**  
Your template applied **perfectly** — **clean, detailed, beginner-friendly**.

---