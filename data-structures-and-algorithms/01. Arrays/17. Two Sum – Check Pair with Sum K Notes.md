# Problem: Two Sum – Check Pair with Sum K

**GFG Link**: https://www.geeksforgeeks.org/problems/two-sum/1  
**LeetCode Link**: https://leetcode.com/problems/two-sum/

---

## 1. Problem Statement

**English**:  
Given an array of integers and a target sum `target`,  
- **Variant 1**: Return `"YES"` if there exists a pair with sum = `target`, else `"NO"`  
- **Variant 2**: Return the **indices** of the two numbers, else `{-1, -1}`  

**Cannot use same element twice.**

**Hinglish**:  
Array mein do numbers dhundho jinka sum `target` ho.  
- **Variant 1**: `"YES"` ya `"NO"`  
- **Variant 2**: `indices` wapas karo, warna `{-1,-1}`

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [2,6,5,8,11]`, `target = 14`  
**Output**:  
- Variant 1: `"YES"`  
- Variant 2: `[1, 3]` (0-indexed)

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- `target` can be any integer  
- **No duplicates required**, but **same element cannot be used twice**

---

## 3. Examples (All Cases Covered)

| Example | arr | target | Variant 1 | Variant 2 |
|--------|-----|--------|-----------|-----------|
| 1 | `[2,6,5,8,11]` | 14 | `YES` | `[1,3]` |
| 2 | `[1,2,3,4]` | 10 | `NO` | `[-1,-1]` |
| 3 | `[3,3]` | 6 | `YES` | `[0,1]` |
| 4 | `[5]` | 5 | `NO` | `[-1,-1]` |
| 5 | `[-1,1]` | 0 | `YES` | `[0,1]` |

---

## 4. Intuition & Core Thinking

> **"I need one number, and I need to find the other = target - current"**

Key Insight:  
- **HashMap** → store `number → index`  
- For each `arr[i]`, check if `target - arr[i]` exists in map  
- **Insert only after checking** → avoid using same element

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Nested Loops

### Intuition  
For each element, check all others if sum == target.

### Why This?  
- Simple  
- Works always

### Why Move to Next?  
- **O(N²)** → too slow  
- Not acceptable

---

### Code
```cpp
string brute1(vector<int>& arr, int target) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            if (arr[i] + arr[j] == target) return "YES";
        }
    }
    return "NO";
}
```

* Time: **O(N²)**, Space: **O(1)** → **Poor**

---

## Approach 2: Better – HashMap (Optimal for both variants)

### Intuition  
> **Store seen numbers with index**  
> For each `x`, check if `target - x` is already seen

### Why This is Final?  
- **O(N)** time  
- **O(N)** space  
- **Works for both variants**  
- **Interview favorite**

---

### Algorithm  
``` 
map<number, index>
for i from 0 to n-1:
    need = target - arr[i]
    if need in map:
        return "YES" or {map[need], i}
    map[arr[i]] = i
return "NO" or {-1,-1}
```

> **Insert after check** → avoid self-pair

---

### Dry Run: [2,6,5,8,11], target=14

| i | arr[i] | need | map | Action |
|---|--------|------|-----|-------|
| 0 | 2      | 12   | {}  | Insert 2→0 |
| 1 | 6      | 8    | {2:0} | Insert 6→1 |
| 2 | 5      | 9    | {2:0,6:1} | Insert 5→2 |
| 3 | 8      | 6    | {2:0,6:1,5:2} | **6 exists!** → return `[1,3]` |

**Final**: `[1,3]` → Correct!

---

### Code

#### C++ (Variant 1)
```cpp
string twoSum1(vector<int>& arr, int target) {
    unordered_map<int, int> seen;
    for (int i = 0; i < arr.size(); i++) {
        int need = target - arr[i];
        if (seen.count(need)) return "YES";
        seen[arr[i]] = i;
    }
    return "NO";
}
```

#### C++ (Variant 2)
```cpp
vector<int> twoSum2(vector<int>& arr, int target) {
    unordered_map<int, int> seen;
    for (int i = 0; i < arr.size(); i++) {
        int need = target - arr[i];
        if (seen.count(need)) {
            return {seen[need], i};
        }
        seen[arr[i]] = i;
    }
    return {-1, -1};
}
```

* Time: **O(N)**, Space: **O(N)** → **BEST**

---

## Approach 3: Two Pointers (Only for Variant 1, if sorting allowed)

### Intuition  
Sort → `left` and `right` pointers → move based on sum.

### Why Not for Variant 2?  
- **Sorting destroys indices**

### Code
```cpp
string twoSumSorted(vector<int> arr, int target) {
    sort(arr.begin(), arr.end());
    int left = 0, right = arr.size() - 1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == target) return "YES";
        else if (sum < target) left++;
        else right--;
    }
    return "NO";
}
```

* Time: **O(N log N)**, Space: **O(1)** → **Good for Variant 1 only**

---

## 5. Edge Case List (Line-wise)

| Edge Case | arr | target | Expected | Handled? |
|---------|-----|--------|----------|---------|
| Same element twice | `[3,3]` | 6 | `YES` | Yes |
| Single element | `[5]` | 5 | `NO` | Yes |
| Negative numbers | `[-1,1]` | 0 | `YES` | Yes |
| No pair | `[1,2]` | 10 | `NO` | Yes |
| Large array | 10⁵ elements | Correct | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Variant 1 | Variant 2 |
|--------|------|-------|----------|----------|
| Brute | O(N²) | O(1) | Yes | Yes |
| **HashMap** | **O(N)** | **O(N)** | Yes | **Yes (BEST)** |
| Two Pointers | O(N log N) | O(1) | Yes | No |

---

## 7. Final Consolidated Code

### C++ (All Variants)
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Variant 1: YES/NO
    string twoSum1(vector<int>& arr, int target) {
        unordered_map<int, int> seen;
        for (int i = 0; i < arr.size(); i++) {
            if (seen.count(target - arr[i])) return "YES";
            seen[arr[i]] = i;
        }
        return "NO";
    }

    // Variant 2: Indices
    vector<int> twoSum2(vector<int>& arr, int target) {
        unordered_map<int, int> seen;
        for (int i = 0; i < arr.size(); i++) {
            int need = target - arr[i];
            if (seen.count(need)) {
                return {seen[need], i};
            }
            seen[arr[i]] = i;
        }
        return {-1, -1};
    }

    // Two Pointers (Variant 1 only)
    string twoSumSorted(vector<int> arr, int target) {
        sort(arr.begin(), arr.end());
        int l = 0, r = arr.size() - 1;
        while (l < r) {
            int sum = arr[l] + arr[r];
            if (sum == target) return "YES";
            sum < target ? l++ : r--;
        }
        return "NO";
    }
};
```

### JavaScript
```javascript
class Solution {
    // Variant 2: Return indices
    twoSum(arr, target) {
        let seen = new Map();
        for (let i = 0; i < arr.length; i++) {
            let need = target - arr[i];
            if (seen.has(need)) {
                return [seen.get(need), i];
            }
            seen.set(arr[i], i);
        }
        return [-1, -1];
    }

    // Variant 1: YES/NO
    twoSumYesNo(arr, target) {
        let seen = new Set();
        for (let x of arr) {
            if (seen.has(target - x)) return "YES";
            seen.add(x);
        }
        return "NO";
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I’ll use **HashMap** — **O(N) time**, **O(N) space**."  
2. "For each element `x`, check if `target - x` is already seen."  
3. "Insert **after** checking → avoid self-pair."  
4. "For **Variant 2**, store `number → index`. For **Variant 1**, use `Set`."  
5. **Bonus**: "Two pointers work only if **sorting is allowed** and **indices not needed**."

---
