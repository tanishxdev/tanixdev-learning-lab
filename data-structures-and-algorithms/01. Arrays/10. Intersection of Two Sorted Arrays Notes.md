# Problem: Intersection of Two Sorted Arrays

**GFG Link**: https://www.geeksforgeeks.org/problems/intersection-of-two-arrays/1  
**LeetCode (Similar)**: https://leetcode.com/problems/intersection-of-two-arrays/

---

## 1. Problem Statement

**English**:  
Given two **sorted arrays** `arr1` and `arr2`, find their **intersection** — all **common elements** in **ascending order**.  
**Duplicates should appear only once** (if present in both).

**Hinglish**:  
Do sorted arrays ka **intersection** nikalo — jo elements **dono mein hain**, **ek baar**, **chhote se bade** order mein.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr1 = [1,2,2,3,4]`, `arr2 = [2,2,4,5]`  
**Output Expected**: `[2,4]`

**Constraints**:  
- `1 ≤ n, m ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- Arrays are **sorted in non-decreasing order**

---

## 3. Examples (All Cases Covered)

| Example | arr1 | arr2 | Output | Why |
|-------|------|------|--------|-----|
| 1 | `[1,2,2,3,4]` | `[2,2,4,5]` | `[2,4]` | Duplicates → only once |
| 2 | `[1,2,3,4,5]` | `[3,4,5,6]` | `[3,4,5]` | Multiple common |
| 3 | `[1,2]` | `[3,4]` | `[]` | No common |
| 4 | `[1,1,1]` | `[1,1]` | `[1]` | Duplicates handled |
| 5 | `[]` | `[1,2]` | `[]` | One empty |
| 6 | `[5]` | `[5]` | `[5]` | Single match |

---

## 4. Intuition & Core Thinking

> **Since arrays are sorted → use two pointers like merge!**

Think of it like:  
> "I’m walking through two sorted lists. When I find a **match**, I add it **once** and move both pointers."

Key Insight:  
- Use **two pointers** (`i`, `j`)  
- Only add when `arr1[i] == arr2[j]`  
- Skip duplicates by moving **both** when equal  
- Result is **sorted + unique**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Using Set / Map (Easy but Slower)

### Intuition  
Insert all from `arr1` → check `arr2` elements in set.

### Why This Approach?  
- Easy  
- Works for **unsorted**  
- Handles duplicates

### Why Move to Next?  
- **O(m+n) space**  
- **O((m+n) log(m+n))** if using `map`  
- **Slower**

---

### Code (Set)

#### C++
```cpp
vector<int> intersectionWithSet(vector<int>& a, vector<int>& b) {
    unordered_set<int> s(a.begin(), a.end());
    vector<int> res;
    for (int x : b) {
        if (s.count(x)) {
            res.push_back(x);
            s.erase(x); // remove to avoid duplicate
        }
    }
    return res;
}
```

* Time: **O(m + n)**, Space: **O(n)**

---

## Approach 2: Two Pointers (Optimal & Fastest)

### Intuition  
> **Merge-style traversal**

Use:
- `i` → pointer in `arr1`  
- `j` → pointer in `arr2`  
- `res` vector for result

**Only add when equal and not duplicate**

### Why This Approach?  
- **O(m + n) time**  
- **O(1) extra space** (output excluded)  
- **In-place style**  
- **Interview favorite**

### Why This is Final?  
- **Optimal**  
- Uses sorted property  
- No extra space

---

### Algorithm  
``` 
i = 0, j = 0
res = []

while i < n and j < m:
    if arr1[i] < arr2[j]:
        i++
    else if arr1[i] > arr2[j]:
        j++
    else:
        # Equal → add only if not duplicate
        if res empty or res.back() != arr1[i]:
            res.push(arr1[i])
        i++, j++
```

---

### Dry Run: [1,2,2,3,4], [2,2,4,5]

| i | j | arr1[i] | arr2[j] | Action | res |
|---|---|---------|---------|--------|-----|
| 0 | 0 | 1       | 2       | 1<2 → i++ | [] |
| 1 | 0 | 2       | 2       | equal → add 2 | [2] |
| 2 | 1 | 2       | 2       | equal → skip (last=2) | [2] |
| 3 | 2 | 3       | 4       | 3<4 → i++ | [2] |
| 4 | 2 | 4       | 4       | equal → add 4 | [2,4] |
| 4 | 3 | 4       | 5       | 4<5 → i++ | [2,4] |

---

### Code

#### C++ (Optimal)
```cpp
vector<int> findIntersection(vector<int>& arr1, vector<int>& arr2) {
    int n = arr1.size(), m = arr2.size();
    int i = 0, j = 0;
    vector<int> res;

    while (i < n && j < m) {
        if (arr1[i] < arr2[j]) {
            i++;
        } else if (arr1[i] > arr2[j]) {
            j++;
        } else {
            // Equal
            if (res.empty() || res.back() != arr1[i]) {
                res.push_back(arr1[i]);
            }
            i++;
            j++;
        }
    }

    return res;
}
```

#### JavaScript
```js
function findIntersection(arr1, arr2) {
    let n = arr1.length, m = arr2.length;
    let i = 0, j = 0;
    let res = [];

    while (i < n && j < m) {
        if (arr1[i] < arr2[j]) {
            i++;
        } else if (arr1[i] > arr2[j]) {
            j++;
        } else {
            if (res.length === 0 || res[res.length-1] !== arr1[i]) {
                res.push(arr1[i]);
            }
            i++;
            j++;
        }
    }

    return res;
}
```

* Time: **O(m + n)**, Space: **O(1)** (output excluded)

---

## 5. Edge Case List (Line-wise)

| Edge Case | arr1 | arr2 | Expected | Handled? |
|---------|------|------|----------|---------|
| No common | `[1,2]` | `[3,4]` | `[]` | Yes |
| All common | `[1,1]` | `[1,1]` | `[1]` | Yes |
| One empty | `[]` | `[1]` | `[]` | Yes |
| Duplicates | `[2,2]` | `[2,2]` | `[2]` | Yes |
| Single match | `[5]` | `[5]` | `[5]` | Yes |
| Large arrays | 10⁵ elements | 10⁵ elements | Correct | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Set | O(m + n) | O(n) | Learning |
| **Two Pointers** | **O(m + n)** | **O(1)** | **Interviews (Optimal)** |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Using Set
    vector<int> intersectionWithSet(vector<int>& a, vector<int>& b) {
        unordered_set<int> s(a.begin(), a.end());
        vector<int> res;
        for (int x : b) {
            if (s.count(x)) {
                res.push_back(x);
                s.erase(x);
            }
        }
        return res;
    }

    // Optimal: Two Pointers
    vector<int> findIntersection(vector<int>& arr1, vector<int>& arr2) {
        int n = arr1.size(), m = arr2.size();
        int i = 0, j = 0;
        vector<int> res;

        while (i < n && j < m) {
            if (arr1[i] < arr2[j]) {
                i++;
            } else if (arr1[i] > arr2[j]) {
                j++;
            } else {
                if (res.empty() || res.back() != arr1[i]) {
                    res.push_back(arr1[i]);
                }
                i++;
                j++;
            }
        }

        return res;
    }
};
```

### JavaScript
```javascript
class Solution {
    // Set Method
    intersectionWithSet(a, b) {
        let s = new Set(a);
        let res = [];
        for (let x of b) {
            if (s.has(x)) {
                res.push(x);
                s.delete(x);
            }
        }
        return res;
    }

    // Two Pointers
    findIntersection(arr1, arr2) {
        let n = arr1.length, m = arr2.length;
        let i = 0, j = 0;
        let res = [];

        while (i < n && j < m) {
            if (arr1[i] < arr2[j]) {
                i++;
            } else if (arr1[i] > arr2[j]) {
                j++;
            } else {
                if (res.length === 0 || res[res.length-1] !== arr1[i]) {
                    res.push(arr1[i]);
                }
                i++;
                j++;
            }
        }

        return res;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since arrays are **sorted**, I’ll use **two pointers** to find intersection in **O(m+n) time**."  
2. "I’ll move the smaller pointer. When equal → add **once** and move **both**."  
3. "Skip duplicates by checking last inserted."  
4. "Edge cases: no common, duplicates, empty → handled."  
5. **Bonus**: "Set uses O(n) space. This is **optimal**."

---