# Problem: 3Sum – Find Unique Triplets That Sum to Zero

**LeetCode**: https://leetcode.com/problems/3sum/  
**GFG**: https://www.geeksforgeeks.org/find-triplets-array-whose-sum-equal-zero/

---

## 1. Problem Statement

**English**:  
Given an integer array `nums`, return **all unique triplets** `[a, b, c]` such that:  
- `a + b + c = 0`  
- `i ≠ j ≠ k` (distinct indices)  
- No duplicate triplets in output

**Hinglish**:  
Array mein unique triplets dhundho jinka sum zero ho.  
Duplicate triplets nahi chahiye → `[1, -1, 0]` aur `[ -1, 0, 1 ]` same hai.

---

## 2. Input / Output / Constraints

**Example 1**  
Input: `nums = [-1,0,1,2,-1,-4]`  
Output: `[[-1,-1,2], [-1,0,1]]`

**Example 2**  
Input: `nums = [0,0,0,0]`  
Output: `[[0,0,0]]`

**Constraints**  
- `3 ≤ nums.length ≤ 3000`  
- `-10⁵ ≤ nums[i] ≤ 10⁵`

---

## 3. Examples (All Cases Covered)

| Input | Output | Why |
|------|--------|-----|
| `[-1,0,1,2,-1,-4]` | `[[-1,-1,2],[-1,0,1]]` | Correct |
| `[0,0,0]` | `[[0,0,0]]` | All same |
| `[1,2,-3]` | `[[1,2,-3]]` | One triplet |
| `[]` or `[1]` | `[]` | Invalid size |
| `[1,1,1]` | `[]` | No zero sum |
| `[-2,0,1,1,2]` | `[[-2,0,2],[-2,1,1]]` | Duplicates handled |

---

# APPROACHES (Brute → Optimal) – All 3 with Full Commented Code

---

## Approach 1: Brute Force – 3 Nested Loops + Set

### Intuition  
Try every possible triplet → sort → insert into set → removes duplicates

```cpp
// Brute Force - O(N³ log M) | M = unique triplets
vector<vector<int>> threeSumBrute(vector<int>& nums) {
    int n = nums.size();
    set<vector<int>> uniqueTriplets;  // auto sorts & removes duplicates

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    vector<int> triplet = {nums[i], nums[j], nums[k]};
                    sort(triplet.begin(), triplet.end());
                    uniqueTriplets.insert(triplet);
                }
            }
        }
    }

    vector<vector<int>> result(uniqueTriplets.begin(), uniqueTriplets.end());
    return result;
}
```

*Time: O(N³ log M)*  
*Space: O(M)* → M = number of unique triplets

---

## Approach 2: Better – Two Pointer + HashSet (Per Fixed i)

### Intuition  
Fix `i` → for each `j > i`, search for `-(nums[i]+nums[j])` in a set of remaining elements

```cpp
// Better - O(N²) Time, O(N) Space
vector<vector<int>> threeSumBetter(vector<int>& nums) {
    int n = nums.size();
    set<vector<int>> st;

    for (int i = 0; i < n; i++) {
        unordered_set<int> seen;  // stores elements after index i

        for (int j = i + 1; j < n; j++) {
            int third = -(nums[i] + nums[j]);

            if (seen.count(third)) {
                vector<int> triplet = {nums[i], nums[j], third};
                sort(triplet.begin(), triplet.end());
                st.insert(triplet);
            }
            seen.insert(nums[j]);  // insert current j for future lookups
        }
    }

    vector<vector<int>> result(st.begin(), st.end());
    return result;
}
```

*Time: O(N²)*  
*Space: O(N)*

---

## Approach 3: Optimal – Sorting + Two Pointers (Best)

### Intuition  
**Sort the array** → Fix `i` → Use two pointers `j` and `k` → Skip duplicates

**This is the gold standard for 3Sum**

```cpp
// Optimal - O(N²) Time, O(1) Extra Space (excluding output)
vector<vector<int>> threeSumOptimal(vector<int>& nums) {
    int n = nums.size();
    vector<vector<int>> ans;
    
    sort(nums.begin(), nums.end());  // Crucial step

    for (int i = 0; i < n; i++) {
        // Skip duplicate values for i
        if (i > 0 && nums[i] == nums[i-1]) continue;

        int j = i + 1;
        int k = n - 1;

        while (j < k) {
            long long sum = (long long)nums[i] + nums[j] + nums[k];  // prevent overflow

            if (sum == 0) {
                ans.push_back({nums[i], nums[j], nums[k]});
                
                // Skip duplicates for j and k
                while (j < k && nums[j] == nums[j+1]) j++;
                while (j < k && nums[k] == nums[k-1]) k--;

                j++;
                k--;
            }
            else if (sum < 0) {
                j++;  // need larger sum
            }
            else {
                k--;  // need smaller sum
            }
        }
    }
    return ans;
}
```

*Time: O(N log N + N²) → O(N²)*  
*Space: O(1)* (excluding output) → **Best possible**

---

## 5. Edge Case List

| Case | Input | Output | Handled? |
|------|------|--------|---------|
| All zeros | `[0,0,0,0]` | `[[0,0,0]]` | Yes |
| Duplicates | `[-1,-1,-1,0,0,1,1]` | `[[-1,0,1]]` | Yes |
| No solution | `[1,2,3]` | `[]` | Yes |
| Large numbers | `[-100000,100000,0]` | `[]` | Use `long long` for sum |
| Minimum size | `[0,0,0]` | `[[0,0,0]]` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute (3 loops + set) | O(N³ log M) | O(M) | Learning |
| Better (HashSet per i) | O(N²) | O(N) | Simplicity |
| **Optimal (Sort + 2Ptr)** | **O(N²)** | **O(1)** | **Interviews** |

**Always use Optimal in interviews**

---

## 7. Final Consolidated Code (All 3 Approaches – Fully Commented)

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute Force - 3 Loops + Set
    vector<vector<int>> brute(vector<int>& nums) {
        set<vector<int>> st;
        int n = nums.size();

        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                for (int k = j+1; k < n; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        vector<int> temp = {nums[i], nums[j], nums[k]};
                        sort(temp.begin(), temp.end());
                        st.insert(temp);
                    }
                }
            }
        }
        return vector<vector<int>>(st.begin(), st.end());
    }

    // 2. Better - Fix i + HashSet for remaining
    vector<vector<int>> better(vector<int>& nums) {
        int n = nums.size();
        set<vector<int>> st;

        for (int i = 0; i < n; i++) {
            unordered_set<int> seen;
            for (int j = i+1; j < n; j++) {
                int target = -(nums[i] + nums[j]);
                if (seen.count(target)) {
                    vector<int> temp = {nums[i], nums[j], target};
                    sort(temp.begin(), temp.end());
                    st.insert(temp);
                }
                seen.insert(nums[j]);
            }
        }
        return vector<vector<int>>(st.begin(), st.end());
    }

    // 3. Optimal - Sorting + Two Pointers (BEST)
    vector<vector<int>> optimal(vector<int>& nums) {
        vector<vector<int>> ans;
        int n = nums.size();
        sort(nums.begin(), nums.end());

        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i-1]) continue;  // skip duplicate i

            int j = i + 1;
            int k = n - 1;

            while (j < k) {
                long long sum = (long long)nums[i] + nums[j] + nums[k];

                if (sum == 0) {
                    ans.push_back({nums[i], nums[j], nums[k]});
                    while (j < k && nums[j] == nums[j+1]) j++;
                    while (j < k && nums[k] == nums[k-1]) k--;
                    j++; k--;
                }
                else if (sum < 0) j++;
                else k--;
            }
        }
        return ans;
    }
};
```

### JavaScript
```javascript
class Solution {
    // Brute Force
    brute(nums) {
        let set = new Set();
        let n = nums.length;

        for (let i = 0; i < n; i++) {
            for (let j = i+1; j < n; j++) {
                for (let k = j+1; k < n; k++) {
                    if (nums[i] + nums[j] + nums[k] === 0) {
                        let triplet = [nums[i], nums[j], nums[k]].sort((a,b) => a-b);
                        set.add(triplet.join(','));
                    }
                }
            }
        }
        return Array.from(set).map(s => s.split(',').map(Number));
    }

    // Optimal
    optimal(nums) {
        nums.sort((a, b) => a - b);
        let ans = [];
        let n = nums.length;

        for (let i = 0; i < n; i++) {
            if (i > 0 && nums[i] === nums[i-1]) continue;

            let j = i + 1;
            let k = n - 1;

            while (j < k) {
                let sum = nums[i] + nums[j] + nums[k];

                if (sum === 0) {
                    ans.push([nums[i], nums[j], nums[k]]);
                    while (j < k && nums[j] === nums[j+1]) j++;
                    while (j < k && nums[k] === nums[k-1]) k--;
                    j++; k--;
                }
                else if (sum < 0) j++;
                else k--;
            }
        }
        return ans;
    }
}
```

---

## 8. Interview Strategy

1. **Clarify**: "Do we need unique triplets? Order doesn't matter?" → Yes
2. **Start**: "I'll sort the array and use two pointers → O(N²) time, O(1) space"
3. "Sorting helps skip duplicates and enables two-pointer"
4. "For each fixed i, j and k move based on sum"
5. "Skip duplicates at all three levels"
6. **Bonus**: "This is the standard way to solve any 3Sum / 4Sum variant"

**100/100 in interviews**

---