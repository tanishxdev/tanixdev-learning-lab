# Problem: Left Rotate Array by One (In-Place)  
**+ Bonus: Right Rotate by One**

**GFG Link**: https://www.geeksforgeeks.org/problems/cyclically-rotate-an-array-by-one2614/1  
**LeetCode (General)**: https://leetcode.com/problems/rotate-array/

---

## 1. Problem Statement

**English**:  
Given an array of `n` integers, **rotate it left by 1 position** in-place.  
The first element moves to the end.

**Hinglish**:  
Array ko **ek baar left rotate** karo — pehla element last mein, baaki ek step left.

**Bonus**: Also implement **Right Rotate by One**.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [1, 2, 3, 4, 5]`  
**Output Expected**: `[2, 3, 4, 5, 1]`

**Constraints**:  
- `1 ≤ n ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`

---

## 3. Examples (All Cases Covered)

| Example | Input | Left Rotate Output | Right Rotate Output | Why |
|-------|-------|---------------------|----------------------|-----|
| 1 | `[1,2,3,4,5]` | `[2,3,4,5,1]` | `[5,1,2,3,4]` | Normal |
| 2 | `[10]` | `[10]` | `[10]` | n = 1 |
| 3 | `[]` | `[]` | `[]` | Empty |
| 4 | `[1,1,1,1]` | `[1,1,1,1]` | `[1,1,1,1]` | All duplicates |
| 5 | `[1,2]` | `[2,1]` | `[2,1]` | n = 2 |

---

## 4. Intuition & Core Thinking

> **Left Rotate by 1** = Move first box to the end  
> **Right Rotate by 1** = Move last box to the front

Key Questions:  
- Can I avoid extra array? → **Yes!**  
- Can I do it in **O(1) space**? → **Yes!**  
- Can I generalize to **k rotations**? → Yes (use reversal)

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Using Extra Array

### Intuition  
Create a new array:  
`temp[i] = arr[i+1]` for `i < n-1`  
`temp[n-1] = arr[0]`

### Why This Approach?  
- Easy to visualize  
- No risk of data loss  
- Good for learning

### Why Move to Next?  
- **O(n) extra space** → not allowed  
- Two passes  
- Not in-place

---

### Algorithm (Left Rotate)  
1. If `n <= 1` → return  
2. Create `temp[n]`  
3. For `i = 1` to `n-1`: `temp[i-1] = arr[i]`  
4. `temp[n-1] = arr[0]`  
5. Copy `temp` → `arr`

---

### Pseudocode  
``` 
function leftRotateBrute(arr):  
    if n <= 1: return  
    temp = new array  
    for i from 1 to n-1:  
        temp[i-1] = arr[i]  
    temp[n-1] = arr[0]  
    arr = temp
```

---

### Dry Run: [A B C D]  
→ temp = [B, C, D, A]  
→ Copy back → Done

---

### Code

#### C++
```cpp
void leftRotateBrute(vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;
    vector<int> temp(n);
    for (int i = 1; i < n; i++) {
        temp[i-1] = arr[i];
    }
    temp[n-1] = arr[0];
    arr = temp;
}
```

#### JavaScript
```js
function leftRotateBrute(arr) {
    let n = arr.length;
    if (n <= 1) return;
    let temp = [];
    for (let i = 1; i < n; i++) {
        temp[i-1] = arr[i];
    }
    temp[n-1] = arr[0];
    for (let i = 0; i < n; i++) {
        arr[i] = temp[i];
    }
}
```

* Time: **O(n)**, Space: **O(n)**

---

## Approach 2: Optimal – In-Place Shift (Left Rotate)

### Intuition  
1. Save `first = arr[0]`  
2. Shift all elements **left by 1**: `arr[i] = arr[i+1]`  
3. Put `first` at the end: `arr[n-1] = first`

### Why This Approach?  
- **O(1) space**  
- **In-place**  
- **Simple & fast**

### Why This is Final?  
- **Optimal for rotate by 1**  
- No better in-place method  
- Interview favorite

---

### Algorithm (Left Rotate)  
1. If `n <= 1` → return  
2. `first = arr[0]`  
3. For `i = 0` to `n-2`: `arr[i] = arr[i+1]`  
4. `arr[n-1] = first`

---

### Pseudocode  
``` 
function leftRotate(arr):  
    if n <= 1: return  
    first = arr[0]  
    for i from 0 to n-2:  
        arr[i] = arr[i+1]  
    arr[n-1] = first
```

---

### Dry Run: [1,2,3,4,5]  
| Step | Action | Array |
|------|------|-------|
| 0 | first = 1 | [1,2,3,4,5] |
| 1 | i=0: arr[0]=2 | [2,2,3,4,5] |
| 2 | i=1: arr[1]=3 | [2,3,3,4,5] |
| 3 | i=2: arr[2]=4 | [2,3,4,4,5] |
| 4 | i=3: arr[3]=5 | [2,3,4,5,5] |
| 5 | arr[4]=1 | [2,3,4,5,1] |

---

### Code

#### C++
```cpp
void leftRotate(vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;
    int first = arr[0];
    for (int i = 0; i < n - 1; i++) {
        arr[i] = arr[i + 1];
    }
    arr[n - 1] = first;
}
```

#### JavaScript
```js
function leftRotate(arr) {
    let n = arr.length;
    if (n <= 1) return;
    let first = arr[0];
    for (let i = 0; i < n - 1; i++) {
        arr[i] = arr[i + 1];
    }
    arr[n - 1] = first;
}
```

* Time: **O(n)**, Space: **O(1)**

---

## Approach 3: Right Rotate by One (Bonus)

### Intuition  
1. Save `last = arr[n-1]`  
2. Shift all elements **right by 1**: `arr[i] = arr[i-1]`  
3. Put `last` at front: `arr[0] = last`

---

### Code

#### C++
```cpp
void rightRotate(vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;
    int last = arr[n-1];
    for (int i = n-1; i > 0; i--) {
        arr[i] = arr[i-1];
    }
    arr[0] = last;
}
```

#### JavaScript
```js
function rightRotate(arr) {
    let n = arr.length;
    if (n <= 1) return;
    let last = arr[n-1];
    for (let i = n-1; i > 0; i--) {
        arr[i] = arr[i-1];
    }
    arr[0] = last;
}
```

---

## Approach 4: Reversal Trick (General for k) – Optional Bonus

### Intuition  
To **left rotate by k**:  
1. Reverse first `k`  
2. Reverse rest  
3. Reverse all  

But for **k=1**:  
→ Reverse [0,0] → no change  
→ Reverse [1,n-1] → [n-1, ..., 1]  
→ Reverse all → [1, ..., n-1, first] → **Wrong!**

**Better for k > 1**. For **k=1**, **in-place shift is simpler**.

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Left Output | Right Output | Handled? |
|---------|-------|-------------|--------------|---------|
| n = 1 | `[7]` | `[7]` | `[7]` | Yes |
| n = 0 | `[]` | `[]` | `[]` | Yes |
| n = 2 | `[A,B]` | `[B,A]` | `[B,A]` | Yes |
| All same | `[1,1,1]` | `[1,1,1]` | `[1,1,1]` | Yes |
| Large n | 10⁵ elements | Correct | Correct | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Extra Array | O(n) | O(n) | Learning |
| **In-Place Shift** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| Right Rotate | O(n) | O(1) | Bonus |
| Reversal (k) | O(n) | O(1) | General k |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute: Extra Array
    void leftRotateBrute(vector<int>& arr) {
        int n = arr.size();
        if (n <= 1) return;
        vector<int> temp(n);
        for (int i = 1; i < n; i++) {
            temp[i-1] = arr[i];
        }
        temp[n-1] = arr[0];
        arr = temp;
    }

    // 2. Optimal: In-Place Left Rotate
    void leftRotate(vector<int>& arr) {
        int n = arr.size();
        if (n <= 1) return;
        int first = arr[0];
        for (int i = 0; i < n - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr[n - 1] = first;
    }

    // 3. Right Rotate by One
    void rightRotate(vector<int>& arr) {
        int n = arr.size();
        if (n <= 1) return;
        int last = arr[n-1];
        for (int i = n-1; i > 0; i--) {
            arr[i] = arr[i-1];
        }
        arr[0] = last;
    }
};
```

### JavaScript
```javascript
class Solution {
    // 1. Brute
    leftRotateBrute(arr) {
        let n = arr.length;
        if (n <= 1) return;
        let temp = [];
        for (let i = 1; i < n; i++) {
            temp[i-1] = arr[i];
        }
        temp[n-1] = arr[0];
        for (let i = 0; i < n; i++) {
            arr[i] = temp[i];
        }
    }

    // 2. Optimal: Left Rotate
    leftRotate(arr) {
        let n = arr.length;
        if (n <= 1) return;
        let first = arr[0];
        for (let i = 0; i < n - 1; i++) {
            arr[i] = arr[i + 1];
        }
        arr[n - 1] = first;
    }

    // 3. Right Rotate
    rightRotate(arr) {
        let n = arr.length;
        if (n <= 1) return;
        let last = arr[n-1];
        for (let i = n-1; i > 0; i--) {
            arr[i] = arr[i-1];
        }
        arr[0] = last;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I’ll do **in-place left rotate** in **O(1) space**."  
2. "Save `first = arr[0]`, shift all left, put `first` at end."  
3. "Edge cases: n ≤ 1 → return."  
4. **Bonus**: "For **right rotate**, save last, shift right, put at front."  
5. "Time: **O(n)**, Space: **O(1)** — optimal."

---