# Problem: Find the Repeating and Missing Number  
**(Classic Interview Problem – Numbers from 1 to N, one duplicate, one missing)**

**GFG Link**: https://www.geeksforgeeks.org/problems/find-missing-and-repeating2512/1  
**LeetCode Similar**: https://leetcode.com/problems/find-the-duplicate-number/ (but different constraints)

---

## 1. Problem Statement

**English**:  
Given a read-only array of `N` integers with values in range **[1, N]**, exactly **one number appears twice** (repeating), and **one number is missing**.  
Find and return `{repeating, missing}`.

**Hinglish**:  
1 se N tak numbers hain, ek number do baar aa raha hai, ek bilkul missing hai. Dono ko dhundho.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [3, 1, 2, 5, 4, 6, 7, 5]`, `N = 8`  
**Output Expected**: `{5, 8}`  

**Constraints**:  
- `2 ≤ N ≤ 10⁵`  
- Numbers are from `1` to `N`  
- Exactly **one duplicate**, **one missing**

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[3,1,2,5,4,6,7,5]` | `{5,8}` | 5 repeated, 8 missing |
| 2 | `[1,2,2]` | `{2,3}` | Smallest case |
| 3 | `[4,3,6,2,1,1]` | `{1,5}` | 1 repeated, 5 missing |
| 4 | `[2,1]` | `{2,3}` or `{1,3}` wait no → must be `{2,3}` | 2 repeated, 3 missing |

---

## 4. Intuition & Core Thinking

This is a **pigeonhole principle** problem.  
We have N numbers in N-sized array → one must repeat, one must miss.

Key Insight:  
> We can treat the array as a **graph** where index → value is an edge.  
> Or use **math**, **hashing**, or **bit manipulation**.

We’ll cover **all 5 standard approaches** — from brute to god-level XOR.

---

# APPROACHES (Brute → God-Level)

---

## Approach 1: Brute Force – Count Each Number

### Intuition  
For each number from 1 to N → count how many times it appears in array.

### Why This Approach?  
- Easiest to think  
- Teaches counting logic

### Why Move to Next?  
- O(N²) → TLE  
- Too slow

---

### Algorithm  
1. For i from 1 to N:  
  Count occurrences of i in array  
  If count == 2 → repeating  
  If count == 0 → missing

---

### Dry Run: [3,1,2,5,4,6,7,5]  
- i=1 → appears 1  
- i=5 → appears 2 → repeating = 5  
- i=8 → appears 0 → missing = 8

---

### Code

#### C++
```cpp
vector<int> brute(vector<int>& a) {
    int n = a.size();
    int repeating = -1, missing = -1;
    for (int i = 1; i <= n; i++) {
        int cnt = 0;
        for (int j = 0; j < n; j++) {
            if (a[j] == i) cnt++;
        }
        if (cnt == 2) repeating = i;
        if (cnt == 0) missing = i;
    }
    return {repeating, missing};
}
```

#### JavaScript
```js
function brute(a) {
    let n = a.length;
    let repeating = -1, missing = -1;
    for (let i = 1; i <= n; i++) {
        let cnt = a.filter(x => x === i).length;
        if (cnt === 2) repeating = i;
        if (cnt === 0) missing = i;
    }
    return [repeating, missing];
}
```

* Time: O(N²)  
* Space: O(1)

---

## Approach 2: Better – Hash Array (Frequency Count)

### Intuition  
Use a frequency array of size `N+1` → count occurrences.

### Why This Approach?  
- Simple upgrade from brute  
- O(N) time

### Why Move to Next?  
- Uses O(N) extra space  
- Not in-place

---

### Code

#### C++
```cpp
vector<int> better(vector<int>& a) {
    int n = a.size();
    vector<int> hash(n + 1, 0);
    for (int x : a) hash[x]++;
    
    int repeating = -1, missing = -1;
    for (int i = 1; i <= n; i++) {
        if (hash[i] == 2) repeating = i;
        if (hash[i] == 0) missing = i;
    }
    return {repeating, missing};
}
```

#### JavaScript
```js
function better(a) {
    let n = a.length;
    let hash = new Array(n + 1).fill(0);
    for (let x of a) hash[x]++;
    
    let repeating = -1, missing = -1;
    for (let i = 1; i <= n; i++) {
        if (hash[i] === 2) repeating = i;
        if (hash[i] === 0) missing = i;
    }
    return [repeating, missing];
}
```

* Time: O(N)  
* Space: O(N)

---

## Approach 3: Optimal 1 – Mathematics (Sum & Sum of Squares)

### Intuition  
Use algebra:  
- `S_actual - S_expected = repeating - missing`  
- `S2_actual - S2_expected = repeating² - missing² = (repeating - missing)(repeating + missing)`

### Why This Approach?  
- O(N) time  
- O(1) space  
- Elegant math

### Why Move to Next?  
- Risk of **integer overflow** (use `long long`)  
- Slightly tricky derivation

---

### Algorithm  
1. `S = sum(arr)`, `Sn = n*(n+1)/2` → `S - Sn = X - Y`  
2. `S2 = sum(arr²)`, `S2n = n*(n+1)*(2n+1)/6` → `S2 - S2n = X² - Y²`  
3. `X + Y = (X² - Y²) / (X - Y)`  
4. Solve for X and Y

---

### Code

#### C++
```cpp
vector<int> mathApproach(vector<int>& a) {
    long long n = a.size();
    long long Sn = n * (n + 1) / 2;
    long long S2n = n * (n + 1) * (2 * n + 1) / 6;
    
    long long S = 0, S2 = 0;
    for (int x : a) {
        S += x;
        S2 += (long long)x * x;
    }
    
    long long val1 = S - Sn;        // X - Y
    long long val2 = S2 - S2n;      // X² - Y²
    val2 = val2 / val1;             // X + Y
    
    long long X = (val1 + val2) / 2; // repeating
    long long Y = X - val1;          // missing
    
    return {(int)X, (int)Y};
}
```

#### JavaScript
```js
function mathApproach(a) {
    let n = a.length;
    let Sn = n * (n + 1) / 2;
    let S2n = n * (n + 1) * (2 * n + 1) / 6;
    
    let S = 0, S2 = 0;
    for (let x of a) {
        S += x;
        S2 += x * x;
    }
    
    let val1 = S - Sn;     // X - Y
    let val2 = (S2 - S2n) / val1; // X + Y
    
    let X = (val1 + val2) / 2;
    let Y = X - val1;
    
    return [X, Y];
}
```

* Time: O(N)  
* Space: O(1)

---

## Approach 4: Optimal 2 – XOR (God Level)

### Intuition  
XOR all array elements + XOR all numbers 1 to N → result = `repeating XOR missing`

Then find first set bit → divide numbers into two groups → XOR each group → get repeating & missing

### Why This Approach?  
- O(N) time  
- O(1) space  
- **No overflow risk**  
- Pure bit magic

### Why This is Final?  
- **Best in interviews**  
- Shows deep understanding  
- Works even if numbers were larger

---

### Code

#### C++
```cpp
vector<int> xorApproach(vector<int>& a) {
    int n = a.size();
    int xr = 0;
    
    // Step 1: XOR all array + 1 to N
    for (int i = 0; i < n; i++) {
        xr ^= a[i];
        xr ^= (i + 1);
    }
    
    // Step 2: Find first set bit
    int bit = xr & ~(xr - 1);
    
    int zero = 0, one = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] & bit) one ^= a[i];
        else zero ^= a[i];
        
        if ((i + 1) & bit) one ^= (i + 1);
        else zero ^= (i + 1);
    }
    
    // Step 3: Check which one is repeating
    int cnt = 0;
    for (int x : a) if (x == zero) cnt++;
    
    if (cnt == 2) return {zero, one};
    return {one, zero};
}
```

#### JavaScript
```js
function xorApproach(a) {
    let n = a.length;
    let xr = 0;
    
    for (let i = 0; i < n; i++) {
        xr ^= a[i];
        xr ^= (i + 1);
    }
    
    let bit = xr & ~(xr - 1);
    let zero = 0, one = 0;
    
    for (let i = 0; i < n; i++) {
        if (a[i] & bit) one ^= a[i];
        else zero ^= a[i];
        
        if ((i + 1) & bit) one ^= (i + 1);
        else zero ^= (i + 1);
    }
    
    let cnt = a.filter(x => x === zero).length;
    return cnt === 2 ? [zero, one] : [one, zero];
}
```

* Time: O(N)  
* Space: O(1)

---

## Approach 5: Bonus – Modify Array (Not Allowed Here)

Would use `a[a[i]-1] = -a[a[i]-1]` → but problem says **read-only array** → **not allowed**

---

## 5. Edge Case List

| Case | Handled? |
|------|---------|
| N = 2 | Yes |
| Repeating at start/end | Yes |
| Missing is N | Yes |
| Large numbers (10⁵) | Yes (use long long in math) |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute | O(N²) | O(1) | Learning |
| Hashing | O(N) | O(N) | Simple |
| **Math** | **O(N)** | **O(1)** | Clean, safe |
| **XOR** | **O(N)** | **O(1)** | **Interviews (God Level)** |

**Use XOR or Math in interviews**

---

## 7. Final Consolidated Code

### C++
```cpp
class Solution {
public:
    // Brute Force
    vector<int> brute(vector<int>& a) { /* code above */ }

    // Better: Hashing
    vector<int> better(vector<int>& a) { /* code above */ }

    // Optimal 1: Math
    vector<int> mathApproach(vector<int>& a) { /* code above */ }

    // Optimal 2: XOR (Best)
    vector<int> xorApproach(vector<int>& a) { /* code above */ }
};
```

### JavaScript
```js
class Solution {
    brute(a) { /* ... */ }
    better(a) { /* ... */ }
    mathApproach(a) { /* ... */ }
    xorApproach(a) { /* ... */ }  // Recommended
}
```

---