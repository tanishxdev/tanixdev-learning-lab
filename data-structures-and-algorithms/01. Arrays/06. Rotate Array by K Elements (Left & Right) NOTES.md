# Problem: Rotate Array by K Elements (Left & Right)

**GFG Link**: https://www.geeksforgeeks.org/problems/rotate-array-by-n-elements/1  
**LeetCode Link**: https://leetcode.com/problems/rotate-array/

---

## 1. Problem Statement

**English**:  
Given an array of `n` integers and a number `k`, **rotate the array**:
- **Right by k** → each element moves `k` positions to the right  
- **Left by k** → each element moves `k` positions to the left  

**Do it in-place** with **O(1) extra space**.

**LeetCode Version**: Rotate **right** by `k` steps.

**Hinglish**:  
Array ko `k` steps **left** ya **right** rotate karo — **bina extra space ke**.

---

## 2. Input / Output / Constraints

**Input Example (Right Rotate)**:  
`arr = [1,2,3,4,5,6,7]`, `k = 2`  
**Output Expected**: `[6,7,1,2,3,4,5]`

**Input Example (Left Rotate)**:  
`arr = [3,7,8,9,10,11]`, `k = 3`  
**Output Expected**: `[9,10,11,3,7,8]`

**Constraints**:  
- `1 ≤ n ≤ 10⁵`  
- `1 ≤ k ≤ 10⁹`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`

---

## 3. Examples (All Cases Covered)

| Example | Input | k | Direction | Output |
|--------|-------|----|-----------|--------|
| 1 | `[1,2,3,4,5,6,7]` | 2 | Right | `[6,7,1,2,3,4,5]` |
| 2 | `[3,7,8,9,10,11]` | 3 | Left | `[9,10,11,3,7,8]` |
| 3 | `[1,2]` | 5 | Right | `[2,1]` (5 % 2 = 1) |
| 4 | `[5]` | 10 | Any | `[5]` |
| 5 | `[]` | 3 | Any | `[]` |
| 6 | `[1,1,1]` | 2 | Right | `[1,1,1]` |

---

## 4. Intuition & Core Thinking

> **Key Insight**:  
> **Rotate Right by k** = Reverse last `k` → Reverse first `n-k` → Reverse all  
> **Rotate Left by k** = Reverse first `k` → Reverse last `n-k` → Reverse all

**Why?**  
Reversing blocks swaps positions in a way that mimics rotation.

**Bonus**:  
- `k = k % n` → rotating `n` times = no change  
- Works for **any k**, even `k > n`

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute – Using Temp Array

### Intuition  
- **Right Rotate**: Save last `k` elements → shift rest → copy saved  
- **Left Rotate**: Save first `k` → shift rest → copy saved

### Why This Approach?  
- Easy to code  
- Teaches indexing

### Why Move to Next?  
- **O(k) extra space** → not O(1)  
- **Not optimal**

---

### Code (Right Rotate)

#### C++
```cpp
void rotateRightBrute(vector<int>& arr, int k) {
    int n = arr.size();
    if (n == 0) return;
    k %= n;
    if (k == 0) return;

    vector<int> temp(k);
    // Save last k
    for (int i = 0; i < k; i++) {
        temp[i] = arr[n - k + i];
    }
    // Shift n-k elements right
    for (int i = n - 1; i >= k; i--) {
        arr[i] = arr[i - k];
    }
    // Copy temp to front
    for (int i = 0; i < k; i++) {
        arr[i] = temp[i];
    }
}
```

* Time: **O(n)**, Space: **O(k)** → **Not in-place**

---

## Approach 2: Optimal – Reversal Algorithm (O(1) Space)

### Intuition  
**Right Rotate by k**:
1. Reverse last `k` → `[1,2,3,4,5,6,7]` → `[1,2,3,4,7,6,5]`
2. Reverse first `n-k` → `[5,4,3,2,1,6,7]`
3. Reverse all → `[6,7,1,2,3,4,5]`

**Left Rotate by k**:
1. Reverse first `k` → `[3,2,1,4,5,6,7]`
2. Reverse last `n-k` → `[3,2,1,7,6,5,4]`
3. Reverse all → `[4,5,6,7,1,2,3]`

### Why This Approach?  
- **O(1) space**  
- **O(n) time**  
- **In-place**  
- **Interview favorite**

### Why This is Final?  
- **Optimal**  
- Generalizes to any `k`  
- Clean & elegant

---

### Algorithm (Right Rotate)
``` 
k = k % n
if k == 0: return
reverse(arr, n-k, n-1)   // last k
reverse(arr, 0, n-k-1)   // first n-k
reverse(arr, 0, n-1)     // all
```

---

### Dry Run: Right Rotate [1,2,3,4,5,6,7], k=2

| Step | Action | Array |
|------|------|-------|
| 0 | k=2 | [1,2,3,4,5,6,7] |
| 1 | Reverse last 2 | [1,2,3,4,5,7,6] |
| 2 | Reverse first 5 | [5,4,3,2,1,7,6] |
| 3 | Reverse all | [6,7,1,2,3,4,5] |

---

### Code

#### C++ (Both Left & Right + LeetCode)

```cpp
class Solution {
public:
    void reverse(vector<int>& arr, int start, int end) {
        while (start < end) {
            swap(arr[start++], arr[end--]);
        }
    }

    // Right Rotate by k (LeetCode)
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        if (n == 0) return;
        k %= n;
        if (k == 0) return;

        reverse(nums, n - k, n - 1);  // last k
        reverse(nums, 0, n - k - 1);  // first n-k
        reverse(nums, 0, n - 1);      // all
    }

    // Left Rotate by k
    void rotateLeft(vector<int>& arr, int k) {
        int n = arr.size();
        if (n == 0) return;
        k %= n;
        if (k == 0) return;

        reverse(arr, 0, k - 1);       // first k
        reverse(arr, k, n - 1);       // last n-k
        reverse(arr, 0, n - 1);       // all
    }
};
```

#### JavaScript
```js
function reverse(arr, start, end) {
    while (start < end) {
        [arr[start], arr[end]] = [arr[end], arr[start]];
        start++;
        end--;
    }
}

function rotateRight(arr, k) {
    let n = arr.length;
    if (n === 0) return;
    k %= n;
    if (k === 0) return;

    reverse(arr, n - k, n - 1);
    reverse(arr, 0, n - k - 1);
    reverse(arr, 0, n - 1);
}

function rotateLeft(arr, k) {
    let n = arr.length;
    if (n === 0) return;
    k %= n;
    if (k === 0) return;

    reverse(arr, 0, k - 1);
    reverse(arr, k, n - 1);
    reverse(arr, 0, n - 1);
}
```

* Time: **O(n)**, Space: **O(1)**

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | k | Direction | Expected | Handled? |
|---------|-------|----|-----------|----------|---------|
| k > n | `[1,2]` | 5 | Right | `[2,1]` | Yes (`k %= n`) |
| k = 0 | Any | 0 | Any | Same | Yes |
| n = 1 | `[5]` | 3 | Any | `[5]` | Yes |
| Empty | `[]` | 2 | Any | `[]` | Yes |
| k = n | Any | n | Any | Same | Yes |
| Duplicates | `[1,1]` | 1 | Right | `[1,1]` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Temp Array | O(n) | O(k) | Learning |
| **Reversal** | **O(n)** | **O(1)** | **Interviews (Optimal)** |

---

## 7. Final Consolidated Code

### C++ (LeetCode + Both Directions)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    void reverse(vector<int>& arr, int start, int end) {
        while (start < end) {
            swap(arr[start++], arr[end--]);
        }
    }

    // LeetCode: Right Rotate
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        if (n == 0) return;
        k %= n;
        if (k == 0) return;
        reverse(nums, n - k, n - 1);
        reverse(nums, 0, n - k - 1);
        reverse(nums, 0, n - 1);
    }

    // Left Rotate
    void rotateLeft(vector<int>& arr, int k) {
        int n = arr.size();
        if (n == 0) return;
        k %= n;
        if (k == 0) return;
        reverse(arr, 0, k - 1);
        reverse(arr, k, n - 1);
        reverse(arr, 0, n - 1);
    }

    // Right Rotate (non-LeetCode)
    void rotateRight(vector<int>& arr, int k) {
        rotate(arr, k); // Reuse LeetCode
    }
};
```

### JavaScript
```javascript
class Solution {
    reverse(arr, start, end) {
        while (start < end) {
            [arr[start], arr[end]] = [arr[end], arr[start]];
            start++;
            end--;
        }
    }

    // Right Rotate (LeetCode style)
    rotate(nums, k) {
        let n = nums.length;
        if (n === 0) return;
        k %= n;
        if (k === 0) return;
        this.reverse(nums, n - k, n - 1);
        this.reverse(nums, 0, n - k - 1);
        this.reverse(nums, 0, n - 1);
    }

    rotateLeft(arr, k) {
        let n = arr.length;
        if (n === 0) return;
        k %= n;
        if (k === 0) return;
        this.reverse(arr, 0, k - 1);
        this.reverse(arr, k, n - 1);
        this.reverse(arr, 0, n - 1);
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I'll use **reversal algorithm** — **O(1) space**, **in-place**."  
2. "First, `k = k % n`. Then 3 reverses: last k → first n-k → all."  
3. "For **left rotate**, reverse first k → last n-k → all."  
4. "Edge cases: k > n, k=0, n≤1 → handled with `k %= n`."  
5. **Bonus**: "Temp array uses O(k) space — not optimal. This is **best**."

