# Problem: Majority Element (> N/2 times)

**GFG Link**: https://www.geeksforgeeks.org/problems/majority-element-1587115620/1  
**LeetCode (Same)**: https://leetcode.com/problems/majority-element/

---

## 1. Problem Statement

**English**:  
Given an array of `N` integers, return the element that appears **more than `N/2` times**.  
**It is guaranteed** that such an element **always exists**.

**Hinglish**:  
Array mein ek number `N/2` se zyada baar aata hai — usko return karo.  
**Guaranteed hai ki aisa number hoga.**

---

## 2. Input / Output / Constraints

**Input Example**:  
`nums = [3, 2, 3]`  
**Output Expected**: `3`

**Constraints**:  
- `1 ≤ N ≤ 5 * 10⁴`  
- `-10⁹ ≤ nums[i] ≤ 10⁹`  
- **Majority element always exists**

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[3,2,3]` | `3` | 3 appears 2 > 3/2 |
| 2 | `[2,2,1,1,1,2,2]` | `2` | 2 appears 4 > 7/2 |
| 3 | `[4,4,2,4,3,4,4,3,2,4]` | `4` | 4 appears 6 > 10/2 |
| 4 | `[1]` | `1` | n=1 → 1/2 = 0 |
| 5 | `[5,5,5,5]` | `5` | All same |
| 6 | `[1,2,2]` | `2` | 2 appears 2 > 3/2 |

---

## 4. Intuition & Core Thinking

> **"If a number appears more than half the time, it must 'win' in a voting system."**

Think of it as **election**:
- Each occurrence of a number = **+1 vote**
- Each different number = **-1 vote**
- The **majority element will always have positive votes at the end**

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Nested Loops

### Intuition  
For each element, count how many times it appears → if > `n/2`, return it.

### Why This Approach?  
- Most natural  
- Easy to code  
- Teaches frequency counting

### Why Move to Next?  
- **O(n²)** → TLE for large n  
- Redundant counting

---

### Algorithm  
``` 
for i from 0 to n-1:
    count = 0
    for j from 0 to n-1:
        if arr[j] == arr[i]: count++
    if count > n/2: return arr[i]
```

---

### Dry Run: [2,2,1,1,1,2,2]  
- i=0, num=2 → count=4 → **>3.5** → return 2

---

### Code

#### C++
```cpp
int brute(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        int cnt = 0;
        for (int j = 0; j < n; j++) {
            if (arr[j] == arr[i]) cnt++;
        }
        if (cnt > n / 2) return arr[i];
    }
    return -1;
}
```

#### JavaScript
```js
function brute(arr) {
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let cnt = 0;
        for (let j = 0; j < n; j++) {
            if (arr[j] === arr[i]) cnt++;
        }
        if (cnt > Math.floor(n / 2)) return arr[i];
    }
    return -1;
}
```

* Time: **O(n²)**, Space: **O(1)**

---

## Approach 2: Better – Hash Map (Frequency Count)

### Intuition  
Use a map to store frequency → check if any > `n/2`.

### Why This Approach?  
- **O(n) time**  
- Clean and readable  
- Works even without guarantee

### Why Move to Next?  
- **O(n) space**  
- **Not needed** when majority is guaranteed  
- Can be done **in-place**

---

### Code

#### C++
```cpp
int hashMap(vector<int>& arr) {
    unordered_map<int, int> freq;
    int n = arr.size();
    for (int num : arr) {
        freq[num]++;
        if (freq[num] > n / 2) return num;
    }
    return -1;
}
```

#### JavaScript
```js
function hashMap(arr) {
    let freq = new Map();
    let n = arr.length;
    for (let num of arr) {
        freq.set(num, (freq.get(num) || 0) + 1);
        if (freq.get(num) > Math.floor(n / 2)) return num;
    }
    return -1;
}
```

* Time: **O(n)**, Space: **O(n)**

---

## Approach 3: Optimal – **Moore’s Voting Algorithm**

### Intuition  
> **"Majority element will always survive cancellation"**

**Idea**:
- Keep a `candidate` and a `count`
- If same → `count++`
- If different → `count--`
- When `count == 0` → pick new candidate
- **Final candidate = majority** (since guaranteed)

### Why This Approach?  
- **O(n) time**  
- **O(1) space**  
- **Elegant & fast**  
- **Interview favorite**

### Why This is Final?  
- **Optimal** — cannot improve  
- Works **only because majority is guaranteed**  
- Used in real systems

---

### Algorithm  
``` 
count = 0, candidate = null
for num in arr:
    if count == 0:
        candidate = num
    if num == candidate:
        count++
    else:
        count--
return candidate
```

---

### Dry Run: [2,2,1,1,1,2,2]

| num | count | candidate | Action |
|-----|-------|-----------|--------|
| 2 | 0 → 1 | 2 | set candidate |
| 2 | 1 → 2 | 2 | same → +1 |
| 1 | 2 → 1 | 2 | diff → -1 |
| 1 | 1 → 0 | 2 | diff → -1 |
| 1 | 0 → 1 | 1 | count=0 → new candidate |
| 2 | 1 → 0 | 1 | diff → -1 |
| 2 | 0 → 1 | 2 | count=0 → new candidate |

→ Final candidate = `2` → **Correct!**

---

### Code

#### C++
```cpp
int mooreVoting(vector<int>& arr) {
    int count = 0, candidate = 0;
    for (int num : arr) {
        if (count == 0) {
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1;
    }
    return candidate;
}
```

#### JavaScript
```js
function mooreVoting(arr) {
    let count = 0, candidate = null;
    for (let num of arr) {
        if (count === 0) {
            candidate = num;
        }
        count += (num === candidate) ? 1 : -1;
    }
    return candidate;
}
```

* Time: **O(n)**, Space: **O(1)** → **Optimal**

---

## Approach 4: STL / Built-in (Not for Learning)

```cpp
// Only if you want to impress in production
sort(arr.begin(), arr.end());
return arr[arr.size() / 2];  // median = majority
```

> **Why it works?** In sorted array, majority element appears at `n/2` index.

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|---------|-------|----------|---------|
| n = 1 | `[5]` | `5` | Yes |
| All same | `[3,3,3]` | `3` | Yes |
| Majority at start | `[4,1,2,3]` | `4` | Yes |
| Majority at end | `[1,2,3,4,4]` | `4` | Yes |
| Minimum majority | `[1,2,2]` | `2` | Yes (2 > 3/2) |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute Force | O(n²) | O(1) | Learning |
| Hash Map | O(n) | O(n) | General case |
| **Moore’s Voting** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| Sorting | O(n log n) | O(1) | Production (if allowed) |

**Use Moore’s Voting Algorithm**

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute Force
    int brute(vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 0; j < n; j++) {
                if (arr[j] == arr[i]) cnt++;
            }
            if (cnt > n / 2) return arr[i];
        }
        return -1;
    }

    // 2. Hash Map
    int hashMap(vector<int>& arr) {
        unordered_map<int, int> freq;
        int n = arr.size();
        for (int num : arr) {
            if (++freq[num] > n / 2) return num;
        }
        return -1;
    }

    // 3. Optimal: Moore's Voting
    int mooreVoting(vector<int>& arr) {
        int count = 0, candidate = 0;
        for (int num : arr) {
            if (count == 0) candidate = num;
            count += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }

    // 4. Sorting (Bonus)
    int sorting(vector<int>& arr) {
        sort(arr.begin(), arr.end());
        return arr[arr.size() / 2];
    }
};
```

### JavaScript
```javascript
class Solution {
    // 1. Brute
    brute(arr) {
        let n = arr.length;
        for (let i = 0; i < n; i++) {
            let cnt = 0;
            for (let j = 0; j < n; j++) {
                if (arr[j] === arr[i]) cnt++;
            }
            if (cnt > Math.floor(n / 2)) return arr[i];
        }
        return -1;
    }

    // 2. Hash Map
    hashMap(arr) {
        let freq = new Map();
        let n = arr.length;
        for (let num of arr) {
            freq.set(num, (freq.get(num) || 0) + 1);
            if (freq.get(num) > Math.floor(n / 2)) return num;
        }
        return -1;
    }

    // 3. Optimal: Moore's Voting
    mooreVoting(arr) {
        let count = 0, candidate = null;
        for (let num of arr) {
            if (count === 0) candidate = num;
            count += (num === candidate) ? 1 : -1;
        }
        return candidate;
    }

    // 4. Sorting
    sorting(arr) {
        arr.sort((a, b) => a - b);
        return arr[Math.floor(arr.length / 2)];
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since majority is **guaranteed**, I’ll use **Moore’s Voting Algorithm** in **O(1) space**."
2. "Idea: majority element survives cancellation."
3. "Keep `candidate` and `count` → final candidate is answer."
4. "Time: **O(n)**, Space: **O(1)** — optimal."
5. **Bonus**:  
   - "If majority **not guaranteed**, I’d add a second pass to verify."  
   - "Sorting also works: majority is at index `n/2` after sort."

---