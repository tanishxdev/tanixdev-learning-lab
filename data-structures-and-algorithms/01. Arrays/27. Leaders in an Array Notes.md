# Problem: Leaders in an Array

**GFG Link**: https://www.geeksforgeeks.org/problems/leaders-in-an-array/1  
**LeetCode (Similar)**: https://leetcode.com/problems/find-all-leaders-in-array/ (Custom)

---

## 1. Problem Statement

**English**:  
Given an array of integers, find all **leaders**.  
A **leader** is an element such that **all elements to its right are smaller than it**.  
Return the leaders in **original order** (from left to right).

**Hinglish**:  
Array mein saare *leaders* dhundho — jo element apne **right side ke saare elements se bada ho**.  
Left to right order mein return karo.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [10, 22, 12, 3, 0, 6]`  
**Output Expected**: `[22, 12, 6]`

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`  
- Array can have **duplicates**, **negatives**, **single element**

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[10, 22, 12, 3, 0, 6]` | `[22, 12, 6]` | 22 > all right, 12 > [3,0,6], 6 > [] |
| 2 | `[7, 10, 4, 3, 6, 5, 2]` | `[10, 6, 5, 2]` | Step-by-step check |
| 3 | `[5]` | `[5]` | Only element → leader |
| 4 | `[1, 2, 3, 4, 5]` | `[5]` | Only last is leader |
| 5 | `[5, 4, 3, 2, 1]` | `[5, 4, 3, 2, 1]` | All are leaders |
| 6 | `[]` | `[]` | Empty array |

---

## 4. Intuition & Core Thinking

> **Key Insight**:  
> An element is a **leader** if it is **greater than every element to its right**.

So:
- The **last element is always a leader** (no right elements).
- As we move **left**, we only care about **maximum so far from right**.

**Idea**:  
> Traverse from **right to left**  
> Keep track of **current maximum**  
> If current element > current max → it’s a **leader** → update max

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Nested Loops

### Intuition  
For each element `arr[i]`, check **all elements to its right** → if any is greater → not leader.

### Why This Approach?  
- Natural thinking  
- Teaches double loop logic  
- Easy to debug

### Why Move to Next?  
- **O(n²)** → TLE for large n  
- Redundant comparisons  
- **Not scalable**

---

### Algorithm  
1. Initialize empty `ans` vector  
2. For `i` from `0` to `n-1`:  
  `isLeader = true`  
  For `j` from `i+1` to `n-1`:  
   if `arr[j] > arr[i]` → `isLeader = false`, break  
  If `isLeader` → `ans.push_back(arr[i])`  
3. Return `ans`

---

### Pseudocode  
``` 
function bruteLeaders(arr):  
    ans = []  
    for i from 0 to n-1:  
        isLeader = true  
        for j from i+1 to n-1:  
            if arr[j] > arr[i]:  
                isLeader = false  
                break  
        if isLeader:  
            ans.append(arr[i])  
    return ans
```

---

### Dry Run: [10, 22, 12, 3, 0, 6]  
| i | arr[i] | Check right | Leader? |
|---|--------|-------------|--------|
| 0 | 10 | 22,12,... → 22 > 10 | No |
| 1 | 22 | 12,3,0,6 → 12 < 22 | Yes |
| 2 | 12 | 3,0,6 → 6 < 12 | Yes |
| 3 | 3  | 0,6 → 6 > 3 | No |
| 4 | 0  | 6 → 6 > 0 | No |
| 5 | 6  | (none) | Yes |

→ Answer: `[22, 12, 6]`

---

### Code

#### C++
```cpp
vector<int> bruteLeaders(vector<int>& arr) {
    int n = arr.size();
    vector<int> ans;
    for (int i = 0; i < n; i++) {
        bool isLeader = true;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] > arr[i]) {
                isLeader = false;
                break;
            }
        }
        if (isLeader) ans.push_back(arr[i]);
    }
    return ans;
}
```

#### JavaScript
```js
function bruteLeaders(arr) {
    let n = arr.length;
    let ans = [];
    for (let i = 0; i < n; i++) {
        let isLeader = true;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] > arr[i]) {
                isLeader = false;
                break;
            }
        }
        if (isLeader) ans.push(arr[i]);
    }
    return ans;
}
```

* Time Complexity: **O(n²)**  
* Space Complexity: **O(n)** (for output)

---

## Approach 2: Optimal – Traverse from Right (Single Pass)

### Intuition  
> **Last element is always leader** → start from end  
> Keep track of **maximum seen so far from right**  
> If current > max → it’s a leader → update max

### Why This Approach?  
- **O(n) time**  
- **O(1) extra space** (except output)  
- **Elegant & efficient**  
- **Interview favorite**

### Why This is Final?  
- **Optimal** — cannot do better than O(n)  
- No redundant checks  
- Handles all edge cases

---

### Algorithm  
1. If `n == 0` → return `[]`  
2. Initialize:  
  `ans = [arr[n-1]]`  
  `maxSoFar = arr[n-1]`  
3. For `i = n-2` down to `0`:  
  if `arr[i] > maxSoFar`:  
   `ans.push_back(arr[i])`  
   `maxSoFar = arr[i]`  
4. **Reverse `ans`** → to get left-to-right order  
5. Return `ans`

---

### Pseudocode  
``` 
function optimalLeaders(arr):  
    n = arr.length  
    if n == 0: return []  
    ans = [arr[n-1]]  
    maxSoFar = arr[n-1]  
    for i from n-2 down to 0:  
        if arr[i] > maxSoFar:  
            ans.append(arr[i])  
            maxSoFar = arr[i]  
    reverse(ans)  
    return ans
```

---

### Dry Run: [10, 22, 12, 3, 0, 6]  
| i | arr[i] | maxSoFar | Action |
|---|--------|----------|--------|
| 5 | 6      | 6        | ans = [6], max = 6 |
| 4 | 0      | 6        | skip |
| 3 | 3      | 6        | skip |
| 2 | 12     | 6        | 12 > 6 → add, max = 12 |
| 1 | 22     | 12       | 22 > 12 → add, max = 22 |
| 0 | 10     | 22       | skip |

→ `ans = [6, 12, 22]` → reverse → `[22, 12, 6]`

---

### Code

#### C++
```cpp
vector<int> optimalLeaders(vector<int>& arr) {
    int n = arr.size();
    if (n == 0) return {};
    vector<int> ans;
    int maxSoFar = arr[n-1];
    ans.push_back(maxSoFar);
    
    for (int i = n-2; i >= 0; i--) {
        if (arr[i] > maxSoFar) {
            ans.push_back(arr[i]);
            maxSoFar = arr[i];
        }
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
```

#### JavaScript
```js
function optimalLeaders(arr) {
    let n = arr.length;
    if (n === 0) return [];
    let ans = [];
    let maxSoFar = arr[n-1];
    ans.push(maxSoFar);
    
    for (let i = n-2; i >= 0; i--) {
        if (arr[i] > maxSoFar) {
            ans.push(arr[i]);
            maxSoFar = arr[i];
        }
    }
    return ans.reverse();
}
```

* Time Complexity: **O(n)**  
* Space Complexity: **O(1)** (excluding output)

---

## Approach 3: STL / Built-in (Not Directly Available)

No direct STL for leaders.  
Custom logic is **cleanest**.

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|--------|-------|----------|---------|
| Empty array | `[]` | `[]` | Yes |
| Single element | `[10]` | `[10]` | Yes |
| Strictly decreasing | `[5,4,3,2,1]` | `[5,4,3,2,1]` | Yes |
| Strictly increasing | `[1,2,3,4,5]` | `[5]` | Yes |
| Duplicates | `[4,4,4]` | `[4]` | Yes |
| Negative numbers | `[-1, -5, -2]` | `[-1]` | Yes |
| Last element leader | `[1,2,3]` | `[3]` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Brute Force | O(n²) | O(n) | Learning |
| **Right-to-Left Scan** | **O(n)** | **O(1)** | **Interviews (Optimal)** |

> **Always use Right-to-Left scan**

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 1. Brute Force
    vector<int> brute(vector<int>& arr) {
        int n = arr.size();
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            bool leader = true;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] > arr[i]) {
                    leader = false;
                    break;
                }
            }
            if (leader) ans.push_back(arr[i]);
        }
        return ans;
    }

    // 2. Optimal: Right to Left
    vector<int> optimal(vector<int>& arr) {
        int n = arr.size();
        if (n == 0) return {};
        vector<int> ans;
        int maxSoFar = arr[n-1];
        ans.push_back(maxSoFar);
        for (int i = n-2; i >= 0; i--) {
            if (arr[i] > maxSoFar) {
                ans.push_back(arr[i]);
                maxSoFar = arr[i];
            }
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

### JavaScript
```javascript
class Solution {
    // 1. Brute
    brute(arr) {
        let n = arr.length;
        let ans = [];
        for (let i = 0; i < n; i++) {
            let isLeader = true;
            for (let j = i + 1; j < n; j++) {
                if (arr[j] > arr[i]) {
                    isLeader = false;
                    break;
                }
            }
            if (isLeader) ans.push(arr[i]);
        }
        return ans;
    }

    // 2. Optimal
    optimal(arr) {
        let n = arr.length;
        if (n === 0) return [];
        let ans = [];
        let maxSoFar = arr[n-1];
        ans.push(maxSoFar);
        for (let i = n-2; i >= 0; i--) {
            if (arr[i] > maxSoFar) {
                ans.push(arr[i]);
                maxSoFar = arr[i];
            }
        }
        return ans.reverse();
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I’ll solve this in **O(n)** time by scanning from **right to left**."  
2. "Last element is always a leader. I’ll keep track of **max so far**."  
3. "If current element > max → it’s a leader → update max."  
4. "Finally reverse the result to get left-to-right order."  
5. "Time: **O(n)**, Space: **O(1)** — optimal."  
6. **Bonus**: "Brute force is O(n²) — not needed. This works for all cases: duplicates, negatives, single element."

---

**Done!**  
Your template applied **smoothly, detailed, and interview-ready**.

---