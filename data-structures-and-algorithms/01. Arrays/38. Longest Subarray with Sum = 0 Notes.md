# Longest Subarray with Sum = 0  
(Zero Sum Subarray – Maximum Length)

**LeetCode Similar**: 525 – Contiguous Array (1s & 0s) → same logic  
**GFG**: https://practice.geeksforgeeks.org/problems/largest-subarray-with-0-sum

---

### Problem Statement
Given an array of integers (positive + negative), find the **length of the longest subarray** whose sum is **0**.  
If no such subarray exists → return **0**.

**Examples**  
```
[9, -3, 3, -1, 6, -5] → 5   ({-3,3,-1,6,-5})
[6,-2,2,-8,1,7,4,-10] → 8   (entire array)
[1, 0, -5]            → 1   ({0})
[1, 3, -5, 6, -2]     → 0   (no zero-sum subarray)
```

---

### Core Intuition (Most Important)

> If at two indices `i` and `j` (i < j), the **prefix sum is the same**, then  
> **Subarray from (i+1) to j has sum = 0**  
> Length = `j - i`

```
prefix[i] = sum of elements from 0 to i
If prefix[i] == prefix[j] → sum(i+1 to j) = 0
```

Also, if **prefix[i] == 0** → subarray from index 0 to i has sum 0 → length = i+1

---

### All Approaches – Fully Commented + Pseudocode + Dry Run

---

#### Approach 1: Brute Force – Check All Subarrays  
**Time**: O(N²) | **Space**: O(1)

```cpp
int brute(vector<int>& arr) {
    int n = arr.size();
    int maxLen = 0;

    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = i; j < n; j++) {
            sum += arr[j];
            if (sum == 0) {
                maxLen = max(maxLen, j - i + 1);
            }
        }
    }
    return maxLen;
}
```

Works, but **TLE** for large N.

---

#### Approach 2: Optimal – Prefix Sum + HashMap (Best)

**Time**: O(N) | **Space**: O(N)

```cpp
// Optimal - Prefix Sum + HashMap
int longestZeroSumSubarray(vector<int>& arr) {
    int n = arr.size();
    unordered_map<int, int> prefixMap;  // prefixSum → first index
    int sum = 0;
    int maxLen = 0;

    for (int i = 0; i < n; i++) {
        sum += arr[i];

        // Case 1: sum == 0 → subarray from 0 to i
        if (sum == 0) {
            maxLen = i + 1;
        }
        // Case 2: sum seen before → subarray (prevIndex+1 to i)
        else if (prefixMap.count(sum)) {
            maxLen = max(maxLen, i - prefixMap[sum]);
        }
        // Case 3: first time seeing this sum → store index
        else {
            prefixMap[sum] = i;
        }
    }
    return maxLen;
}
```

**Key Point**: We **do NOT update** the index if sum is seen again → we want the **longest** subarray.

---

### Dry Run – Example: [1, 2, -2, 4, -4]

| i | arr[i] | sum | Action | maxLen | Map |
|---|--------|-----|-------|--------|-----|
| 0 | 1      | 1   | Insert (1→0) | 0 | {1:0} |
| 1 | 2      | 3   | Insert (3→1) | 0 | {1:0,3:1} |
| 2 | -2     | 1   | Found 1 → len = 2-0 = 2 | 2 | unchanged |
| 3 | 4      | 5   | Insert (5→3) | 2 | {1:0,3:1,5:3} |
| 4 | -4     | 1   | Found 1 → len = 4-0 = 4 | 4 | unchanged |

Answer: **4** → subarray `[2,-2,4,-4]`

---

### Pseudocode (Optimal)

```
function longestZeroSum(arr):
    map = {}
    sum = 0
    maxLen = 0
    
    for i from 0 to n-1:
        sum += arr[i]
        
        if sum == 0:
            maxLen = i + 1
            
        else if map contains sum:
            maxLen = max(maxLen, i - map[sum])
            
        else:
            map[sum] = i
            
    return maxLen
```

---

### Edge Cases Handled

| Case                     | Handled? | How? |
|--------------------------|--------|------|
| All positive             | Yes    | Only sum==0 case |
| All negative             | Yes    | Same |
| Contains 0               | Yes    | sum==0 at that index |
| No zero-sum subarray     | Yes    | maxLen remains 0 |
| Entire array sum = 0     | Yes    | sum==0 at last index |
| Multiple same prefix     | Yes    | We keep earliest index |

---

### Final Consolidated Code (C++ & JavaScript)

#### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute Force - O(N²)
    int brute(vector<int>& arr) {
        int n = arr.size(), maxLen = 0;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += arr[j];
                if (sum == 0) maxLen = max(maxLen, j - i + 1);
            }
        }
        return maxLen;
    }

    // Optimal - Prefix + HashMap
    int optimal(vector<int>& arr) {
        unordered_map<int, int> mp;
        int sum = 0, maxLen = 0, n = arr.size();

        for (int i = 0; i < n; i++) {
            sum += arr[i];

            if (sum == 0) {
                maxLen = i + 1;
            }
            else if (mp.count(sum)) {
                maxLen = max(maxLen, i - mp[sum]);
            }
            else {
                mp[sum] = i;  // store only first occurrence
            }
        }
        return maxLen;
    }
};
```

#### JavaScript
```javascript
function longestZeroSumSubarray(arr) {
    let map = new Map();
    let sum = 0;
    let maxLen = 0;

    for (let i = 0; i < arr.length; i++) {
        sum += arr[i];

        if (sum === 0) {
            maxLen = i + 1;
        }
        else if (map.has(sum)) {
            maxLen = Math.max(maxLen, i - map.get(sum));
        }
        else {
            map.set(sum, i);
        }
    }
    return maxLen;
}

// Test
console.log(longestZeroSumSubarray([9,-3,3,-1,6,-5])); // 5
console.log(longestZeroSumSubarray([6,-2,2,-8,1,7,4,-10])); // 8
```

---

### Complexity Summary

| Approach       | Time     | Space   | Best For         |
|----------------|----------|---------|------------------|
| Brute Force    | O(N²)    | O(1)    | Learning         |
| **Optimal**    | **O(N)** | **O(N)**| **Interviews** |

**Use Optimal in interviews – it’s a classic!**
