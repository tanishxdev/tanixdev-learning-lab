# Problem: Longest Subarray with Sum K (Only Positive Elements)

**GFG Link**: https://www.geeksforgeeks.org/problems/longest-sub-array-with-sum-k/1  
**LeetCode (Similar)**: https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/

---

## 1. Problem Statement

**English**:  
Given an array of **positive integers** and a target sum `K`, find the **length of the longest subarray** whose sum equals `K`.

**Hinglish**:  
Sirf **positive numbers** wale array mein, **sabse lamba subarray** dhundho jiska sum **K** ho.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [2, 3, 5, 1, 9]`, `K = 10`  
**Output Expected**: `3` → `[2,3,5]`

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `1 ≤ arr[i] ≤ 10⁹`  
- `1 ≤ K ≤ 10¹⁴`  
- **All elements are positive**

---

## 3. Examples (All Cases Covered)

| Example | Array | K | Output | Subarray |
|--------|-------|----|--------|----------|
| 1 | `[2,3,5]` | 5 | `2` | `[2,3]` |
| 2 | `[2,3,5,1,9]` | 10 | `3` | `[2,3,5]` |
| 3 | `[1,2,3,4]` | 15 | `0` | Not possible |
| 4 | `[7]` | 7 | `1` | `[7]` |
| 5 | `[1,1,1,1]` | 3 | `3` | `[1,1,1]` |
| 6 | `[]` | 5 | `0` | Empty |

---

## 4. Intuition & Core Thinking

> **Since all elements are positive → sum increases as subarray grows**

Key Insight:  
- Use **two pointers (Sliding Window)**  
- Expand `right` → add elements  
- Shrink `left` when sum > K → remove elements  
- When `sum == K` → update `maxLen`

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Three Nested Loops

### Intuition  
Generate all subarrays → check sum → track max length.

### Why This?  
- Easy to think  
- Covers all cases

### Why Move to Next?  
- **O(N³)** → too slow  
- Not acceptable

---

### Code
```cpp
int brute(vector<int>& arr, long long k) {
    int n = arr.size();
    int maxLen = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            long long sum = 0;
            for (int l = i; l <= j; l++) {
                sum += arr[l];
            }
            if (sum == k) maxLen = max(maxLen, j - i + 1);
        }
    }
    return maxLen;
}
```

* Time: **O(N³)**, Space: **O(1)** → **Poor**

---

## Approach 2: Better – Two Loops (Cumulative Sum)

### Intuition  
For each `i`, start `j = i`, keep adding `arr[j]`, check if sum == K.

### Why This?  
- **O(N²)**  
- Uses cumulative sum idea

### Why Move to Next?  
- Still slow for large N  
- Can be optimized

---

### Code
```cpp
int better(vector<int>& arr, long long k) {
    int n = arr.size();
    int maxLen = 0;
    for (int i = 0; i < n; i++) {
        long long sum = 0;
        for (int j = i; j < n; j++) {
            sum += arr[j];
            if (sum == k) {
                maxLen = max(maxLen, j - i + 1);
            }
        }
    }
    return maxLen;
}
```

* Time: **O(N²)**, Space: **O(1)** → **Acceptable, but not best**

---

## Approach 3: Optimal – Two Pointers (Sliding Window)

### Intuition  
> **Since all elements > 0 → sum increases with size**

- Expand `right` → increase sum  
- Shrink `left` when `sum > K` → reduce sum  
- When `sum == K` → update `maxLen`

### Why This is Final?  
- **O(N)** time  
- **O(1)** space  
- **Interview favorite**

---

### Algorithm  
``` 
left = 0, right = 0
sum = 0
maxLen = 0

while right < n:
    sum += arr[right]
    
    while sum > k and left <= right:
        sum -= arr[left]
        left++
    
    if sum == k:
        maxLen = max(maxLen, right - left + 1)
    
    right++
```

---

### Dry Run: [2,3,5,1,9], K=10

| right | arr[right] | sum | left | Action | maxLen |
|-------|------------|-----|------|--------|--------|
| 0 | 2 | 2 | 0 | — | 0 |
| 1 | 3 | 5 | 0 | — | 0 |
| 2 | 5 | 10 | 0 | sum==10 → len=3 | **3** |
| 3 | 1 | 11 | 0 | sum>10 → shrink | 3 |
| 3 | 1 | 9 | 1 | — | 3 |
| 4 | 9 | 18 | 1 | sum>10 → shrink | 3 |
| 4 | 9 | 15 | 2 | — | 3 |
| 4 | 9 | 10 | 3 | sum==10 → len=2 | 3 |
| 4 | 9 | 9 | 4 | — | 3 |

**Final**: `3` → Correct!

---

### Code

#### C++ (Optimal)
```cpp
int getLongestSubarray(vector<int>& arr, long long k) {
    int n = arr.size();
    int left = 0, right = 0;
    long long sum = 0;
    int maxLen = 0;

    while (right < n) {
        sum += arr[right];

        // Shrink from left if sum > k
        while (sum > k && left <= right) {
            sum -= arr[left];
            left++;
        }

        // Check if sum == k
        if (sum == k) {
            maxLen = max(maxLen, right - left + 1);
        }

        right++;
    }

    return maxLen;
}
```

#### JavaScript
```js
function longestSubarrayWithSumK(arr, k) {
    let n = arr.length;
    let left = 0, right = 0;
    let sum = 0;
    let maxLen = 0;

    while (right < n) {
        sum += arr[right];

        while (sum > k && left <= right) {
            sum -= arr[left];
            left++;
        }

        if (sum === k) {
            maxLen = Math.max(maxLen, right - left + 1);
        }

        right++;
    }

    return maxLen;
}
```

* Time: **O(N)**, Space: **O(1)** → **BEST**

---

## 5. Edge Case List (Line-wise)

| Edge Case | Array | K | Expected | Handled? |
|---------|-------|----|----------|---------|
| Single element | `[5]` | 5 | `1` | Yes |
| No subarray | `[1,2,3]` | 10 | `0` | Yes |
| Whole array | `[1,2,3,4]` | 10 | `4` | Yes |
| Multiple same | `[1,1,1,1]` | 3 | `3` | Yes |
| Large K | `[1,1,...,1]` | 10⁵ | Correct | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| 3 Loops | O(N³) | O(1) | Learning |
| 2 Loops | O(N²) | O(1) | Good |
| **Two Pointers** | **O(N)** | **O(1)** | **Interviews (BEST)** |

---

## 7. Final Consolidated Code

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute: 3 loops
    int brute(vector<int>& arr, long long k) {
        int n = arr.size(), maxLen = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                long long sum = 0;
                for (int l = i; l <= j; l++) sum += arr[l];
                if (sum == k) maxLen = max(maxLen, j - i + 1);
            }
        }
        return maxLen;
    }

    // Better: 2 loops
    int better(vector<int>& arr, long long k) {
        int n = arr.size(), maxLen = 0;
        for (int i = 0; i < n; i++) {
            long long sum = 0;
            for (int j = i; j < n; j++) {
                sum += arr[j];
                if (sum == k) maxLen = max(maxLen, j - i + 1);
            }
        }
        return maxLen;
    }

    // Optimal: Two Pointers
    int longestSubarrayWithSumK(vector<int>& arr, long long k) {
        int n = arr.size();
        int left = 0, right = 0;
        long long sum = 0;
        int maxLen = 0;

        while (right < n) {
            sum += arr[right];

            while (sum > k && left <= right) {
                sum -= arr[left++];
            }

            if (sum == k) {
                maxLen = max(maxLen, right - left + 1);
            }

            right++;
        }

        return maxLen;
    }
};
```

### JavaScript
```javascript
class Solution {
    // Optimal
    longestSubarrayWithSumK(arr, k) {
        let n = arr.length;
        let left = 0, right = 0;
        let sum = 0;
        let maxLen = 0;

        while (right < n) {
            sum += arr[right];

            while (sum > k && left <= right) {
                sum -= arr[left++];
            }

            if (sum === k) {
                maxLen = Math.max(maxLen, right - left + 1);
            }

            right++;
        }

        return maxLen;
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "Since all elements are **positive**, I’ll use **Two Pointers** — **O(N) time**, **O(1) space**."  
2. "Expand `right`, add `arr[right]`. If `sum > K`, shrink from `left`."  
3. "When `sum == K`, update `maxLen`."  
4. "Edge cases: single element, no subarray, whole array → handled."  
5. **Bonus**: "Brute is O(N³), Better is O(N²). This is **optimal**."

---