# Problem: Move All Zeros to the End of the Array

**GFG Link**: https://www.geeksforgeeks.org/problems/move-all-zeros-to-the-end/1  
**LeetCode Link**: https://leetcode.com/problems/move-zeroes/

---

## 1. Problem Statement

**English**:  
Given an array of integers, move **all `0`s to the end** while **preserving the relative order** of non-zero elements.  
Do it **in-place** (without extra array).

**Hinglish**:  
Array mein saare `0` ko **last mein bhejo**, baaki numbers ka **order same rakho**, **bina extra space ke**.

---

## 2. Input / Output / Constraints

**Input Example**:  
`arr = [1, 0, 2, 3, 0, 4, 0, 1]`  
**Output Expected**: `[1, 2, 3, 4, 1, 0, 0, 0]`

**Constraints**:  
- `1 ≤ arr.length ≤ 10⁵`  
- `-10⁹ ≤ arr[i] ≤ 10⁹`

---

## 3. Examples (All Cases Covered)

| Example | Input | Output | Why |
|-------|-------|--------|-----|
| 1 | `[1,0,2,3,0,4,0,1]` | `[1,2,3,4,1,0,0,0]` | Normal |
| 2 | `[0,1,0,3,12]` | `[1,3,12,0,0]` | LeetCode |
| 3 | `[1,2,3,4]` | `[1,2,3,4]` | No zeros |
| 4 | `[0,0,0]` | `[0,0,0]` | All zeros |
| 5 | `[5]` | `[5]` | Single element |
| 6 | `[]` | `[]` | Empty |

---

## 4. Intuition & Core Thinking

> **"I want non-zeros in front, in same order."**

Think of it like:  
> "I'm collecting all non-zeros in a basket. Then I put them back at the start, and fill the rest with zeros."

Key Insight:  
- **Two Pointers**:  
  - `i` → where to **place next non-zero**  
  - `j` → current element we’re checking  
- When `arr[j] != 0` → place it at `arr[i++]`  
- Finally, fill `i` to `n-1` with `0`

---

# APPROACHES (Brute → Optimal)

---

## Approach 1: Brute Force – Using Extra Array

### Intuition  
Copy all non-zeros to a temp array → copy back → fill rest with 0.

### Why This Approach?  
- Easy to think  
- No risk of order loss  
- Good for learning

### Why Move to Next?  
- **O(n) extra space** → not allowed  
- **Not in-place**

---

### Algorithm  
1. Create `temp`  
2. Copy non-zeros to `temp`  
3. Copy `temp` back to `arr[0..count-1]`  
4. Fill `arr[count..n-1]` with `0`

---

### Pseudocode  
``` 
function brute(arr):  
    temp = []  
    for x in arr:  
        if x != 0: temp.push(x)  
    for i from 0 to temp.size()-1:  
        arr[i] = temp[i]  
    for i from temp.size() to n-1:  
        arr[i] = 0
```

---

### Code

#### C++
```cpp
void brute(vector<int>& arr) {
    vector<int> temp;
    for (int x : arr) {
        if (x != 0) temp.push_back(x);
    }
    for (int i = 0; i < temp.size(); i++) {
        arr[i] = temp[i];
    }
    for (int i = temp.size(); i < arr.size(); i++) {
        arr[i] = 0;
    }
}
```

#### JavaScript
```js
function brute(arr) {
    let temp = [];
    for (let x of arr) {
        if (x !== 0) temp.push(x);
    }
    for (let i = 0; i < temp.length; i++) {
        arr[i] = temp[i];
    }
    for (let i = temp.length; i < arr.length; i++) {
        arr[i] = 0;
    }
}
```

* Time: **O(n)**, Space: **O(n)** → **Not in-place**

---

## Approach 2: Optimal – Two Pointers (In-Place)

### Intuition  
> **Snowball / Dutch National Flag Style**

Use:
- `i` → next position to place **non-zero**
- `j` → current element

**Only move `i` when we find non-zero**

### Why This Approach?  
- **O(1) space**  
- **O(n) time**  
- **In-place**  
- **Preserves order**  
- **Interview favorite**

### Why This is Final?  
- **Optimal**  
- Clean, fast, production-ready  
- No better in-place method

---

### Algorithm  
1. `i = 0`  
2. For `j = 0` to `n-1`:  
  If `arr[j] != 0`:  
   `arr[i++] = arr[j]`  
3. For `i` to `n-1`:  
  `arr[i++] = 0`

---

### Pseudocode  
``` 
function optimal(arr):  
    i = 0  
    for j from 0 to n-1:  
        if arr[j] != 0:  
            arr[i++] = arr[j]  
    while i < n:  
        arr[i++] = 0
```

---

### Dry Run: [1, 0, 2, 3, 0, 4, 0, 1]

| j | arr[j] | i | Action | Array |
|---|--------|---|--------|-------|
| 0 | 1      | 0 | arr[0]=1, i=1 | [1,0,2,3,0,4,0,1] |
| 1 | 0      | 1 | skip | — |
| 2 | 2      | 1 | arr[1]=2, i=2 | [1,2,2,3,0,4,0,1] |
| 3 | 3      | 2 | arr[2]=3, i=3 | [1,2,3,3,0,4,0,1] |
| 4 | 0      | 3 | skip | — |
| 5 | 4      | 3 | arr[3]=4, i=4 | [1,2,3,4,0,4,0,1] |
| 6 | 0      | 4 | skip | — |
| 7 | 1      | 4 | arr[4]=1, i=5 | [1,2,3,4,1,4,0,1] |

Then fill `i=5` to `7` with `0` → `[1,2,3,4,1,0,0,0]`

---

### Code

#### C++ (LeetCode Style)
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i = 0;
        for (int j = 0; j < nums.size(); j++) {
            if (nums[j] != 0) {
                nums[i++] = nums[j];
            }
        }
        while (i < nums.size()) {
            nums[i++] = 0;
        }
    }
};
```

#### JavaScript
```js
function moveZeroes(arr) {
    let i = 0;
    for (let j = 0; j < arr.length; j++) {
        if (arr[j] !== 0) {
            arr[i++] = arr[j];
        }
    }
    while (i < arr.length) {
        arr[i++] = 0;
    }
}
```

* Time: **O(n)**, Space: **O(1)**

---

## Approach 3: Swap Version (Alternative Optimal)

### Intuition  
Find first zero (`j`), then swap non-zeros with it.

```cpp
int j = -1;
for (int i = 0; i < n; i++) {
    if (arr[i] == 0) { j = i; break; }
}
if (j == -1) return;

for (int i = j + 1; i < n; i++) {
    if (arr[i] != 0) {
        swap(arr[i], arr[j++]);
    }
}
```

Same complexity, slightly more swaps.

---

## 5. Edge Case List (Line-wise)

| Edge Case | Input | Expected | Handled? |
|---------|-------|----------|---------|
| No zeros | `[1,2,3]` | `[1,2,3]` | Yes |
| All zeros | `[0,0,0]` | `[0,0,0]` | Yes |
| Single element | `[5]` | `[5]` | Yes |
| Empty | `[]` | `[]` | Yes |
| Zeros at start | `[0,0,1,2]` | `[1,2,0,0]` | Yes |
| Zeros at end | `[1,2,0,0]` | `[1,2,0,0]` | Yes |

---

## 6. Complexity Summary

| Approach | Time | Space | Best For |
|--------|------|-------|----------|
| Extra Array | O(n) | O(n) | Learning |
| **Two Pointers** | **O(n)** | **O(1)** | **Interviews (Optimal)** |
| Swap Version | O(n) | O(1) | Alternative |

---

## 7. Final Consolidated Code

### C++ (LeetCode + Full)
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Brute: Extra Array
    void brute(vector<int>& arr) {
        vector<int> temp;
        for (int x : arr) {
            if (x != 0) temp.push_back(x);
        }
        for (int i = 0; i < temp.size(); i++) {
            arr[i] = temp[i];
        }
        for (int i = temp.size(); i < arr.size(); i++) {
            arr[i] = 0;
        }
    }

    // Optimal: Two Pointers (LeetCode)
    void moveZeroes(vector<int>& nums) {
        int i = 0;
        for (int j = 0; j < nums.size(); j++) {
            if (nums[j] != 0) {
                nums[i++] = nums[j];
            }
        }
        while (i < nums.size()) {
            nums[i++] = 0;
        }
    }

    // Swap Version
    void swapVersion(vector<int>& arr) {
        int j = -1;
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i] == 0) {
                j = i;
                break;
            }
        }
        if (j == -1) return;
        for (int i = j + 1; i < arr.size(); i++) {
            if (arr[i] != 0) {
                swap(arr[i], arr[j++]);
            }
        }
    }
};
```

### JavaScript
```javascript
class Solution {
    // Brute
    brute(arr) {
        let temp = [];
        for (let x of arr) {
            if (x !== 0) temp.push(x);
        }
        for (let i = 0; i < temp.length; i++) {
            arr[i] = temp[i];
        }
        for (let i = temp.length; i < arr.length; i++) {
            arr[i] = 0;
        }
    }

    // Optimal
    moveZeroes(arr) {
        let i = 0;
        for (let j = 0; j < arr.length; j++) {
            if (arr[j] !== 0) {
                arr[i++] = arr[j];
            }
        }
        while (i < arr.length) {
            arr[i++] = 0;
        }
    }
}
```

---

## 8. Interview Strategy

1. **Start**: "I'll use **two pointers** — **O(1) space**, **in-place**."  
2. "I'll keep `i` as the position to place next non-zero. For each `j`, if non-zero → place at `i++`."  
3. "Finally, fill from `i` to end with `0`."  
4. "Edge cases: no zeros, all zeros, single element → handled."  
5. **Bonus**: "Extra array uses O(n) space — not optimal. This is **best**."

---
