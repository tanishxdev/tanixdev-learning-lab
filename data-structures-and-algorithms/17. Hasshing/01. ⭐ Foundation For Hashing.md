# HASHING – COMPLETE ROADMAP

Important Note:

* Before solving any problems, review the fundamentals of hashing in `00/basics/13.basic-hashing`.
* This current file gives a high-level overview of hashing concepts, patterns, and strategies.
* For deeper explanations, implementations, and practice problems, explore to the `/17.Hashing` folder.

---

## 1. INTRODUCTION TO HASHING

Hashing is a technique to **store**, **search**, and **retrieve** data in O(1) average time.

### Why Hashing?

Most brute-force logic repeatedly scans the array, leading to:

* O(N²) time in nested loops
* O(N) per query

Hashing provides:

* **Fast lookup**
* **Frequency counting**
* **Uniqueness checks**
* **Order-independent comparisons**

### Key Structures Used in Hashing

* **Array Hashing** → if range is small
* **unordered_map** → frequency table, key-value pairs
* **unordered_set** → unique elements
* **map** → sorted key-value pairs

---

## 2. WHEN TO USE HASHING?

Use hashing when your problem mentions:

* "How many times…?"
* "Find frequency"
* "Check duplicates"
* "First repeating / non-repeating"
* "Distinct elements"
* "Equal by frequency"
* "Anagram check"
* "Order does NOT matter"
* "Fast search/lookup required"

Hashing simplifies these to **O(N)**.

---

## 3. MAJOR HASHING PATTERNS

### Pattern A: Frequency Counting

Used for:

* Count elements
* Highest frequency
* Lowest frequency
* Exactly K times
* Majority elements
* Anagrams

Core Idea:

```
freq[x]++
```

### Pattern B: First Occurrence / Order Preservation

Used for:

* First repeating
* First non-repeating
* Remove duplicates (preserve order)

Use `unordered_set` for seen-tracking.

### Pattern C: Hashing + Prefix Sum

Used for:

* Subarray sum = K
* Longest subarray with sum = K
* Zero-sum subarray
* Count subarrays divisible by K

Pattern:

```
prefixSum += arr[i]
Use map to check existing prefix
```

### Pattern D: Hashing + Strings

Used for:

* Anagrams
* First unique char
* Isomorphic strings
* Group anagrams

Pattern:

```
char → freq
char → mapping
string → sorted/hash signature
```

### Pattern E: Hash Set Problems

Used for:

* Longest consecutive sequence
* Duplicate check
* Unique elements

Pattern:

```
insert(x)
check existence
```

---

## 4. COMPLETE HASHING PROBLEM ROADMAP (22 Problems)

A well‑structured order to master hashing.

### GROUP 1 - Basic Frequency Problems

1. Count frequencies of array elements
2. Highest frequency element
3. Lowest frequency element
4. First non-repeating element
5. Remove duplicates (preserve order)
6. Check if two arrays are equal (frequency-based)
7. Check if two strings are anagrams
8. First repeating element
9. Count distinct elements
10. Elements appearing exactly K times

---

### GROUP 2 – Majority & Special Frequencies

11. Majority Element (> N/2)
12. Elements appearing more than N/3
13. Top K Frequent Elements

---

### GROUP 3 – Hashing + Prefix Sum (VERY IMPORTANT)

14. Count subarrays with sum = K
15. Longest subarray with sum = K
16. Zero-sum subarray
17. Total subarrays divisible by K

---

### GROUP 4 – String Hashing Problems

18. First unique character in string
19. Group Anagrams
20. Isomorphic Strings

---

### GROUP 5 – Set Based Problems

21. Longest Consecutive Sequence
22. Check if array contains duplicates

---

## 5. OVERVIEW OF HASHING TECHNIQUES

### 1. Array Hashing

* Works when range is small
* Fastest (O(1))
* Limited by memory

### 2. unordered_map

* Stores frequency or mapping
* Average O(1), worst O(N)
* Best for large values or unknown range

### 3. map

* Sorted key-value structure
* Guarantees O(log N)
* Used when sorting is required

### 4. unordered_set / set

* Stores only unique elements
* Used in duplicate removal, membership check

### 5. Hash Collisions (Conceptual)

* Two values mapped to same index
* Handled by chaining
* Rare in STL but important to understand

---

## 6. HASHING MINDSET (How to Think?)

### Always ask:

1. Do I need frequency?
2. Do I need uniqueness?
3. Do I need order preserved?
4. Is range small or large?
5. Should I use array hash, map, or set?

### Frequency Problem = unordered_map

### Unique or seen-tracking = unordered_set

### Small fixed range = array hash

### Order + frequency = two-pass method

### Subarray problems = prefix sum + map

---

## 7. WHAT YOU SHOULD MASTER AFTER THIS FILE

* Build hashing intuition
* Identify patterns instantly
* Solve all 22 problems
* Be interview-ready for all hashing questions

---
