# TIME COMPLEXITY (TC) & SPACE COMPLEXITY (SC) ‚Äì COMPLETE GUIDE

This topic answers one critical question:

üëâ How good or bad is your code?

---

## 1. What is Time Complexity?

Time Complexity tells:

> How much time an algorithm takes as input size increases.

Not measured in seconds, but in:
**number of operations performed.**

We express it using:

### Big-O Notation

---

## 2. What is Space Complexity?

Space Complexity tells:

> How much extra memory an algorithm uses.

Includes:
‚Ä¢ Variables
‚Ä¢ Arrays
‚Ä¢ Recursion stack
‚Ä¢ Temporary storage

---

# 3. WHY TC & SC ARE IMPORTANT

If two programs give same output:
We choose the one which:
‚Ä¢ Runs faster
‚Ä¢ Uses less memory

In interviews:
This is one of the MOST asked topics.

---

# 4. BIG-O NOTATION (Core)

Big-O tells worst-case performance.

Common complexities:

| Big-O      | Meaning           |
| ---------- | ----------------- |
| O(1)       | Constant          |
| O(log N)   | Logarithmic       |
| O(N)       | Linear            |
| O(N log N) | Efficient sorting |
| O(N¬≤)      | Nested loops      |
| O(2‚Åø)      | Very slow         |
| O(N!)      | Extremely slow    |

---

# 5. CONSTANT TIME ‚Äì O(1)

Input size doesn't matter.

Example:

```cpp
int x = a + b;
```

Always takes same time.

Array access:

```cpp
arr[5]
```

TC = O(1)

---

# 6. LINEAR TIME ‚Äì O(N)

Time increases proportional to input.

Example:

```cpp
for(int i = 0; i < n; i++)
   cout << arr[i];
```

If n doubles ‚Üí time doubles.

TC = O(N)

---

# 7. QUADRATIC TIME ‚Äì O(N¬≤)

Nested loops.

Example:

```cpp
for(int i=0;i<n;i++)
  for(int j=0;j<n;j++)
     cout << i*j;
```

TC = O(N * N) = O(N¬≤)

---

# 8. LOGARITHMIC ‚Äì O(log N)

Occurs when input reduces each step.

Example:
Binary Search

```
N = 16
Steps:
16 ‚Üí 8 ‚Üí 4 ‚Üí 2 ‚Üí 1
```

TC = O(log N)

---

# 9. SPACE COMPLEXITY EXAMPLES

### Example 1:

```cpp
int a = 10;
```

SC = O(1)

### Example 2:

```cpp
int arr[n];
```

SC = O(N)

### Example 3:

```cpp
int sum = 0;
for(int i=0;i<n;i++)
   sum += arr[i];
```

Extra space = sum + i
SC = O(1)

---

# 10. HOW TO CALCULATE TIME COMPLEXITY

### Rule 1: Ignore constants

O(2N) ‚Üí O(N)
O(5N¬≤) ‚Üí O(N¬≤)

### Rule 2: Keep highest power

O(N¬≤ + N) ‚Üí O(N¬≤)

### Rule 3: Nested loops multiply

Outer N √ó Inner N = N¬≤

---

# 11. DRY RUN ANALYSIS

### Code:

```cpp
for(int i=0;i<n;i++) {     // runs n times
   cout << i;
}
```

Operations = n
TC = O(N)

---

```cpp
for(int i=0;i<n;i++) {
   for(int j=0;j<n;j++) {
      cout << i+j;
   }
}
```

Operations = n * n
TC = O(N¬≤)

---

# 12. COMPARISON CHART

| Input Size | O(N) | O(N¬≤)     |
| ---------- | ---- | --------- |
| 10         | 10   | 100       |
| 100        | 100  | 10,000    |
| 1000       | 1000 | 1,000,000 |

---

# 13. COMMON INTERVIEW TRICKS

### Trick Code:

```cpp
for(int i=1;i<n;i=i*2)
```

i doubles each time ‚Üí log steps
TC = O(log N)

---

```cpp
for(int i=0;i<n;i++){
   for(int j=0;j<i;j++)
```

TC = 1 + 2 + 3 + ... + n
= O(N¬≤)

---

# 14. TIME vs SPACE

| Factor   | Time        | Space            |
| -------- | ----------- | ---------------- |
| Measures | Speed       | Memory           |
| Units    | Operations  | Bytes            |
| Goal     | Faster code | Memory efficient |

---

# MINI PRACTICE

Tell TC & SC:

1.

```
for(int i=0;i<n;i++)
   cout<<i;
```

2.

```
int arr[n];
```

3.

```
for(int i=0;i<n;i++)
   for(int j=0;j<n;j++)
      cout<<i;
```

---

# INTERVIEW QUICK POINTS

‚Ä¢ TC measures speed
‚Ä¢ SC measures memory
‚Ä¢ Big-O defines worst case
‚Ä¢ Nested loops increase TC
‚Ä¢ Try to convert O(N¬≤) ‚Üí O(N)
