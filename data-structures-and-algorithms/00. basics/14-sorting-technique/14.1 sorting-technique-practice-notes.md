# Sorting â€“ Basics Practice (Beginner)

This practice file helps you **apply sorting concepts**, not memorize algorithms.

ðŸ‘‰ Rule:
Think which sorting idea fits best **before coding**.

---

## PRACTICE QUESTIONS

---

### Q1. Check If Array Is Already Sorted

Given an array, check whether it is sorted in **non-decreasing order**.

Example:

```
Input: 1 2 3 4 5
Output: Sorted
```

---

### Q2. Find the Smallest Element and Its Index

Given an array, find the **minimum element** and its **index**.

(Think: selection sort intuition)

---

### Q3. Count How Many Swaps Bubble Sort Will Do (Worst Case)

Given an array sorted in **descending order**, how many swaps will bubble sort perform?

Example:

```
Input: 5 4 3 2 1
```

---

### Q4. Insert Last Element into Sorted Array

An array is sorted except the **last element**.
Insert the last element into its correct position.

Example:

```
Input: 1 3 5 7 2
Output: 1 2 3 5 7
```

---

### Q5. Merge Two Sorted Arrays

Given two sorted arrays, merge them into one sorted array.

Example:

```
A = 1 3 5
B = 2 4 6
```

---

### Q6. Partition an Array Around a Pivot

Given an array and a pivot value, move all elements:

* smaller than pivot to left
* greater than pivot to right

(Order doesnâ€™t matter)

---

### Q7. Find Kth Smallest Element (Brute Thinking)

Find the Kth smallest element using sorting.

Example:

```
Array: 7 10 4 3 20 15
K = 3
Output: 7
```

---

### Q8. Sort an Array of 0s and 1s

Given an array containing only 0s and 1s, sort it.

Example:

```
Input: 1 0 1 0 1
Output: 0 0 1 1 1
```

---

---

# SOLUTIONS

(Thinking â†’ Code â†’ Dry Run)

---

## Q1 Solution: Check Sorted

### Thinking

* Compare every element with next one
* If any violation â†’ not sorted

### Code

```cpp
bool isSorted(int arr[], int n)
{
    for(int i = 0; i < n - 1; i++)
    {
        if(arr[i] > arr[i + 1])
            return false;
    }
    return true;
}
```

### Dry Run

```
[1,2,3,4]
1<=2 OK
2<=3 OK
3<=4 OK
â†’ Sorted
```

---

## Q2 Solution: Minimum Element + Index

### Thinking

* Same idea as selection sortâ€™s first step

### Code

```cpp
int minIndex(int arr[], int n)
{
    int idx = 0;
    for(int i = 1; i < n; i++)
    {
        if(arr[i] < arr[idx])
            idx = i;
    }
    return idx;
}
```

### Dry Run

```
[13,46,24,9]
min = 13
compare 46 â†’ no
compare 24 â†’ no
compare 9 â†’ yes â†’ index 3
```

---

## Q3 Solution: Bubble Sort Swaps (Worst Case)

### Thinking

* Reverse array â†’ maximum inversions
* Bubble sort swaps = number of inversions
* For N elements â†’ N*(N-1)/2

### Answer

```
Swaps = N*(N-1)/2
```

Example:

```
N=5 â†’ 5*4/2 = 10 swaps
```

---

## Q4 Solution: Insert Last Element (Insertion Sort Idea)

### Thinking

* Treat array as insertion sort step
* Shift until correct position

### Code

```cpp
void insertLast(int arr[], int n)
{
    int key = arr[n-1];
    int j = n - 2;

    while(j >= 0 && arr[j] > key)
    {
        arr[j+1] = arr[j];
        j--;
    }
    arr[j+1] = key;
}
```

### Dry Run

```
[1,3,5,7,2]
Shift 7,5,3
Insert 2 at index 1
```

---

## Q5 Solution: Merge Two Sorted Arrays

### Thinking

* Same merge logic as merge sort
* Two pointers

### Code

```cpp
vector<int> mergeArrays(vector<int>& a, vector<int>& b)
{
    vector<int> res;
    int i = 0, j = 0;

    while(i < a.size() && j < b.size())
    {
        if(a[i] <= b[j]) res.push_back(a[i++]);
        else res.push_back(b[j++]);
    }

    while(i < a.size()) res.push_back(a[i++]);
    while(j < b.size()) res.push_back(b[j++]);

    return res;
}
```

---

## Q6 Solution: Partition Around Pivot

### Thinking

* Similar to quick sort partition
* One pass

### Code

```cpp
void partition(vector<int>& arr, int pivot)
{
    int i = 0;

    for(int j = 0; j < arr.size(); j++)
    {
        if(arr[j] < pivot)
        {
            swap(arr[i], arr[j]);
            i++;
        }
    }
}
```

---

## Q7 Solution: Kth Smallest (Sorting)

### Thinking

* Sort array
* Kth smallest = index k-1

### Code

```cpp
int kthSmallest(vector<int>& arr, int k)
{
    sort(arr.begin(), arr.end());
    return arr[k-1];
}
```

---

## Q8 Solution: Sort 0s and 1s

### Thinking

* Count approach
* No comparison needed

### Code

```cpp
void sort01(int arr[], int n)
{
    int zero = 0;
    for(int i = 0; i < n; i++)
        if(arr[i] == 0) zero++;

    for(int i = 0; i < n; i++)
        arr[i] = (i < zero ? 0 : 1);
}
```

---

## FINAL SORTING MINDSET (VERY IMPORTANT)

Before solving any sorting problem, ask:

1. **Is array almost sorted?** â†’ Insertion idea
2. **Need guaranteed performance?** â†’ Merge
3. **In-place fast average?** â†’ Quick
4. **Just concept learning?** â†’ Selection / Bubble
5. **Only 0/1 or small range?** â†’ Counting
