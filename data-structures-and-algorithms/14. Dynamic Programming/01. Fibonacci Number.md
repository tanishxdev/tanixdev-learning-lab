# PROBLEM (Original Statement)

Given an integer `n`, return the **n-th Fibonacci number**.

The Fibonacci sequence is defined as:

```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)   for n >= 2
```

---

## BREAKDOWN PROBLEM

### What is being asked?

- Compute the **n-th Fibonacci number**

### What is input?

- A single integer `n`

### What is output?

- An integer → `F(n)`

---

## CONSTRAINT UNDERSTANDING

Typical constraints (varies by platform):

- `0 <= n <= 45` (recursive allowed but slow)
- `0 <= n <= 10^6` (needs DP / optimized)

**Why constraints matter**

- Fibonacci grows exponentially
- Recursive solution becomes unusable very fast
- We must reduce **repeated calculations**

---

# BRUTE FORCE APPROACH

## First Thought Intuition

“Fibonacci is defined recursively, so let’s directly write that recursion.”

This feels natural because:

- Problem definition itself is recursive
- Easy to write
- Easy to understand

---

## Thought Process (Step-wise)

1. If `n` is `0` or `1`, return `n`
2. Otherwise:
   - Compute `fib(n-1)`
   - Compute `fib(n-2)`
   - Add them

Problem:
Same values are recomputed again and again.

---

## Pseudocode

```
function fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

---

## Algorithm

1. Check base case
2. Call function recursively
3. Return sum

---

## CODE (C++)

### ⭐ Approach 1: Recursive (Brute Force)

```cpp
// ⭐ Approach 1: Recursive
int fibRecursive(int n)
{
    // Base case:
    // If n is 0 or 1, Fibonacci value is n itself
    if (n <= 1)
        return n;

    // Recursive case:
    // Fibonacci of n is sum of previous two Fibonacci numbers
    return fibRecursive(n - 1) + fibRecursive(n - 2);
}
```

---

## Time and Space Complexity

- **Time Complexity:** `O(2^n)`
  - Every call creates two more calls

- **Space Complexity:** `O(n)`
  - Due to recursion call stack

---

## Dry Run (n = 5)

```
fib(5)
 ├─ fib(4)
 │   ├─ fib(3)
 │   │   ├─ fib(2)
 │   │   │   ├─ fib(1)
 │   │   │   └─ fib(0)
 │   │   └─ fib(1)
 │   └─ fib(2)
 └─ fib(3)
```

Same values like `fib(2)` and `fib(3)` are recomputed multiple times.

---

## Edge Cases

- `n = 0` → returns `0`
- `n = 1` → returns `1`
- Large `n` → **TLE**

---

## Does This Approach Fail?

**YES**

### Why?

- Too many repeated calculations
- Exponential time

### Constraint that breaks it

- `n > 40`

➡️ We need to **store results**.

---

# BETTER APPROACH

## Recursive + Top-Down DP (Memoization)

---

## First Thought Intuition

“If the same value is computed again, why not store it?”

This removes repetition.

---

## Thought Process (Step-wise)

1. Create a `memo` array
2. Before computing `fib(n)`, check if already stored
3. If stored → return it
4. Else → compute and store

---

## Pseudocode

```
function fib(n):
    if n <= 1: return n
    if memo[n] exists: return memo[n]
    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```

---

## CODE (C++)

### ⭐ Approach 2: Recursive + Memoization

```cpp
// Helper function to perform memoized recursion
int fibMemoHelper(int n, vector<int> &memo)
{
    // Base case
    if (n <= 1)
        return n;

    // If already calculated, return stored value
    if (memo[n] != -1)
        return memo[n];

    // Calculate, store, and return result
    memo[n] = fibMemoHelper(n - 1, memo) + fibMemoHelper(n - 2, memo);
    return memo[n];
}

int fibMemoization(int n)
{
    // Base case
    if (n <= 1)
        return n;

    // Create memo array initialized with -1
    vector<int> memo(n + 1, -1);

    return fibMemoHelper(n, memo);
}
```

---

## Time and Space Complexity

- **Time Complexity:** `O(n)`
  - Each Fibonacci number computed once

- **Space Complexity:** `O(n)`
  - Memo array + recursion stack

---

## Dry Run (n = 5)

```
fib(5)
 → compute once
 → stored in memo
 → reused later
```

---

## Does This Approach Fail?

**NO (for moderate n)**
But recursion stack still exists.

➡️ Can we remove recursion completely?

---

# OPTIMAL APPROACH

## Bottom-Up DP (Tabulation / Space Optimized)

---

## First Thought Intuition

“Instead of recursion, build the answer from `0` to `n`.”

---

## Thought Process (Step-wise)

1. Create `dp[]`
2. Store base values
3. Build forward
4. Return `dp[n]`

---

## CODE (C++)

### ⭐ Approach 3: Bottom-Up DP

```cpp
int fibBottomUp(int n)
{
    // Base case
    if (n <= 1)
        return n;

    // DP array to store Fibonacci values
    vector<int> dp(n + 1, 0);

    // Base initialization
    dp[1] = 1;

    // Build from bottom up
    for (int i = 2; i <= n; i++)
    {
        // Current Fibonacci is sum of previous two
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

---

## Space Optimized Version (BEST)

```cpp
/*
int fibBottomUp(int n)
{
    if (n <= 1)
        return n;

    int prev2 = 0; // F(0)
    int prev1 = 1; // F(1)

    for (int i = 2; i <= n; i++)
    {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
*/
```

---

## Time and Space Complexity

- **Time Complexity:** `O(n)`
- **Space Complexity:** `O(1)` (optimized)

---

## Why This Is Optimal

- No recursion
- No extra memory
- Linear time
- Works for very large `n`

---

# PATTERN RECOGNITION & MINDSET NOTES

### When you see:

- Recursive definition
- Overlapping subproblems

### Think:

- Memoization first
- Then bottom-up
- Then space optimization

### Core DP Thought:

> “Can I express current answer using **previous states**?”

---
