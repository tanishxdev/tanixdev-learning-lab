# Lower Bound

---

### 1. Problem Statement

**English**:  
Given a **sorted array** (non-decreasing) and a number `x`,  
find the **smallest index** such that `arr[index] >= x`  
If no such index exists → return `n` (size of array)

**Hinglish**:  
Sabse pehla index batao jahan value `>= x` ho.  
Agar koi bhi element `x` se bada ya barabar nahi → `n` return karo.

**Also called**: First position where `>= x` → **Lower Bound**

**Implement Lower Bound** : [Implement Lower Bound](https://www.geeksforgeeks.org/problems/implement-lower-bound/1)
**LeetCode**: [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/) (Same thing!)

**STL**: `lower_bound()` in C++ exactly does this!

---

### 2. Examples (Must Know)

| Example | Array           | x   | Answer | Why?                         |
| ------- | --------------- | --- | ------ | ---------------------------- |
| 1       | `[1,2,2,3]`     | 2   | 1      | arr[1] = 2 → first >= 2      |
| 2       | `[3,5,8,15,19]` | 9   | 3      | arr[3] = 15 → first >= 9     |
| 3       | `[1,2,3,4]`     | 5   | 4      | koi >=5 nahi → return n=4    |
| 4       | `[1,2,3,4]`     | 0   | 0      | sabse pehle 1 >= 0 → index 0 |
| 5       | `[2,2,2,2]`     | 2   | 0      | first occurrence             |
| 6       | `[]` (empty)    | 10  | 0      | size = 0 → return 0          |

---

### 3. Brute Force → Linear Search (Just for Understanding)

```cpp
for(int i = 0; i < n; i++){
    if(arr[i] >= x)
        return i;
}
return n;
```

Time → **O(N)** → TLE for large arrays  
Space → O(1)

**Not acceptable in interviews**

---

### 4. Optimal → Modified Binary Search (The Real Deal)

#### Golden Intuition (Yaad rakh lo!)

> **Normal Binary Search**: Find exact match  
> **Lower Bound**: Find **first position >= x** → even if not present, tell where it would be inserted!

**Only 2 Changes from Normal BS**:

| Normal BS                         | Lower Bound BS                        |
| --------------------------------- | ------------------------------------- |
| `if(arr[mid] == target)` → return | `if(arr[mid] >= x)` → possible answer |
| `else if <` → left                | → go **left** to find smaller index   |
| `else` → right                    | → go right only if too small          |

---

### 5. Algorithm (Step by Step)

```text
low = 0, high = n-1
ans = n                     // default answer if nothing found

while(low <= high){
    mid = low + (high-low)/2

    if(arr[mid] >= x){
        ans = mid           // possible answer
        high = mid - 1      // try to find smaller index on left
    }
    else{
        low = mid + 1       // too small → discard left
    }
}
return ans
```

**Key Point**: Jab bhi `arr[mid] >= x` milta hai →  
→ Yeh possible answer hai → `ans` update karo  
→ Aur **left mein check karo** kya aur chhota index mil sakta hai?

---

### 6. Dry Run → arr = [1,2,2,3], x = 2

| Step | low | high | mid | arr[mid] | >=2? | Action        | ans |
| ---- | --- | ---- | --- | -------- | ---- | ------------- | --- |
| 1    | 0   | 3    | 1   | 2        | Yes  | ans=1, high=0 | 1   |
| 2    | 0   | 0    | 0   | 1        | No   | low=1         | 1   |
| 3    | 1   | 0    | -   | -        | End  | return ans    | 1   |

**Correct! First >=2 at index 1**

---

### 7. Full Working Code (C++ & JavaScript)

#### C++ (Interview Favorite)

```cpp
class Solution {
public:
    int lowerBound(vector<int>& arr, int x) {
        int n = arr.size();
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] >= x) {
                ans = mid;
                high = mid - 1;        // go left for smaller index
            } else {
                low = mid + 1;         // too small → go right
            }
        }
        return ans;
    }
};
```

#### JavaScript

```js
function lowerBound(arr, x) {
  let n = arr.length;
  let low = 0,
    high = n - 1;
  let ans = n;

  while (low <= high) {
    let mid = low + Math.floor((high - low) / 2);

    if (arr[mid] >= x) {
      ans = mid;
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return ans;
}

// Test
console.log(lowerBound([1, 2, 2, 3], 2)); // 1
console.log(lowerBound([3, 5, 8, 15], 9)); // 3
console.log(lowerBound([1, 2, 3], 4)); // 3
```

---

### 8. Built-in Functions (Pro Tip!)

| Language | Function                                 | Returns                              |
| -------- | ---------------------------------------- | ------------------------------------ |
| C++      | `lower_bound(arr.begin(), arr.end(), x)` | iterator → `- arr.begin()` for index |
| Python   | `bisect.bisect_left(arr, x)`             | exact lower bound                    |
| Java     | `Collections.binarySearch()` + manual    | not direct                           |

**C++ Example**:

```cpp
vector<int> arr = {1,2,2,3};
auto it = lower_bound(arr.begin(), arr.end(), 2);
int index = it - arr.begin();  // → 1
```

---

### 9. Edge Cases Handled

| Case               | Handled? | Output            |
| ------------------ | -------- | ----------------- |
| x smaller than all | Yes      | 0                 |
| x larger than all  | Yes      | n                 |
| x equal to some    | Yes      | first occurrence  |
| All elements same  | Yes      | 0                 |
| Empty array        | Yes      | 0                 |
| Duplicates         | Yes      | first valid index |

---

### 10. Complexity

| Approach          | Time         | Space    | Verdict      |
| ----------------- | ------------ | -------- | ------------ |
| Linear Search     | O(N)         | O(1)     | TLE          |
| **Binary Search** | **O(log N)** | **O(1)** | **Accepted** |

**Only Binary Search is acceptable**

---

### 11. Summary Table (Revision Wala)

| Problem           | Condition           | What to return         | Move when condition true |
| ----------------- | ------------------- | ---------------------- | ------------------------ |
| Normal Search     | `== target`         | index                  | return immediately       |
| **Lower Bound**   | `>= x`              | **first such index**   | go **left**              |
| Upper Bound       | `> x`               | first strictly greater | go left                  |
| Search Insert Pos | same as lower bound | where to insert        | same                     |

---

### Final Notes (Yaad Rakhna Bhai!)

1. **Lower Bound = First >= x**
2. Jab `arr[mid] >= x` → possible answer → `ans = mid` → **left jaao**
3. Default answer = `n`
4. `lower_bound()` STL function exactly yahi karta hai
5. **LeetCode 35 (Search Insert Position)** → same question!
