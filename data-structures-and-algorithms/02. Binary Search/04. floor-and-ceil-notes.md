# Floor and Ceil in Sorted Array

---

### 1. Problem Statement

**English**:
Given a **sorted array** (non-decreasing order) of `n` integers and a value `x`,
find:

- **Floor of x** ‚Üí the **largest element ‚â§ x**
- **Ceil of x** ‚Üí the **smallest element ‚â• x**

If floor or ceil does not exist ‚Üí return `-1` for that value.

**Hinglish**:

- **Floor** ‚Üí `x` se **chhota ya barabar sabse bada number**
- **Ceil** ‚Üí `x` se **bada ya barabar sabse chhota number**

---

### 2. Examples (Must Know)

| Example | Array            | x   | Floor | Ceil | Explanation     |
| ------- | ---------------- | --- | ----- | ---- | --------------- |
| 1       | `[3,4,4,7,8,10]` | 5   | 4     | 7    | 4 ‚â§ 5 and 7 ‚â• 5 |
| 2       | `[3,4,4,7,8,10]` | 8   | 8     | 8    | exact match     |
| 3       | `[1,2,3]`        | 0   | -1    | 1    | no floor        |
| 4       | `[1,2,3]`        | 5   | 3     | -1   | no ceil         |
| 5       | `[2,2,2,2]`      | 2   | 2     | 2    | duplicates      |
| 6       | `[]`             | 10  | -1    | -1   | empty array     |

---

### 3. Brute Force (Just for Understanding)

```cpp
pair<int,int> floorAndCeil(int arr[], int n, int x) {

    int floorVal = -1;
    int ceilVal  = -1;

    // Find floor (largest <= x)
    for (int i = n - 1; i >= 0; i--) {
        if (arr[i] <= x) {
            floorVal = arr[i];
            break;
        }
    }

    // Find ceil (smallest >= x)
    for (int i = 0; i < n; i++) {
        if (arr[i] >= x) {
            ceilVal = arr[i];
            break;
        }
    }

    return {floorVal, ceilVal};
}
```

Usage

```cpp
    int arr[] = {1, 2, 8, 10, 10, 12, 19};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 5;

    auto ans = floorAndCeil(arr, n, x);
    cout << ans.first << " " << ans.second;
```

- **Time** ‚Üí O(N)
- **Space** ‚Üí O(1)
- ‚ùå Not acceptable in interviews

---
Got it üëç
You want **Topic 4 ‚Üí Topic 6 rewritten**, but **much clearer**, **more detailed**, and **properly structured with clean headings**, while **keeping your exact logic and style**.

Below is a **drop-in replacement** for **Section 4, 5, 6** of your notes.
You can paste this directly into your `.md` file.

---

## 4. Core Intuition (Binary Search Thinking)

> **Floor and Ceil are not new problems.**
> They are just **Binary Search with a different goal**.

Binary Search always does one thing:

> **Shrink the search space based on a condition.**

What changes in Floor / Ceil is:

* **What condition we check**
* **Which direction we move after a valid answer**

---

### 4.1 What exactly are we trying to find?

#### Floor of `x`

> **Largest value in the array that is ‚â§ x**

* Condition for validity ‚Üí `arr[mid] <= x`
* Optimization goal ‚Üí **as large as possible**

---

#### Ceil of `x`

> **Smallest value in the array that is ‚â• x**

* Condition for validity ‚Üí `arr[mid] >= x`
* Optimization goal ‚Üí **as small as possible**

---

#### 4.2 Why movement direction matters

Whenever `arr[mid]` satisfies the condition:

* It is a **possible answer**
* But it may **not be the best answer**

So:

* If we want a **smaller** valid value ‚Üí move **LEFT**
* If we want a **bigger** valid value ‚Üí move **RIGHT**

---

#### 4.3 Relation with Known Binary Search Patterns

| Concept     | Condition       | What we optimize | Move Direction |
| ----------- | --------------- | ---------------- | -------------- |
| **Floor**   | `arr[mid] <= x` | largest value    | **RIGHT**      |
| **Ceil**    | `arr[mid] >= x` | smallest value   | **LEFT**       |
| Lower Bound | `>= x`          | first position   | LEFT           |
| Upper Bound | `> x`           | first position   | LEFT           |

---

#### 4.4 One-Line Memory Rule (Very Important)

```
Want smaller answer  ‚Üí move LEFT
Want bigger answer   ‚Üí move RIGHT
```

---

### 5. Algorithm ‚Äì Ceil (Binary Search)

#### 5.1 Goal

> Find the **smallest value ‚â• x**

---

#### 5.2 Binary Search Logic

```text
low = 0, high = n-1
ans = -1

while(low <= high){
    mid = low + (high-low)/2

    if(arr[mid] >= x){
        ans = arr[mid]        // possible ceil
        high = mid - 1        // try smaller value on left
    }
    else{
        low = mid + 1         // too small, go right
    }
}
return ans
```

---

#### 5.3 Why this works (Intuition)

* `arr[mid] >= x` means:

  * This element **can be a ceil**
  * But maybe there is a **smaller valid ceil on the left**
* So:

  * Store it as answer
  * Move **LEFT**

If `arr[mid] < x`:

* Too small to be a ceil
* Discard left half
* Move **RIGHT**

---

#### 5.4 Key Takeaway for Ceil

> **Ceil always behaves like Lower Bound**
> First valid answer ‚Üí keep going left to minimize it

---

### 6. Algorithm ‚Äì Floor (Binary Search)

#### 6.1 Goal

> Find the **largest value ‚â§ x**

---

#### 6.2 Binary Search Logic

```text
low = 0, high = n-1
ans = -1

while(low <= high){
    mid = low + (high-low)/2

    if(arr[mid] <= x){
        ans = arr[mid]        // possible floor
        low = mid + 1         // try bigger value on right
    }
    else{
        high = mid - 1        // too big, go left
    }
}
return ans
```

---

#### 6.3 Why this works (Intuition)

* `arr[mid] <= x` means:

  * This element **can be a floor**
  * But maybe there is a **bigger valid floor on the right**
* So:

  * Store it as answer
  * Move **RIGHT**

If `arr[mid] > x`:

* Too big to be a floor
* Discard right half
* Move **LEFT**

---

#### 6.4 Key Takeaway for Floor

> **Floor is the opposite of Ceil**
> After success, always move **RIGHT** to maximize value

---

#### Final Mental Summary (Lock This)

```
Ceil  ‚Üí smallest ‚â• x ‚Üí LEFT on success
Floor ‚Üí largest  ‚â§ x ‚Üí RIGHT on success
```

---

### 7. Dry Run

`arr = [3,4,4,7,8,10], x = 5`

#### Ceil

| low | high | mid | arr[mid] | >=5? | ans | move   |
| --- | ---- | --- | -------- | ---- | --- | ------ |
| 0   | 5    | 2   | 4        | No   | -1  | low=3  |
| 3   | 5    | 4   | 8        | Yes  | 8   | high=3 |
| 3   | 3    | 3   | 7        | Yes  | 7   | high=2 |

‚Üí **Ceil = 7**

#### Floor

| low | high | mid | arr[mid] | <=5? | ans | move   |
| --- | ---- | --- | -------- | ---- | --- | ------ |
| 0   | 5    | 2   | 4        | Yes  | 4   | low=3  |
| 3   | 5    | 4   | 8        | No   | 4   | high=3 |
| 3   | 3    | 3   | 7        | No   | 4   | high=2 |

‚Üí **Floor = 4**

---

### 8. Full Working Code

#### C++ (Interview Preferred)

```cpp
class Solution {
public:

    // Function to find FLOOR of x
    // Floor = largest value in the array that is <= x
    int findFloor(vector<int>& arr, int x) {

        // low  -> start of search space
        // high -> end of search space
        int low = 0, high = arr.size() - 1;

        // ans stores the best floor found so far
        // Initialized to -1 (means floor does not exist)
        int ans = -1;

        // Binary Search loop
        // Runs while search space is valid
        while (low <= high) {

            // Calculate mid safely to avoid overflow
            int mid = low + (high - low) / 2;

            // If current element is <= x
            // It can be a possible floor
            if (arr[mid] <= x) {

                // Store current value as potential floor
                ans = arr[mid];

                // Try to find a larger value (closer to x)
                // on the RIGHT side
                low = mid + 1;
            }
            else {
                // arr[mid] > x means it cannot be floor
                // Floor must lie on the LEFT side
                high = mid - 1;
            }
        }

        // Return the largest value <= x
        // If not found, returns -1
        return ans;
    }


    // Function to find CEIL of x
    // Ceil = smallest value in the array that is >= x
    int findCeil(vector<int>& arr, int x) {

        // low  -> start of search space
        // high -> end of search space
        int low = 0, high = arr.size() - 1;

        // ans stores the best ceil found so far
        // Initialized to -1 (means ceil does not exist)
        int ans = -1;

        // Binary Search loop
        while (low <= high) {

            // Calculate mid safely
            int mid = low + (high - low) / 2;

            // If current element is >= x
            // It can be a possible ceil
            if (arr[mid] >= x) {

                // Store current value as potential ceil
                ans = arr[mid];

                // Try to find a smaller value (closer to x)
                // on the LEFT side
                high = mid - 1;
            }
            else {
                // arr[mid] < x means it cannot be ceil
                // Ceil must lie on the RIGHT side
                low = mid + 1;
            }
        }

        // Return the smallest value >= x
        // If not found, returns -1
        return ans;
    }
};
```

#### JavaScript

```js
// Function to find FLOOR of x
// Floor = largest value in the array that is <= x
function findFloor(arr, x) {

  // low  -> start index of search space
  // high -> end index of search space
  let low = 0,
      high = arr.length - 1;

  // ans stores the best floor found so far
  // Initialized to -1 (means floor does not exist)
  let ans = -1;

  // Binary Search loop
  while (low <= high) {

    // Calculate mid index
    // Math.floor is required because JS division gives decimals
    let mid = low + Math.floor((high - low) / 2);

    // If current element is <= x
    // It can be a valid floor
    if (arr[mid] <= x) {

      // Store current value as possible floor
      ans = arr[mid];

      // Try to find a larger valid floor on the RIGHT
      low = mid + 1;
    }
    else {
      // arr[mid] > x, cannot be floor
      // Move to LEFT side
      high = mid - 1;
    }
  }

  // Return largest value <= x
  return ans;
}


// Function to find CEIL of x
// Ceil = smallest value in the array that is >= x
function findCeil(arr, x) {

  // low  -> start index of search space
  // high -> end index of search space
  let low = 0,
      high = arr.length - 1;

  // ans stores the best ceil found so far
  // Initialized to -1 (means ceil does not exist)
  let ans = -1;

  // Binary Search loop
  while (low <= high) {

    // Calculate mid index safely
    let mid = low + Math.floor((high - low) / 2);

    // If current element is >= x
    // It can be a valid ceil
    if (arr[mid] >= x) {

      // Store current value as possible ceil
      ans = arr[mid];

      // Try to find a smaller valid ceil on the LEFT
      high = mid - 1;
    }
    else {
      // arr[mid] < x, cannot be ceil
      // Move to RIGHT side
      low = mid + 1;
    }
  }

  // Return smallest value >= x
  return ans;
}


// Test
console.log(findFloor([3, 4, 4, 7, 8, 10], 5)); // 4
console.log(findCeil([3, 4, 4, 7, 8, 10], 5)); // 7

```

---

### 9. Edge Cases Covered

| Case               | Floor        | Ceil          |
| ------------------ | ------------ | ------------- |
| x smaller than all | -1           | first element |
| x greater than all | last element | -1            |
| x exists           | x            | x             |
| duplicates         | correct      | correct       |
| empty array        | -1           | -1            |

---

### 10. Complexity Analysis

| Approach          | Time         | Space    | Verdict |
| ----------------- | ------------ | -------- | ------- |
| Linear            | O(N)         | O(1)     | ‚ùå      |
| **Binary Search** | **O(log N)** | **O(1)** | ‚úÖ      |

---

### 11. Interview Connections (Very Important)

1. **Floor using Lower Bound**

```
idx = lower_bound(arr, x) - 1
```

2. **Ceil using Lower Bound**

```
idx = lower_bound(arr, x)
```

3. Used in:

- Range queries
- Closest element problems
- Scheduling & allocation problems

---

### Final Notes

1. **Floor = last ‚â§ x**
2. **Ceil = first ‚â• x**
3. Floor ‚Üí move right on success
4. Ceil ‚Üí move left on success
5. Classic Binary Search pattern

---
