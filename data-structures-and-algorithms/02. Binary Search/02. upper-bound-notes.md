# Upper Bound

---

### 1. Problem Statement

**English**:
Given a **sorted array** (non-decreasing order) and a number `x`,
find the **smallest index** such that `arr[index] > x`.
If no such index exists → return `n` (size of array).

**Hinglish**:
Sabse pehla index batao jahan value **strictly `> x`** ho.
Agar koi element `x` se strictly bada nahi hai → `n` return karo.

**Also called**: First position where `> x` → **Upper Bound**

**STL**: `upper_bound()` in C++
**Related**: Lower Bound + Count Occurrences

**Implement Upper Bound** : [Implement Upper Bound
](https://www.geeksforgeeks.org/problems/implement-upper-bound/1)

---

### 2. Examples (Must Know)

| Example | Array           | x   | Answer | Why                    |
| ------- | --------------- | --- | ------ | ---------------------- |
| 1       | `[1,2,2,3]`     | 2   | 3      | arr[3] = 3 → first > 2 |
| 2       | `[3,5,8,15,19]` | 9   | 3      | arr[3] = 15 > 9        |
| 3       | `[1,2,3,4]`     | 4   | 4      | koi >4 nahi → n        |
| 4       | `[1,2,3,4]`     | 0   | 0      | arr[0]=1 > 0           |
| 5       | `[2,2,2,2]`     | 2   | 4      | no element > 2         |
| 6       | `[]`            | 10  | 0      | empty array            |

---

### 3. Brute Force (Just for Understanding)

```cpp
for(int i = 0; i < n; i++){
    if(arr[i] > x)
        return i;
}
return n;
```

- **Time** → O(N)
- **Space** → O(1)
- ❌ **Not acceptable in interviews**

---

### 4. Core Intuition (Golden Rule)

> **Upper Bound = First index where value is STRICTLY GREATER than x**

Relation with other patterns:

| Pattern         | Condition | Meaning          |
| --------------- | --------- | ---------------- |
| Normal BS       | `== x`    | exact match      |
| Lower Bound     | `>= x`    | first possible   |
| **Upper Bound** | `> x`     | strictly greater |

**Key Thinking**:
Jab `arr[mid] > x` mile →
→ yeh **possible answer** hai
→ lekin shayad left side mein aur chhota index ho
→ **left jaate raho**

---

### 5. Algorithm (Binary Search)

```text
low = 0, high = n-1
ans = n                       // default

while(low <= high){
    mid = low + (high-low)/2

    if(arr[mid] > x){
        ans = mid             // possible answer
        high = mid - 1        // go left
    }
    else{
        low = mid + 1         // too small or equal
    }
}
return ans
```

**Only difference from Lower Bound**

- Lower Bound → `>= x`
- Upper Bound → `> x`

---

### 6. Dry Run

`arr = [1,2,2,3], x = 2`

| Step | low | high | mid | arr[mid] | >2? | Action        | ans |
| ---- | --- | ---- | --- | -------- | --- | ------------- | --- |
| 1    | 0   | 3    | 1   | 2        | No  | low = 2       | 4   |
| 2    | 2   | 3    | 2   | 2        | No  | low = 3       | 4   |
| 3    | 3   | 3    | 3   | 3        | Yes | ans=3, high=2 | 3   |
| End  | 3   | 2    | -   | -        | -   | return ans    | 3   |

✅ First element strictly greater than `2` is at index `3`.

---

### 7. Full Working Code

#### C++ (Interview Preferred)

```cpp
class Solution {
public:
    int upperBound(vector<int>& arr, int x) {
        int n = arr.size();
        int low = 0, high = n - 1;
        int ans = n;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] > x) {
                ans = mid;          // possible answer
                high = mid - 1;     // search left
            } else {
                low = mid + 1;      // move right
            }
        }
        return ans;
    }
};
```

#### JavaScript

```js
function upperBound(arr, x) {
  let n = arr.length;
  let low = 0,
    high = n - 1;
  let ans = n;

  while (low <= high) {
    let mid = low + Math.floor((high - low) / 2);

    if (arr[mid] > x) {
      ans = mid;
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return ans;
}

// Tests
console.log(upperBound([1, 2, 2, 3], 2)); // 3
console.log(upperBound([2, 2, 2], 2)); // 3
console.log(upperBound([1, 3, 5], 6)); // 3
```

---

### 8. STL Shortcut (Must Know)

```cpp
vector<int> arr = {1, 2, 2, 3};

// upper_bound returns an iterator pointing to the FIRST element
// that is STRICTLY GREATER than the given value (2 in this case)
int idx = upper_bound(arr.begin(), arr.end(), 2) - arr.begin();

// idx = 3


// ⭐ What upper_bound Does (Core Concept)

// upper_bound(arr.begin(), arr.end(), x)
// → returns an iterator to the first element > x

// For x = 2, it skips all occurrences of 2 and stops at the next bigger element.

// ⭐ Dry Run (Step-by-Step)

// Array with indices:

// Index:  0  1  2  3
// Value:  1  2  2  3

// Call:

// upper_bound(arr.begin(), arr.end(), 2)

// 1 → less than 2 → skip
// 2 → equal to 2 → skip
// 2 → equal to 2 → skip
// 3 → strictly greater than 2 → STOP

// Iterator points to index 3

// Subtracting arr.begin():

// idx = 3
```

#### Important Difference (Very Common Interview Question)

| Function      | Meaning                | Result (for 2) |
| ------------- | ---------------------- | -------------- |
| `lower_bound` | First element **>= x** | index `1`      |
| `upper_bound` | First element **> x**  | index `3`      |

- Uses Binary Search internally
- Time → O(log n)

---

### 9. Edge Cases Covered

| Case                | Output                |
| ------------------- | --------------------- |
| x smaller than all  | 0                     |
| x greater than all  | n                     |
| x equal to elements | after last occurrence |
| All elements same   | n                     |
| Empty array         | 0                     |
| Duplicates          | first `> x`           |

---

### 10. Complexity Analysis

| Approach          | Time         | Space    | Verdict |
| ----------------- | ------------ | -------- | ------- |
| Linear Search     | O(N)         | O(1)     | ❌      |
| **Binary Search** | **O(log N)** | **O(1)** | ✅      |
| STL               | O(log N)     | O(1)     | ✅      |

---

### 11. Interview Use-Cases (Very Important)

1. **Count occurrences of x**

```
count = upper_bound(x) - lower_bound(x)

count = upper_bound(arr.begin(), arr.end(), x) - lower_bound(arr.begin(), arr.end(), x);

```

2. **Find last occurrence**

```
last = pper_bound(arr.begin(), arr.end(), x) - 1
(check validity)
```

3. **Insert after duplicates**

- Use upper bound instead of lower bound

---

### 12. Summary Table (Revision)

| Concept         | Condition | Move when true | Default |
| --------------- | --------- | -------------- | ------- |
| Lower Bound     | `>= x`    | left           | n       |
| **Upper Bound** | `> x`     | left           | n       |

---

### Final Notes (Yaad Rakh Bhai)

1. **Upper Bound = First > x**
2. Jab condition true ho → `ans = mid` → **left jao**
3. Default answer = `n`
4. Lower + Upper bound se **count, range, frequency** nikalte hain
5. Binary Search ka **core interview pattern** hai

---
