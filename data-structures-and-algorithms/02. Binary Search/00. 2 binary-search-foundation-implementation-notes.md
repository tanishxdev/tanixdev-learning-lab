# Binary Search

---

### 1. Problem Statement (Classic)

**English**:  
Given a **sorted array** (non-decreasing order) of `n` integers and a `target`,  
find the **index** of the target. If not present → return `-1`.

**Hinglish**:  
Sorted array hai → target dhundho, index return karo, nahi mila to -1.

**LeetCode**: [704. Binary Search](https://leetcode.com/problems/binary-search/)  
**GFG**: Search in a sorted array

---

### 2. Input / Output / Constraints

| Example | Input Array             | Target | Output | Why |
|-------|--------------------------|--------|--------|-----|
| 1     | `[1,2,3,4,5,6,7]`       | 4      | 3      | Present |
| 2     | `[1,3,5,7,9]`           | 6      | -1     | Not present |
| 3     | `[10]`                  | 10     | 0      | Single element |
| 4     | `[]` (empty)            | 5      | -1     | Empty array |
| 5     | `[2,2,2,2,2]`           | 2      | Any valid index (0-4) | Duplicates |

**Constraints**  
- `1 ≤ n ≤ 10⁵`  
- `-10⁹ ≤ arr[i], target ≤ 10⁹`  
- Array is **sorted in non-decreasing order**

---

### 3. Real-Life Intuition (Dictionary Wala Example)

> Imagine a thick dictionary (sorted alphabetically)

**Linear Search** → page 1 se last tak dekho → O(n)  
**Binary Search** →  
1. Book ko beech mein kholo  
2. Dekho left page pe “S” se shuru hai → “raj” isse pehle hoga → right half hatao  
3. Ab left half ko beech mein kholo → repeat  
→ Har baar aadha part fek dete ho → **log n steps** mein mil jata hai!

**Golden Rule**: Binary Search tabhi kaam karega jab data **sorted** ho!

---

### 4. Core Concept – Search Space

```
low = 0                high = n-1
    ↓-----------------------↓
    |   Search Space (sorted)   |
```

- **Search Space** = all elements between `low` and `high` (including them)
- Har step mein hum search space ko **exactly half** karte hain
- Jab `low > high` → search space khatam → target nahi mila

---

### 5. The Famous Mid Calculation Bug (MUST KNOW)

```cpp
int mid = (low + high) / 2;        // WRONG for big arrays → Integer Overflow!
```

**Correct Ways** (choose any one):

```cpp
int mid = low + (high - low) / 2;           // Best & Safe
int mid = (low + high) >> 1;                // Bitwise (fast)
int mid = low + ((high - low) >> 1);        // Most preferred
```

---

### 6. Approaches

#### Approach 1: Iterative Binary Search (Most Used in Interviews)

```cpp
int binarySearch(vector<int>& arr, int target) {

    // Size of the array
    // Used to define the search space boundaries
    int n = arr.size();

    // low  -> starting index of current search space
    // high -> ending index of current search space
    int low = 0, high = n - 1;

    // Loop runs while the search space is valid
    // IMPORTANT: using <= ensures single-element case is checked
    // If we used <, we might skip the last remaining element
    while (low <= high) {

        // Calculate mid safely to avoid integer overflow
        // (low + high) / 2 can overflow for large values
        int mid = low + (high - low) / 2;

        // Case 1: target found at mid
        // Return index immediately (binary search guarantees correctness)
        if (arr[mid] == target)
            return mid;

        // Case 2: mid element is smaller than target
        // So target must lie in the RIGHT half (if it exists)
        // We eliminate left half including mid
        else if (arr[mid] < target)
            low = mid + 1;

        // Case 3: mid element is greater than target
        // So target must lie in the LEFT half (if it exists)
        // We eliminate right half including mid
        else
            high = mid - 1;
    }

    // If loop ends, search space became empty
    // That means target does not exist in the array
    return -1;
}

// Key Thinking Notes (Interview-Oriented)

// Why low <= high?
// Ensures the last remaining element is checked.

// Why mid + 1 and mid - 1?
// Because mid has already been compared; keeping it would cause infinite loop.

// Why overflow-safe mid?
// Required for large inputs (important in interviews).

// Precondition (must say in interview):
// Array must be sorted.
```

#### Approach 2: Recursive Binary Search

```cpp
// Helper recursive function that performs binary search
// arr    -> sorted input array
// low    -> starting index of current search space
// high   -> ending index of current search space
// target -> value we are searching for
int solve(vector<int>& arr, int low, int high, int target) {

    // Base case:
    // If low crosses high, search space becomes invalid
    // This means the target does not exist in the array
    if (low > high)
        return -1;

    // Calculate mid index safely to avoid integer overflow
    int mid = low + (high - low) / 2;

    // Case 1: Target found at mid index
    // Immediately return the index
    if (arr[mid] == target)
        return mid;

    // Case 2: Middle element is smaller than target
    // Target (if present) must lie in the RIGHT half
    // So we discard left half including mid
    if (arr[mid] < target)
        return solve(arr, mid + 1, high, target);

    // Case 3: Middle element is greater than target
    // Target (if present) must lie in the LEFT half
    // So we discard right half including mid
    else
        return solve(arr, low, mid - 1, target);
}

// Public function that user calls
// This hides recursion details from the caller
int search(vector<int>& arr, int target) {

    // Start binary search on the full array range
    return solve(arr, 0, arr.size() - 1, target);
}

// Dry Run (Small Example)
// --------------------------

// arr = [1, 3, 5, 7, 9]
// target = 7

// search(arr, 7)
// → solve(arr, 0, 4)
// → mid = 2 → arr[2] = 5 < 7
// → solve(arr, 3, 4)
// → mid = 3 → arr[3] = 7 (found)

// Time & Space Complexity
// --------------------------

// Time Complexity: O(log n)
// Space Complexity: O(log n)
// (due to recursion stack)

// Common Mind Mistakes (Interview Traps)
// --------------------------

// Forgetting base condition (low > high)
// → leads to infinite recursion

// Using mid again without +1 / -1
// → recursion never shrinks

// Using recursion without explaining stack space
// → interviewer may reject answer

// Not mentioning sorted array requirement
```

---

### 7. Dry Run → arr = [2,3,4,6,8,10,12], target = 8

| Step | low | high | mid | arr[mid] | Action            |
|------|-----|------|-----|----------|-------------------|
| 1    | 0   | 6    | 3   | 6        | 8 > 6 → low = 4   |
| 2    | 4   | 6    | 5   | 10       | 8 < 10 → high = 4 |
| 3    | 4   | 4    | 4   | 8        | Found! → return 4 |


#### Interview Tip (Must Say)

> Iterative binary search is preferred in production because it avoids recursion stack space, but recursive version is easier to reason about logically.


---

### 8. Full Working Code (C++ & JavaScript)

#### C++ (Iterative – Interview Favorite)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {

        // Total number of elements in the array
        int n = nums.size();

        // low  -> starting index of the current search range
        // high -> ending index of the current search range
        int low = 0, high = n - 1;

        // Continue searching while the range is valid
        // Using <= ensures even a single remaining element is checked
        while (low <= high) {

            // Calculate mid index safely to avoid overflow
            // (low + high) / 2 could overflow for large values
            int mid = low + (high - low) / 2;

            // Case 1: Target element found at mid
            // Return the index immediately
            if (nums[mid] == target)
                return mid;

            // Case 2: Middle element is smaller than target
            // Target must be in the RIGHT half
            // So discard left half including mid
            else if (nums[mid] < target)
                low = mid + 1;

            // Case 3: Middle element is greater than target
            // Target must be in the LEFT half
            // So discard right half including mid
            else
                high = mid - 1;
        }

        // If loop ends, the target element does not exist in the array
        return -1;
    }
};
```

#### JavaScript

```js
function binarySearch(arr, target) {

    // low  -> starting index of the search space
    // high -> ending index of the search space
    let low = 0, high = arr.length - 1;

    // Loop continues while the search space is valid
    // Using <= is important to handle single-element search space
    while (low <= high) {

        // Calculate mid index
        // Math.floor is used because JS division gives floating-point numbers
        // This formula also avoids potential overflow issues
        let mid = low + Math.floor((high - low) / 2);

        // Case 1: target found at mid index
        if (arr[mid] === target)
            return mid;

        // Case 2: mid element is smaller than target
        // Target must lie in the RIGHT half
        // Discard left half including mid
        else if (arr[mid] < target)
            low = mid + 1;

        // Case 3: mid element is greater than target
        // Target must lie in the LEFT half
        // Discard right half including mid
        else
            high = mid - 1;
    }

    // If loop ends, target does not exist in the array
    return -1;
}

// Test
console.log(binarySearch([2,3,4,6,8,10,12], 8));  // 4
console.log(binarySearch([1,2,3,4,5], 9));       // -1

// ⭐ Important Notes (Interview Mindset)

// Precondition:
// Array must be sorted (ascending).

// Why low <= high?
// Ensures the last remaining element is checked.

// Why mid + 1 / mid - 1?
// Prevents infinite loop by shrinking search space.

// Time Complexity: O(log n)
// Space Complexity: O(1) (iterative)

// ⭐ Common JavaScript-Specific Mistakes

// Forgetting Math.floor → mid becomes decimal
// Using == instead of ===
// Modifying mid instead of low / high
// Applying binary search on unsorted array

```

---

### 9. Edge Cases Covered

| Case                  | Handled? | How |
|-----------------------|----------|-----|
| Empty array           | Yes      | high = -1 → loop nahi chalega |
| Single element        | Yes      | low = high = 0 |
| Target at start       | Yes      | mid = 0 → found |
| Target at end         | Yes      | last iteration |
| Target not present    | Yes      | low > high → return -1 |
| Duplicates            | Yes      | Will return any one index |
| Integer overflow      | Yes      | `low + (high-low)/2` |

---

### 10. Complexity Analysis

| Approach      | Time          | Space    | Best For              |
|---------------|---------------|----------|-----------------------|
| Linear Search | O(n)          | O(1)     | Not acceptable        |
| **Binary Search** | **O(log n)** | **O(1)** (iterative) | **Interviews**        |
| Recursive BS  | O(log n)      | O(log n) (call stack) | Learning recursion |

**Final Verdict**: Iterative Binary Search is the **only acceptable** solution for interviews.

---

### 11. Pro Tips

1. **Hamesha `low + (high-low)/2` use karo** → overflow se bacho  
2. Loop condition → `while(low <= high)`  
3. Binary search **sirf sorted data** pe kaam karta hai  
4. Search space shrink karte raho → ya to left half ya right half  
5. Jab `low > high` → target nahi hai

---