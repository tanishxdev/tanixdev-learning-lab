# 10. Common Mistakes & Interview Traps (Async / Await)

---

## 1. Thinking `async/await` Makes Code Synchronous ❌

### Mistake

Believing that `await` blocks the entire program.

```js
await doTask();
```

### Reality

* `await` pauses **only the current async function**
* It does **NOT block the event loop**
* Other code continues running

### Correct mental model

```
async function pauses
↓
JS thread is free
↓
Promise resolves
↓
function resumes
```

### Interview trap

**Q:** Does `await` block the event loop?
**Correct answer:**
“No. It only pauses the async function. The event loop remains non-blocking.”

---

## 2. Forgetting that `async` Functions Always Return a Promise ❌

### Mistake

Expecting a normal value from an async function.

```js
async function getData() {
  return 10;
}
```

### Reality

This returns:

```js
Promise.resolve(10)
```

### Correct usage

```js
getData().then(value => console.log(value));
```

or

```js
const value = await getData();
```

### Interview trap

**Q:** What does an async function return?
**Answer:**
“It always returns a Promise, even if you return a normal value.”

---

## 3. Using `await` Outside an Async Function ❌

### Mistake

```js
const data = await fetchData(); // ❌ SyntaxError
```

### Reality

* `await` can be used only:

  * inside `async` functions
  * OR top-level await (ES modules only)

### Correct approach

```js
async function run() {
  const data = await fetchData();
}
```

### Interview trap

**Q:** Where can `await` be used?
**Answer:**
“Inside async functions, or at top level in ES modules.”

---

## 4. Missing `try...catch` Around `await` ❌

### Mistake

Assuming rejected Promises won’t crash code.

```js
await riskyTask();
console.log("Next line");
```

### Reality

* Rejected Promise = thrown error
* Without `try/catch`, it becomes an unhandled rejection

### Correct pattern

```js
try {
  await riskyTask();
} catch (err) {
  console.log(err);
}
```

### Interview trap

**Q:** How do you handle errors in async/await?
**Answer:**
“Using try/catch blocks around awaited Promises.”

---

## 5. Using `await` Sequentially When Parallel Execution Is Needed ❌

### Mistake

```js
await task1();
await task2();
```

This runs **one after another**.

### Better approach (parallel)

```js
await Promise.all([task1(), task2()]);
```

### Correct mental model

| Pattern          | Behavior |
| ---------------- | -------- |
| Sequential await | Slower   |
| Promise.all      | Faster   |

### Interview trap

**Q:** How do you run async tasks in parallel with async/await?
**Answer:**
“By starting Promises first and awaiting them using Promise.all.”

---

## 6. Mixing `.then()` with `await` Unnecessarily ❌

### Mistake

```js
await fetchData().then(data => console.log(data));
```

### Reality

* This defeats the purpose of async/await
* Mixing styles reduces readability

### Correct approach

```js
const data = await fetchData();
console.log(data);
```

### Interview trap

**Q:** Should we mix `.then()` with `await`?
**Answer:**
“No. Use one style consistently. Prefer async/await for readability.”

---

## 7. Forgetting to Return Values from Async Functions ❌

### Mistake

```js
async function calculate() {
  const result = await compute();
}
```

### Problem

* Function resolves with `undefined`

### Correct approach

```js
async function calculate() {
  const result = await compute();
  return result;
}
```

### Interview trap

**Q:** What happens if you don’t return anything from async function?
**Answer:**
“It resolves with undefined.”

---

## 8. Assuming Async/Await Improves Performance ❌

### Mistake

Thinking async/await is faster than Promises.

### Reality

* Async/await is **syntax sugar**
* Performance is the same
* It improves **readability**, not speed

### Interview trap

**Q:** Is async/await faster than Promises?
**Answer:**
“No. It’s built on Promises. Performance is the same.”

---

## 9. Ignoring Error Propagation Rules ❌

### Mistake

Expecting execution to continue after rejected await.

```js
await failTask();
console.log("This runs"); // ❌ never runs
```

### Reality

* Rejection jumps directly to `catch`

### Correct mental model

```
await rejected Promise
↓
throw error
↓
jump to catch
```

### Interview trap

**Q:** What happens after a rejected awaited Promise?
**Answer:**
“Execution jumps to the nearest catch block.”

---

## 10. Thinking Async/Await Replaces Promises ❌

### Mistake

Believing Promises are no longer important.

### Reality

* Async/Await depends entirely on Promises
* No Promise → no await

### Core truth

```
Promise = foundation
Async/Await = syntax layer
```

### Interview trap

**Q:** Can async/await work without Promises?
**Answer:**
“No. Async/await is built on top of Promises.”

---

## Final Interview One-Line Summary (Memorize)

* Async/Await does not block the event loop
* Async functions always return Promises
* `await` pauses functions, not JS
* Errors are handled using try/catch
* Parallel work requires Promise.all
* Async/Await improves readability, not performance

---

## Mental Checklist Before Writing Async Code

* Is this sequential or parallel?
* Do I need try/catch?
* Am I returning values properly?
* Am I avoiding mixing `.then()`?
* Am I blocking logic accidentally?
