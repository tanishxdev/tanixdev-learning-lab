# Peterson’s Algorithm in Process Synchronization

---

## 1. Introduction

In a multitasking operating system, **multiple processes may try to enter the critical section at the same time**.

If this access is not controlled, it leads to **race conditions**, where the correctness of the result depends on the order of execution instead of program logic.

To handle this, a synchronization mechanism must ensure:

- Only one process enters the critical section at a time  
- Other processes wait safely  
- No process waits forever  

**Peterson’s Algorithm** is a **classical software-based solution** to the **critical section problem**.

> It guarantees correct synchronization for **exactly two processes**, without using special hardware instructions.

---

## 2. Why Peterson’s Algorithm Was Needed

In early operating systems, **hardware-level synchronization support did not exist**.

OS designers needed a method that could work using **only shared variables**, while still guaranteeing:

- **Mutual Exclusion** – only one process in the critical section  
- **Progress** – if a process wants to enter, it eventually will  
- **Bounded Waiting** – no starvation  

Peterson’s Algorithm was designed to **prove that synchronization is possible using pure software**, at least for two processes.

---

## 3. Core Intuition Behind the Algorithm

Peterson’s Algorithm is based on **polite cooperation and fairness**.

Each process follows a disciplined rule:

1. Declare the intention to enter the critical section  
2. Give the other process a chance to go first  
3. Wait only if the other process also wants to enter **and** it is their turn  

This behavior guarantees:

- No simultaneous entry  
- No deadlock  
- No starvation  

---

## 4. Shared Variables Used

The algorithm uses **two shared variables**, accessible by both processes.

---

### 4.1 `flag[i]` — Interest Indicator

- `flag[i] = true` → Process `Pi` wants to enter the critical section  
- `flag[i] = false` → Process `Pi` does not want to enter  

This variable represents **intent**.

---

### 4.2 `turn` — Tie Breaker

- Indicates which process should wait  
- Resolves conflicts when both processes want to enter at the same time  

---

## 5. Algorithm Description

Assume two processes: **P0** and **P1**

Let:
- `i` = current process  
- `j` = other process (`j = 1 - i`)  

---

### Code for Process `Pi`

```c
do {
    flag[i] = true;      // Express intent to enter
    turn = j;            // Give priority to the other process

    while (flag[j] && turn == j)
        ;                // Busy wait

    // -------- Critical Section --------

    flag[i] = false;     // Exit critical section

    // -------- Remainder Section --------

} while (true);
````

---

## 6. Step-by-Step Working

Let’s understand how the algorithm works internally.

---

### Step 1: Declare Intent

```c
flag[i] = true;
```

The process announces:

> “I want to enter the critical section.”

---

### Step 2: Yield Priority

```c
turn = j;
```

The process politely says:

> “If the other process also wants to enter, let them go first.”

---

### Step 3: Wait Condition

```c
while (flag[j] && turn == j);
```

The process waits **only if**:

* The other process wants to enter
* And it is currently the other process’s turn

If either condition becomes false, waiting stops.

---

### Step 4: Enter Critical Section

* The process enters safely
* Mutual exclusion is guaranteed
* Only one process can be inside at a time

---

### Step 5: Exit

```c
flag[i] = false;
```

The process signals that it has finished, allowing the other process to proceed.

---

## 7. Why Peterson’s Algorithm Is Correct

Peterson’s Algorithm satisfies **all three requirements** of a correct critical section solution.

---

### 7.1 Mutual Exclusion

* If both processes want to enter, `turn` ensures only one proceeds
* Simultaneous entry is impossible

---

### 7.2 Progress

* If no process is inside the critical section
* One of the waiting processes will be selected
* The system does not get stuck

---

### 7.3 Bounded Waiting

* A process cannot be postponed indefinitely
* The `turn` variable ensures fairness

---

## 8. Real-Life Analogy

| OS Concept       | Real-Life Situation          |
| ---------------- | ---------------------------- |
| Processes        | Two people                   |
| Critical Section | Single washroom              |
| `flag`           | “I want to use it” indicator |
| `turn`           | “You go first” decision      |

Because both people follow the same rule, **conflict never occurs**.

---

## 9. Theoretical Use Cases

Peterson’s Algorithm can be conceptually applied to:

* Two processes sharing a printer
* Two processes updating a shared file
* Two processes competing for a single resource

> These examples are **theoretical**, not practical implementations.

---

## 10. Limitations of Peterson’s Algorithm

Despite being elegant, Peterson’s Algorithm is **not used in modern operating systems**.

Major limitations:

1. Works only for **two processes**
2. Uses **busy waiting**, wasting CPU cycles
3. Assumes atomic read/write of shared variables
4. Modern CPUs may reorder memory operations
5. Not suitable for multiprocessor systems

Because of these issues, modern systems rely on:

* Hardware atomic instructions
* Mutexes
* Semaphores
* Monitors

---

## 11. Interview Questions

### Basic

1. What is Peterson’s Algorithm?
2. Which problem does it solve?
3. How many processes does it support?

---

### Conceptual

1. Why is the `turn` variable necessary?
2. What happens if `turn` is removed?
3. Does Peterson’s Algorithm guarantee bounded waiting?

---

### Tricky

1. Is Peterson’s Algorithm used in modern OS?
   → No, it is mainly for theoretical understanding.

2. Is Peterson’s Algorithm lock-free?
   → No, it relies on busy waiting.

---

## 12. Key Takeaways

* Peterson’s Algorithm is a **pure software solution**
* Solves the critical section problem for **two processes only**
* Guarantees:

  * Mutual exclusion
  * Progress
  * Bounded waiting
* Important for understanding **how synchronization works internally**
* Forms the conceptual foundation for modern synchronization techniques

> **Peterson’s Algorithm is about correctness, not performance.**
