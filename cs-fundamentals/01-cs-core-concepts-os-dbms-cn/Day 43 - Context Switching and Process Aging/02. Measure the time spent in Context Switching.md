# **Measuring Context Switch Time**

---

### **1. What is Context Switching (Quick Recap)**

**Definition:**
Context switching is the process where the **CPU stops executing one process**, saves its state (registers, program counter, etc.), and **loads the state of another process** so that multitasking can occur efficiently.

**Purpose:**
It allows multiple processes to **share a single CPU**, ensuring fairness and responsiveness.

**But —** this switch takes time, and that **time spent** is what we aim to **measure** today.

---

### **2. Why Measure Context Switch Time?**

Because:

* Context switching causes **CPU overhead**.
* If switches are **too frequent**, CPU efficiency drops.
* Measuring this helps **optimize scheduling algorithms** and system performance.

Essentially, we want to find **how much time the CPU wastes switching** between processes rather than doing real work.

---

### **3. Understanding Context Switch Time**

When a context switch occurs:

1. CPU saves the **current process state** (registers, stack pointer, etc.) into its PCB (Process Control Block).
2. CPU loads the **next process’s saved state** from its PCB.
3. The OS scheduler updates control information.

This entire operation = **Context Switch Time (Tc)**.

---

### **4. Challenges in Measuring It**

Directly measuring `Tc` is tricky because:

* The **OS scheduler** and **interrupts** run in the background.
* Other **kernel-level activities** interfere with measurements.
* It’s very small (in **microseconds**), so precision matters.

To get accurate results:

* We minimize interference.
* We create a **controlled environment** for measurement.

---

### **5. Experimental Setup**

We can estimate context switch time by using **two communicating processes (P1 and P2)**.

#### **Mechanism:**

* P1 and P2 communicate via a **pipe**.
* Each communication (send/receive) causes a **context switch**.
* We measure **round-trip time** of a message between them.

#### **Sequence:**

1. P2 starts **blocked**, waiting for a message.
2. P1 records **start time**, sends a **token** to P2.
3. P1 then **waits for a response**, causing a context switch.
4. P2 receives the token and sends a reply → another switch.
5. P1 receives the reply and records **end time**.

Total round-trip involves **2 context switches**.

---
### **6. Formula for Context Switch Time**

Let the following terms be defined:

* **Td** = Time to deliver a token
* **Tr** = Time to receive a token
* **Tc** = Time taken for one context switch
* **T**  = Total measured round-trip time

**Formula:**

```
T = 2 × (Td + Tr) + 2 × Tc
```

Solving for **context switch time (Tc):**

```
Tc = [ T − 2 × (Td + Tr) ] / 2
```

---

### **7. Example Calculation**

Given:

* Td = 2 μs
* Tr = 2 μs
* T  = 24 μs

Substitute values into the formula:

```
24 = 2 × (2 + 2) + 2 × Tc
24 = 8 + 2 × Tc
```

Solving:

```
Tc = 8 μs
```

**Context Switch Time = 8 μs**

---

### **8. Practical Code Example (C Program)**

Below is a simplified Linux program to **estimate context switch time**.

```cpp
#include <bits/stdc++.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/wait.h>
using namespace std;

int main() {
    int fd1[2], fd2[2];
    if (pipe(fd1) == -1 || pipe(fd2) == -1) {
        cerr << "Pipe creation failed!" << endl;
        return 1;
    }

    pid_t pid = fork();

    if (pid < 0) {
        cerr << "Fork failed!" << endl;
        return 1;
    }

    const int iterations = 1000;
    char buf = 'x';

    if (pid == 0) {
        // Child Process
        for (int i = 0; i < iterations; i++) {
            read(fd1[0], &buf, 1);   // Wait for parent
            write(fd2[1], &buf, 1);  // Send reply to parent
        }
    } else {
        // Parent Process
        timeval start, end;
        gettimeofday(&start, nullptr);

        for (int i = 0; i < iterations; i++) {
            write(fd1[1], &buf, 1);  // Send token to child
            read(fd2[0], &buf, 1);   // Receive reply from child
        }

        gettimeofday(&end, nullptr);
        wait(nullptr);  // Wait for child to finish

        double total_time_us = (end.tv_sec - start.tv_sec) * 1e6 +
                               (end.tv_usec - start.tv_usec);

        double avg_context_switch_time = total_time_us / (iterations * 2.0);

        cout << fixed << setprecision(3);
        cout << "Total round-trip time: " << total_time_us << " μs\n";
        cout << "Approximate context switch time: " 
             << avg_context_switch_time << " μs" << endl;
    }

    return 0;
}
```

#### **Explanation:**

* 1000 round trips = 2000 context switches.
* Each `read/write` causes a process switch.
* Dividing total time by 2000 gives **average switch time per process**.

---

##### **Example: Measuring Context Switch Time (Using Pipes + fork)**

##### **Idea**

* Parent and child processes **ping-pong a byte** using pipes.
* Each send/receive causes a **context switch**.
* Measure total time → divide by number of context switches.

---

##### **What the Program Does (Very Short)**

1. Create **two pipes**:

   * Parent → Child
   * Child → Parent
2. `fork()` creates a **child process**.
3. Parent sends a byte → child receives → child sends back → parent receives.
4. Repeat this **1000 times**.
5. Measure total time for all round trips.
6. Compute **average context switch time**.

---

##### **Key Formula Used**

```
Average Context Switch Time
= Total Time / (2 × Number of Iterations)
```

(Each iteration causes **2 context switches**)

---

##### **Minimal Code (Concept-Only Version)**

```cpp
pipe(fd1);  // Parent -> Child
pipe(fd2);  // Child -> Parent
fork();

repeat N times:
    Parent writes byte
    Child reads byte
    Child writes back
    Parent reads byte
```

---

##### **Why This Works**

* Every `read()` / `write()` between processes
  forces the OS to **switch CPU context**.
* Repeating many times gives a **good average**.

---

##### **Output Meaning**

```
Total round-trip time: XXXX μs
Approximate context switch time: YY μs
```

* `YY μs` ≈ **time taken for one context switch**

---

##### **One-Liner**

> Context switch time can be measured by repeatedly exchanging a token between parent and child processes using pipes and dividing total time by the number of context switches.

--
---

### **9. Observations**

| System Type   | Typical Context Switch Time |
| ------------- | --------------------------- |
| Modern Linux  | 1–10 μs                     |
| Older systems | 20–100 μs                   |
| Real-time OS  | < 1 μs                      |

---

### **10. Factors Affecting Measurement**

| Factor                | Effect                                    |
| --------------------- | ----------------------------------------- |
| **CPU architecture**  | Faster CPUs switch faster                 |
| **Kernel efficiency** | Optimized kernel reduces delay            |
| **Process count**     | More processes → more context switch load |
| **Cache performance** | Misses increase switch time               |
| **System load**       | High load adds delay                      |

---

### **11. Conclusion**

| Aspect             | Summary                                                             |
| ------------------ | ------------------------------------------------------------------- |
| **Goal**           | Estimate time lost in switching processes                           |
| **Key Formula**    | `Tc = (T - 2(Td + Tr)) / 2`                                         |
| **Core Idea**      | Use two processes and a pipe to trigger consistent context switches |
| **Typical Result** | Few microseconds per switch                                         |
| **Optimization**   | Minimize frequent preemptions, tune scheduling                      |

---

### **12. Final Notes**

* Context switching is **unavoidable** but should be **minimized**.
* The cost is small per switch but large when multiplied across thousands of switches per second.
* OS designers aim to **reduce switch frequency** or **make switching faster** using efficient PCB management.

