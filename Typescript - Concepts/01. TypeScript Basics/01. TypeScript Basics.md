# 01. Introduction to TypeScript

---

## 1.1 What is TypeScript?

TypeScript is a **statically typed superset of JavaScript**.

Meaning:

* Every JavaScript code is valid TypeScript.
* TypeScript adds extra features on top of JavaScript.
* TypeScript code is converted into JavaScript before execution.

### Simple Definition

> TypeScript = JavaScript + Types + Safety + Better Development Experience

---

## 1.2 How TypeScript Works (Behind the Scenes)

TypeScript never runs directly.

Execution flow:

```
TypeScript (.ts)
        ‚Üì
TypeScript Compiler (tsc / ts-node)
        ‚Üì
JavaScript (.js)
        ‚Üì
Browser / Node.js executes
```

So:

* Browser still understands only JavaScript.
* TypeScript is for developers, not for the browser.

---

## 1.3 Why TypeScript Was Created

Problem with JavaScript:

* No strict typing
* Errors appear at runtime
* Difficult debugging in large projects

TypeScript solves this by:

* Checking types before code runs
* Making code predictable
* Reducing production bugs
* Improving scalability and maintainability

---

## 1.4 Core Features of TypeScript

### 1. Static Typing

You define what type of data a variable can store.

```ts
let age: number = 21;
```

Now this is illegal:

```ts
age = "twenty"; // Error before runtime
```

---

### 2. Strong Tooling

TypeScript provides:

* Autocomplete
* IntelliSense
* Refactoring support
* Error highlighting

---

### 3. Modern JavaScript Support

Supports:

* ES6+ features
* Interfaces
* Generics
* Classes
* Enums

---

## 1.5 First TypeScript Program

### File: `intro.ts`

```ts
// Declaring a variable with type annotation
let message: string = "Hello, World!";

// Printing message to console
console.log(message);
```

### Output

```
Hello, World!
```

### Explanation

* `string` enforces the type.
* Prevents assigning non-string values.

---

## 1.6 Comments in TypeScript

Same as JavaScript.

### Single-line

```ts
// This is a single line comment
```

### Multi-line

```ts
/*
   This is
   a multi-line
   comment
*/
```

Purpose:

* Explain logic
* Clarify intent
* Temporarily disable code

---

## 1.7 Where TypeScript is Used

---

### Client Side (Frontend)

Used for:

* Browser logic
* DOM manipulation
* UI state handling

Frameworks:

* Angular
* React
* Vue

TypeScript helps UI code remain predictable and safe.

---

### Server Side (Backend)

Used for:

* APIs
* Database operations
* Authentication systems

Frameworks:

* Express + TS
* NestJS
* Fastify

Ensures:

* Type-safe request handling
* Reliable API structure

---

## 1.8 JavaScript vs TypeScript

| Feature             | JavaScript    | TypeScript        |
| ------------------- | ------------- | ----------------- |
| Typing              | Dynamic       | Static (optional) |
| Execution           | Runs directly | Compiled to JS    |
| Error Detection     | Runtime       | Compile-time      |
| Scalability         | Weak          | Strong            |
| Code Predictability | Low           | High              |
| Tooling Support     | Basic         | Advanced          |

---

## 1.9 Adding TypeScript to HTML

### Step 1: types.ts

```ts
let myString: string = "Hello from TypeScript";
console.log(myString);
```

### Step 2: Compile

```bash
tsc types.ts
```

Creates:

```
types.js
```

### Step 3: HTML

```html
<script src="types.js"></script>
```

Browser runs the JS output.

---

## 1.10 Limitations of TypeScript

1. Requires compilation
2. Learning curve
3. Additional configuration
4. Slightly slower initial setup

But:
‚úÖ Massive long-term benefits
‚úÖ Professional-grade code quality

---

## 1.11 Intuition (Very Simple)

JavaScript:

> Write fast, fix later.

TypeScript:

> Think first, write safe, scale forever.

---

## 1.12 Interview-Level Summary

**What is TypeScript?**

> TypeScript is a statically typed superset of JavaScript that compiles to JavaScript. It helps developers catch errors at development time, improves maintainability, and enables scalable application development with strong tooling support.

---

# 2. TS Variables

Variables are containers used to store data so it can be reused and manipulated throughout the program.

In TypeScript, variables become more powerful because they can be **type-safe**.

---

## Concept

A variable in TypeScript:

* Stores a value
* Has a specific data type
* Can follow strict rules to prevent logical errors

Basic idea:

```
Variable = Name + Type + Value
```

---

# Ways to Declare Variables in TypeScript

There are 3 main patterns.

---

## 1. Declare Type and Value Together

```ts
let name: string = "Amit";
const age: number = 25;
```

### Explanation

* `name` ‚Üí variable
* `string` ‚Üí data type
* `"Amit"` ‚Üí actual value
* Type and value are defined in one place.

Best for clarity and safety.

---

## 02. Declare Type Without Value

```ts
let city: string;
console.log(city);
```

### Explanation

* Type is known
* Value is undefined until assigned
* Default value will be `undefined`

Used when value will be assigned later.

---

## 3. Declare Value Without Type (Type Inference)

```ts
let country = "India";
```

TypeScript automatically infers:

```
country ‚Üí string
```

This is called **Type Inference**.

---

# Variable Declaration Keywords

There are 3 keywords:

* var
* let
* const

Each behaves differently.

---

## var (Avoid This)

### Concept

* Function scoped
* Hoisted
* Allows redeclaration

Example:

```ts
function testVar() {
  var globalVar = "I am function scoped";
  console.log(globalVar);
}
testVar();
```

### Problems

* Can cause unpredictable bugs
* Scope confusion

‚úÖ Modern rule:
**Avoid var completely.**

---

## let (Recommended)

### Concept

* Block scoped
* Safe
* No redeclaration in same scope

Example:

```ts
let count = 5;

if (count > 0) {
  let message = "Count is positive";
  console.log(message);
}

// console.log(message); // Error
```

### Key Point

`message` only exists inside `{ }`

Best for variables that change.

---

## const (Most Strict)

### Concept

* Block scoped
* Cannot be reassigned

Example:

```ts
const country = "India";
// country = "USA"; // Error
```

Use when value should never change.

---

# var vs let vs const (Real Comparison)

| Feature       | var      | let   | const |
| ------------- | -------- | ----- | ----- |
| Scope         | Function | Block | Block |
| Reassign      | ‚úÖ        | ‚úÖ     | ‚ùå     |
| Redeclare     | ‚úÖ        | ‚ùå     | ‚ùå     |
| Hoisting Risk | High     | Low   | Low   |
| Recommended   | ‚ùå Never  | ‚úÖ Yes | ‚úÖ Yes |

---

# Type Annotations in Variables

Type annotation = explicitly defining type.

```ts
let userName: string = "Arjun";
let age: number = 25;
let isActive: boolean = true;
```

Now TypeScript enforces correctness.

---

## Function Example

```ts
function greetUser(name: string, age: number): string {
  return `Hello, ${name}! You are ${age} years old.`;
}

let greeting = greetUser("Arjun", 25);
console.log(greeting);
```

### Output

```
Hello, Arjun! You are 25 years old.
```

---

# Variable Scope in TypeScript

Scope determines where a variable can be accessed.

---

## 1. Local Scope

Declared inside a block or function.

```ts
function testLocalScope() {
  let localVar = "I am local";
  console.log(localVar);
}
```

Accessible only inside the function.

---

## 2. Global Scope

Declared outside any block.

```ts
let globalVar = 10;

function displayGlobalVar() {
  console.log(globalVar);
}
```

Accessible everywhere.

---

## 3. Class Scope

Declared inside class.

```ts
class Employee {
  salary: number = 50000;

  printSalary(): void {
    console.log(this.salary);
  }
}
```

Accessible through class object.

---

# Full Scope Example

```ts
let globalVar: number = 10;

class Geeks {
  private classVar: number = 11;

  assignNum(): void {
    let localVar: number = 12;
    console.log("Local Variable:", localVar);
  }
}

console.log("Global Variable:", globalVar);

let obj = new Geeks();
obj.assignNum();
```

### Output

```
Global Variable: 10
Local Variable: 12
```

---

# Naming Rules for Variables

‚úÖ Allowed:

* Letters (A-Z, a-z)
* Numbers (not at start)
* `_` and `$`

‚ùå Not Allowed:

* Starting with number
* Special symbols like @, #, %

Valid:

```ts
let user_name = "John";
let $price = 100;
```

Invalid:

```ts
let 1name = "Invalid";
```

---

# Best Practices (Important)

‚úÖ Use `const` by default
‚úÖ Use `let` if value changes
‚ùå Never use `var`
‚úÖ Always add type when learning

---

# Common Beginner Mistakes

| Mistake                       | Why it's wrong |
| ----------------------------- | -------------- |
| Using var                     | Scope bugs     |
| No type annotation            | Unsafe logic   |
| Reassign const                | Compile error  |
| Access block variable outside | Scope error    |

---

# Summary

You learned:

* What variables are
* How to declare them in TypeScript
* var vs let vs const
* Type Annotations
* Scope types (local, global, class)
* Best practices

---

# Practice Task

Try this in your folder:

```ts
let studentName: string = "Tanish";
let marks: number = 85;
const isPassed: boolean = true;

console.log(studentName, marks, isPassed);
```

Then try to break it by assigning wrong type and observe the error.

---


# 03.TS DataTypes

---

## Concept

A **data type** defines the kind of value a variable can store.

In simple words:

> Data type = Rule that tells what type of data is allowed

TypeScript enforces this rule at compile time, preventing logical mistakes.

Example:

```ts
let score: number = 90;     // ‚úÖ valid
score = "ninety";           // ‚ùå Error
```

---

# Classification of Data Types in TypeScript

TypeScript data types are divided into 3 main groups:

1. Primitive Types
2. Object Types
3. Advanced Types

---

# 1. Primitive Data Types

These are basic, simple, and immutable values.

They store single values.

---

## 1.1 number

Represents:

* Integers
* Decimals
* Positive & Negative numbers

```ts
let price: number = 99.5;
let age: number = 21;
```

Invalid:

```ts
price = "99"; // ‚ùå Error
```

---

## 1.2 string

Represents textual data.

```ts
let name: string = "Tanish";
let message: string = `Welcome ${name}`;
```

Supports:

* Single quotes
* Double quotes
* Template literals

---

## 1.3 boolean

Represents logical values.

```ts
let isPassed: boolean = true;
let isLoggedIn: boolean = false;
```

Only accepts:

```
true | false
```

---

## 1.4 null

Represents intentional absence of value.

```ts
let result: null = null;
```

Used when we want to say:

> The value exists but is empty.

---

## 1.5 undefined

Represents uninitialized value.

```ts
let data: undefined;
```

Means:

> Variable declared but not assigned.

---

## 1.6 symbol

Represents unique immutable identifiers.

```ts
let id: symbol = Symbol("id");
```

Mostly used in advanced object manipulation.

---

## 1.7 bigint

Used for very large integers beyond normal limits.

```ts
let bigNumber: bigint = 9007199254740991n;
```

Note: Must use `n` suffix.

---

# Primitive Types Summary

| Type      | Meaning           |
| --------- | ----------------- |
| number    | Numeric values    |
| string    | Text              |
| boolean   | true / false      |
| null      | Empty value       |
| undefined | Not initialized   |
| symbol    | Unique identifier |
| bigint    | Large integers    |

---

# 2. Object Types

These can store complex and structured data.

---

## 2.1 Array

Collection of similar data types.

```ts
let marks: number[] = [90, 85, 78];
let names: string[] = ["Amit", "Ravi", "Tanish"];
```

Alternative syntax:

```ts
let scores: Array<number> = [10, 20, 30];
```

---

## 2.2 Tuple

Array with fixed number and fixed types.

```ts
let student: [string, number] = ["Tanish", 21];
```

Order matters:
1st ‚Üí string
2nd ‚Üí number

---

## 2.3 Enum

Set of named constants.

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move: Direction = Direction.Up;
```

Used for predefined values.

---

## 2.4 Function Type

Defines input and output types.

```ts
function add(a: number, b: number): number {
  return a + b;
}
```

Ensures strict parameter checking.

---

## 2.5 Object

Represents a structured object.

```ts
let user: { name: string; age: number } = {
  name: "Tanish",
  age: 21
};
```

---

## 2.6 Interface

Defines the shape of an object.

```ts
interface User {
  name: string;
  age: number;
}

let person: User = {
  name: "Arjun",
  age: 25
};
```

---

# Object Types Summary

| Type      | Purpose               |
| --------- | --------------------- |
| Array     | List of values        |
| Tuple     | Fixed structured list |
| Enum      | Named constants       |
| Function  | Callable data         |
| Object    | Structured data       |
| Interface | Object blueprint      |

---

# 3. Advanced Data Types

These give flexibility + power.

---

## 3.1 Union Types

Allows multiple possible types.

```ts
let id: number | string;
id = 101;
id = "A101";
```

---

## 3.2 Intersection Types

Combines multiple types.

```ts
type A = { name: string };
type B = { age: number };

type C = A & B;

let user: C = {
  name: "Tanish",
  age: 21
};
```

---

## 3.3 Literal Types

Allows exact values only.

```ts
let status: "success" | "error";
status = "success";  // ‚úÖ
status = "pending";  // ‚ùå
```

---

## 3.4 Mapped Types

Create new types from existing types.

```ts
type ReadonlyUser = {
  readonly name: string;
  readonly age: number;
};
```

We‚Äôll cover in advanced section.

---

# Best Practices for Data Types

‚úÖ Use specific types
‚úÖ Avoid `any`
‚úÖ Prefer type inference when obvious
‚úÖ Use union instead of any
‚úÖ Leverage interfaces

---

# Common Mistakes

| Mistake              | Problem                   |
| -------------------- | ------------------------- |
| Using any            | Disables TypeScript power |
| Mixing types         | Leads to bugs             |
| Not typing functions | Unsafe parameters         |
| Using var            | Scope issues              |

---

# Practice Section

Try this code in your environment:

```ts
let username: string = "Tanish";
let score: number = 95;
let pass: boolean = true;

let subjects: string[] = ["Math", "Science"];
let userInfo: [string, number] = ["Tanish", 21];

console.log(username, score, pass, subjects, userInfo);
```

Try changing types and observe errors.

---

# 04. TS Type Annotations

---

## Concept

**Type Annotation = Explicitly telling TypeScript what type a variable, parameter, or property must have.**

In simple terms:

> Type Annotations are labels that define what kind of data is allowed.

They make your code:

* Predictable
* Safer
* Self-documented
* Error-resistant

---

## Why Type Annotations Are Needed

Without annotation:

```ts
let value;
value = 10;
value = "Hello"; // No error in plain JS thinking
```

With annotation:

```ts
let value: number;
value = 10;
value = "Hello"; // ‚ùå Error
```

TypeScript stops the mistake before runtime.

This is the real power.

---

# Syntax of Type Annotation

General pattern:

```ts
variableName: Type = value;
```

---

# 1. Variable Type Annotations

### Example

```ts
const str: string = "GeeksforGeeks";
const num: number = 6;
const arr: (number | string)[] = ["GFG", "TypeScript", 500, 20];

console.log(typeof str);
console.log(typeof num);
console.log(arr);
```

### Explanation

* `str: string` ‚Üí Only string allowed
* `num: number` ‚Üí Only number allowed
* `(number | string)[]` ‚Üí Array can contain both numbers and strings

### Output

```
string
number
["GFG", "TypeScript", 500, 20]
```

---

# 2. Function Type Annotations

We can annotate:

* Parameters
* Return type

## Syntax

```ts
function functionName(param: type): returnType {
  return value;
}
```

### Example

```ts
function greet(name: string): string {
  return `Hello, ${name}!`;
}

console.log(greet("Alice"));
```

### Explanation

* `name: string` ‚Üí Only string accepted
* `: string` ‚Üí Function must return string

### Output

```
Hello, Alice!
```

If you pass:

```ts
greet(10); // ‚ùå Error
```

TypeScript blocks it.

---

# 3. Object Type Annotations

Objects can also be strictly typed.

### Example

```ts
const person: { name: string; age: number } = {
  name: "Alice",
  age: 30
};
console.log(person);
```

### Explanation

* Requires:

  * name ‚Üí string
  * age ‚Üí number
* Anything extra OR missing causes error

This enforces structure.

---

# 4. Array Type Annotations

You define what type of values the array can store.

### Example

```ts
const numbers: number[] = [1, 2, 3, 4, 5];
console.log(numbers);
```

### Rules

* Only numbers allowed
* No strings or mixed values unless union is specified

---

# 5. Class Type Annotations

Classes use type annotations for:

* Properties
* Constructor parameters
* Methods

### Example

```ts
class Rectangle {
  width: number;
  height: number;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  area(): number {
    return this.width * this.height;
  }
}

const rect = new Rectangle(5, 10);
console.log(rect);
console.log(rect.area());
```

### Output

```
Rectangle { width: 5, height: 10 }
50
```

### Explanation

* width & height must be numbers
* area() must return a number

---

# Where Type Annotations Can Be Applied

| Place           | Example                         |
| --------------- | ------------------------------- |
| Variable        | `let age: number = 25;`         |
| Function param  | `function add(a: number)`       |
| Function return | `): string`                     |
| Object          | `{ name: string; age: number }` |
| Array           | `string[]`                      |
| Class property  | `width: number`                 |

---

# Type Annotation vs Type Inference

### Type Annotation

```ts
let score: number = 95;
```

You explicitly tell the type.

### Type Inference

```ts
let score = 95;
```

TypeScript automatically detects it as number.

‚úÖ Both are valid
‚úÖ Annotation is preferred during learning

---

# Benefits of Type Annotations

1. Early error detection
2. Better IntelliSense
3. Code self-documentation
4. Safer refactoring
5. Predictable behavior

---

# Common Mistakes

| Mistake                             | Why wrong              |
| ----------------------------------- | ---------------------- |
| Using any                           | Removes type safety    |
| Incorrect return type               | Causes compiler error  |
| Missing annotation in complex logic | Hidden bugs            |
| Wrong parameter types               | Runtime issues avoided |

---

# Real-World Example

```ts
function calculateTotal(price: number, tax: number): number {
  return price + (price * tax);
}

let total = calculateTotal(100, 0.18);
console.log(total);
```

No incorrect usage allowed.

---

# Quick Practice

Try this yourself:

```ts
let username: string = "Tanish";
let isOnline: boolean = true;
let marks: number = 82;

function printUser(name: string, marks: number): string {
  return `${name} scored ${marks}`;
}

console.log(printUser(username, marks));
```

Now try passing a wrong type and see compiler error.

---

# Summary

You now understand:

* What type annotations are
* Why they exist
* How to use them with:

  * Variables
  * Functions
  * Objects
  * Arrays
  * Classes
* Difference between annotation and inference

---

# 05. TS Enums

---

## Concept

**Enum (Enumeration)** is a way to define a fixed set of related constants under one name.

Instead of writing confusing raw values like:

```ts
let move = 0;   // What does 0 mean?
```

You write:

```ts
let move = Direction.Up;
```

Now your code becomes:

* Readable
* Self-explanatory
* Safer
* Structured

---

## Why Enums Are Needed

Without enums:

```ts
if (status === 1) { ... }
```

Nobody knows what 1 represents.

With enums:

```ts
if (status === Status.Active) { ... }
```

Now the meaning is clear.

This is the real purpose of enums:

> Replace magic values with meaningful names.

---

# Types of Enums in TypeScript

There are 3 main types:

1. Numeric Enums
2. String Enums
3. Heterogeneous Enums

---

# 1. Numeric Enums

Numeric enums store numeric values.

---

## 1.1 Default Numeric Enum

By default, numbering starts from 0.

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move: Direction = Direction.Up;
console.log(move);
```

### Output

```
0
```

### How it works internally

```
Up    -> 0
Down  -> 1
Left  -> 2
Right -> 3
```

Auto-increment happens automatically.

---

## 1.2 Initialized Numeric Enum

You can define starting value.

```ts
enum Direction {
  Up = 1,
  Down,
  Left,
  Right
}

console.log(Direction.Up);
console.log(Direction.Down);
```

### Output

```
1
2
```

Explanation:

* Up = 1
* Down becomes 2
* Left becomes 3

---

## 1.3 Fully Initialized Numeric Enum

You manually set all values.

```ts
enum Direction {
  Up = 1,
  Down = 3,
  Left = 5,
  Right = 7
}

console.log(Direction.Left);
```

### Output

```
5
```

Here, each member has its own independent value.

---

# 2. String Enums

String enums store meaningful text instead of numbers.

```ts
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT"
}

let move: Direction = Direction.Up;
console.log(move);
```

### Output

```
UP
```

### Why String Enums?

* More readable logs
* Better debugging
* Clear representation

Use when values must be meaningful to humans.

---

# 3. Heterogeneous Enums

Mix of numbers and strings.

```ts
enum Status {
  Active = 1,
  Inactive = "INACTIVE",
  Pending = 2,
  Cancelled = "CANCELLED"
}

console.log(Status.Active);
console.log(Status.Cancelled);
```

### Output

```
1
CANCELLED
```

‚ö†Ô∏è Not recommended because:

* Reduces consistency
* Confusing to maintain

---

# Enum vs Normal Variables

### Normal

```ts
let status = 1;
```

### Enum

```ts
enum Status {
  Active,
  Inactive
}

let currentStatus = Status.Active;
```

Enum makes meaning clear.

---

# Real-World Use Case

## Example: User Role System

```ts
enum UserRole {
  Admin,
  Editor,
  Viewer
}

function checkAccess(role: UserRole) {
  if (role === UserRole.Admin) {
    console.log("Full Access");
  }
}

checkAccess(UserRole.Admin);
```

Here enum ensures only valid roles are used.

---

# Where Enums Are Commonly Used

* User roles
* Order status
* Payment types
* API states
* Direction system
* System modes

---

# Reverse Mapping (Numeric Only)

Numeric enums support reverse mapping.

```ts
enum Status {
  Active,
  Inactive
}

console.log(Status[0]); // Active
```

String enums do not support this.

---

# Best Practices

‚úÖ Prefer string enums for readability
‚úÖ Use numeric enums when performance matters
‚ùå Avoid heterogeneous enums
‚úÖ Use enums for related constants

---

# Common Mistakes

| Mistake                    | Why Bad                |
| -------------------------- | ---------------------- |
| Using plain numbers        | Unclear logic          |
| Mixing enum types          | Inconsistent behaviour |
| Not using enums for states | Harder to maintain     |

---

# Quick Practice

Try this:

```ts
enum PaymentStatus {
  Pending = "PENDING",
  Completed = "COMPLETED",
  Failed = "FAILED"
}

let status: PaymentStatus = PaymentStatus.Pending;
console.log(status);
```

Then try:

```ts
status = "DONE"; // ‚ùå Error
```

Observe how TS blocks invalid values.

---

# Summary

* What Enums are
* Why they exist
* Types of enums
* Numeric vs String vs Mixed
* Real-world usage
* Best practices

---

# 07. TS Literal Types

---

## Concept

**Literal Types allow a variable to accept ONLY exact, predefined values ‚Äî not just a general type.**

Normal type:

```ts
let direction: string;
direction = "Up";
direction = "Forward"; // ‚úÖ Allowed by string type
```

Literal type:

```ts
let direction: "Up" | "Down";
direction = "Up";       // ‚úÖ
direction = "Forward";  // ‚ùå Error
```

So the idea is:

> Literal Types = Strict control over allowed values.

---

## Why Literal Types Exist

They:

* Prevent invalid values
* Make code predictable
* Act like controlled enums
* Improve reliability

Useful when:

* Status values
* Fixed options
* Mode-based logic
* API response states

---

# Types of Literal Types

There are 3 main literal types:

1. String Literal Types
2. Numeric Literal Types
3. Boolean Literal Types

---

# 1. String Literal Types

These restrict a variable to specific string values.

### Example

```ts
type Direction = "Up" | "Down" | "Left" | "Right";

let move: Direction;

move = "Up";        // ‚úÖ Allowed
// move = "Forward"; // ‚ùå Error
```

### Explanation

* `Direction` can only be:

  * "Up"
  * "Down"
  * "Left"
  * "Right"
* Any other string is rejected at compile time.

### Why Useful

Instead of:

```ts
move = "forward"; // typo risk
```

You guarantee correctness automatically.

---

# 2. Numeric Literal Types

Restrict numbers to specific values.

### Example

```ts
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): DiceRoll {
  return 4;   // ‚úÖ Valid
  // return 7; // ‚ùå Error
}

console.log(rollDice());
```

### Explanation

* Only numbers 1 to 6 allowed
* Perfect for:

  * Rating systems
  * Levels
  * Game logic

---

# 3. Boolean Literal Types

Restrict to exact boolean value.

### Example

```ts
type Success = true;

function operation(): Success {
  return true;   // ‚úÖ
  // return false; // ‚ùå Error
}

console.log(operation());
```

### Use Case

Useful in:

* Strict flags
* Feature toggles
* Rule enforcement

---

# Literal Types vs Normal Types

| Feature | Normal Type  | Literal Type          |
| ------- | ------------ | --------------------- |
| string  | Any string   | Only specific strings |
| number  | Any number   | Specific numbers only |
| boolean | true / false | Exact true or false   |

---

# Real-World Example

## API Response Status

Without literal types:

```ts
let status: string;
status = "succcess"; // Typo, but allowed
```

With literal types:

```ts
type Status = "success" | "error" | "loading";

let apiStatus: Status;
apiStatus = "success";  // ‚úÖ
apiStatus = "fail";     // ‚ùå
```

Now your API state is 100% safe.

---

# Literal Types with Functions

```ts
type Mode = "light" | "dark";

function setTheme(theme: Mode) {
  console.log(`Theme set to ${theme}`);
}

setTheme("dark");    // ‚úÖ
// setTheme("blue"); // ‚ùå
```

---

# Literal Types vs Enums

| Literal Types          | Enums                |
| ---------------------- | -------------------- |
| Simple & lightweight   | Structured constants |
| Inline type definition | Named group          |
| Used mostly in union   | Used as object-like  |

‚úÖ Literal types are often preferred for lightweight constraints.

---

# Best Practices

‚úÖ Use literal types for fixed values
‚úÖ Combine with union types
‚úÖ Ideal for mode/settings parameters
‚ùå Avoid when Í∞í changes dynamically

---

# Common Mistakes

| Mistake                         | Problem               |
| ------------------------------- | --------------------- |
| Using string instead of literal | Allows invalid values |
| Not restricting inputs          | Logical bugs          |
| Overusing literal types         | Makes code rigid      |

---

# Practice Task

Try this:

```ts
type OrderStatus = "pending" | "shipped" | "delivered";

let status: OrderStatus;
status = "pending";     // ‚úÖ
// status = "cancelled"; // ‚ùå

console.log(status);
```

Now try passing wrong values and see TypeScript block it.

---

# Summary

* What Literal Types are
* Why they exist
* String, Number & Boolean Literal Types
* Real-world use cases
* Differences from enums
* Best practices

---

# 08. TS Union & Intersection Types

---

## 1. Core Concept

### Union Type ( | )

A union type means:

> A value can be ANY ONE of multiple types.

### Intersection Type ( & )

An intersection type means:

> A value must satisfy ALL types at the same time.

This is the key mental model.

```
Union  = OR logic
Intersection = AND logic
```

---

# 2. Union Types

## Definition

Union type allows a variable to hold multiple possible types.

### Syntax

```ts
type MyType = Type1 | Type2;
```

### Example

```ts
type Animal = "Dog" | "Cat" | "Bird";

let pet: Animal;

pet = "Dog";   // ‚úÖ
pet = "Cat";   // ‚úÖ
// pet = "Lion"; // ‚ùå Error
```

Here `pet` can be:

* Dog OR Cat OR Bird
  But nothing else.

### Another Example (Real data types)

```ts
let id: number | string;

id = 101;      // ‚úÖ
id = "A101";   // ‚úÖ
```

---

## When to use Union

Use union when:

* Input can have different shapes
* Multiple valid types exist
* API responses vary

---

# 3. Intersection Types

## Definition

Intersection types combine multiple types into one.

### Syntax

```ts
type Combined = Type1 & Type2;
```

### Example

```ts
type Person = { name: string } & { age: number };

let user: Person = {
  name: "Tanish",
  age: 21
};
```

Here:

* user MUST contain both:

  * name
  * age

Missing any will cause error.

---

## When to use Intersection

Use intersection when:

* You want to merge multiple type requirements
* Object should satisfy all structures

---

# Union vs Intersection (Clear Comparison)

| Feature  | Union                    | Intersection       |     |
| -------- | ------------------------ | ------------------ | --- |
| Meaning  | Either one               | All of them        |     |
| Operator | `                        | `                  | `&` |
| Logic    | OR                       | AND                |     |
| Use case | Multiple possible shapes | Combined structure |     |

---

# 4. Simple Visual Intuition

### Union

```
A OR B
```

Allowed:

* Only A
* Only B

### Intersection

```
A AND B
```

Allowed:

* Must satisfy BOTH A and B

---

# 5. Transforming Union ‚Üí Intersection (Advanced Concept)

Sometimes you want:

Union:

```ts
type U = { a: number } | { b: string } | { c: boolean };
```

Into Intersection:

```ts
type I = { a: number } & { b: string } & { c: boolean };
```

So final type must contain:

```
a + b + c
```

---

# 6. Why We Convert Union to Intersection

Because union is flexible but sometimes too loose.

We want:

* Combine configuration objects
* Merge feature requirements
* Ensure complete data structure

---

# 7. Distributive Conditional Type Method

This is the clean professional solution.

### Core Utility Type

```ts
type UnionToIntersection<U> =
  (U extends any ? (k: U) => void : never) extends
  (k: infer I) => void ? I : never;
```

Now example.

```ts
type UnionType =
  { a: number } |
  { b: string } |
  { c: boolean };

type IntersectionType = UnionToIntersection<UnionType>;

const obj: IntersectionType = {
  a: 42,
  b: "hello",
  c: true
};

console.log(obj);
```

‚úÖ All properties must exist
‚úÖ Now behaves like merged object

---

# 8. Understanding This Conversion Conceptually

### Union

```ts
{ a } OR { b } OR { c }
```

### Intersection Result

```ts
{ a } AND { b } AND { c }
```

So the output type becomes:

```
{ a, b, c }
```

---

# 9. Real World Scenario

Imagine API features:

```ts
type Auth = { token: string };
type Profile = { username: string };
type Preferences = { theme: string };

type UserData = Auth & Profile & Preferences;
```

Now UserData MUST contain all three modules.

---

# 10. Simple Practical Example

```ts
type A = { x: number };
type B = { y: string };

type UnionExample = A | B;
type IntersectionExample = A & B;

const obj1: UnionExample = { x: 10 }; // ‚úÖ
const obj2: IntersectionExample = {
  x: 10,
  y: "Hello"
}; // ‚úÖ
```

---

# 11. Why Not Always Use Intersection?

Because intersection forces strict requirements:

* More properties required
* Less flexible input

So use it only when completeness is needed.

---

# 12. Best Practices

‚úÖ Use union for flexible inputs
‚úÖ Use intersection for strict structure
‚úÖ Convert union to intersection for data merging
‚úÖ Avoid overcomplicated type logic in beginners phase

---

# Practice Task

Try this:

```ts
type A = { id: number };
type B = { name: string };

type Result = A & B;

const user: Result = {
  id: 1,
  name: "Tanish"
};

console.log(user);
```

Now remove one property and see the error.

---

# Summary

* What Union Types are
* What Intersection Types are
* Difference between them
* OR vs AND logic
* How to convert Union ‚Üí Intersection
* When and why to use it

---

# TS Type Aliases

---

## Concept

A **Type Alias** is simply a new name given to an existing type.

Important truth:

> Type Alias DOES NOT create a new type, it only gives another readable name to an existing type structure.

Think of it like:

```
Nickname for a type
```

---

## Why Type Aliases Exist

They help you:

* Avoid repeating complex types
* Improve readability
* Centralise type definitions
* Simplify maintenance
* Make code self-documenting

---

## Basic Syntax

```ts
type AliasName = TypeDefinition;
```

Example:

```ts
type MyType = number | string;
```

Now you can reuse:

```ts
let value: MyType;
```

---

# 1. Simple Type Alias with Union

### Example

```ts
type type_alias = number | string | boolean;

let variable: type_alias;

variable = 1;
console.log(variable);

variable = "geeksforgeeks";
console.log(variable);

variable = true;
console.log(variable);

// variable = function() {}; // ‚ùå Error
```

### Explanation

* `type_alias` allows only:

  * number
  * string
  * boolean
* Anything else is rejected.

This enforces correctness at compile time.

---

## Why This Is Powerful

Instead of writing this everywhere:

```ts
let x: number | string | boolean;
```

You write:

```ts
type ValueType = number | string | boolean;
let x: ValueType;
```

Cleaner, reusable, maintainable.

---

# 2. Type Alias in Functions

### Example

```ts
type anotherType = number | string;

function displayId(id: anotherType) {
  return "My ID is: " + id;
}

console.log(displayId("AF565"));
console.log(displayId(565));
```

### Explanation

* Function now accepts:

  * number OR string
* Any other input type ‚Üí compile-time error

This makes API contracts strict and predictable.

---

# 3. Literal Types as Type Alias

This is where type aliases become extremely powerful.

### Example

```ts
type Answer = "yes" | "no";

let response: Answer;

response = "yes";     // ‚úÖ Allowed
// response = "neither"; // ‚ùå Error
```

This creates **controlled string input**, perfect for:

* User choices
* System modes
* Flags

---

# Alias vs Direct Type

### Without Alias (Messy)

```ts
function process(input: string | number | boolean) {}
```

### With Alias (Clean)

```ts
type InputType = string | number | boolean;
function process(input: InputType) {}
```

‚úÖ Cleaner
‚úÖ More readable
‚úÖ Centralised

---

# Type Alias with Objects

```ts
type User = {
  name: string;
  age: number;
};

let person: User = {
  name: "Tanish",
  age: 21
};
```

Now `User` can be reused anywhere.

---

# Type Alias with Arrays

```ts
type Marks = number[];

let scores: Marks = [90, 85, 78];
```

---

# Type Alias with Functions

```ts
type SumFunction = (a: number, b: number) => number;

const add: SumFunction = (x, y) => {
  return x + y;
};
```

Now function signature is reusable.

---

# Type Alias vs Interface (Conceptual Difference)

| Type Alias             | Interface     |              |
| ---------------------- | ------------- | ------------ |
| Can alias primitives   | ‚úÖ             | ‚ùå            |
| Supports unions        | ‚úÖ             | ‚ùå            |
| Supports intersections | ‚úÖ             | ‚ùå            |
| Extensible             | Limited       | Better       |
| Ideal for              | Types, unions | Object shape |

üëâ Rule of thumb:

* Use **type** for flexibility
* Use **interface** for object structure

---

# Real-World Example

```ts
type UserID = string | number;

type User = {
  id: UserID;
  name: string;
  isActive: boolean;
};

const user: User = {
  id: 101,
  name: "Tanish",
  isActive: true
};
```

This creates a clean type system blueprint.

---

# Common Mistakes

| Mistake                     | Why Wrong               |
| --------------------------- | ----------------------- |
| Overusing primitive aliases | Adds confusion          |
| Not reusing aliases         | Reduces maintainability |
| Mixing inconsistent naming  | Poor readability        |

---

# Best Practices

‚úÖ Use PascalCase for alias names
‚úÖ Create aliases for shared logic
‚úÖ Avoid duplicating complex types
‚úÖ Name meaningfully

Example:

```ts
type UserRole = "admin" | "user" | "guest";
```

---

# Practice Task

Try this:

```ts
type Status = "active" | "inactive";

type User = {
  name: string;
  status: Status;
};

let user: User = {
  name: "Tanish",
  status: "active"
};

console.log(user);
```

Try changing status to invalid value and observe error.

---

# Summary

* What Type Alias is
* Why we use it
* How to create it
* Alias with:

  * Primitives
  * Unions
  * Literals
  * Functions
  * Objects
* Alias vs Interface

---