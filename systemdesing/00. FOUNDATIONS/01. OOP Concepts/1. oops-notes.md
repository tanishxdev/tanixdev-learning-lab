# OOPs Concepts

âš¡ OOP is about designing a system as a collection of objects each with its own data (state) and methods (behaviors) that interact to solve problems.

**It has 4 main pillars:**

- Encapsulation â†’ wrapping data & methods together, hiding details.

- Abstraction â†’ showing only essential features, hiding complexity.

- Inheritance â†’ child classes reuse/extend parent class features.

- Polymorphism â†’ same function behaves differently (compile-time & runtime).

##  Class and Object

### 1. What is a Class?

A **class** is a **blueprint** or **template** for creating objects. Think of it like a blueprint for a car â€” the blueprint defines what a car **has** (attributes like color, model) and what a car **can do** (functions like startEngine, honk).

* **Attributes/Properties/Data/State**: What an can object holds (e.g., brand, model in a Car class).
* **Methods/Action/Behaviors**: Actions an object can perform (e.g., startEngine(), accelerate()).

---
Example code:
```cpp
class Student {
public:
    int roll;
    string name;

    void takeLeave() {
        cout << "on leave" << endl;
    }

    void bunkClass() {
        cout << "Go out and play: " << endl;
    }
};
```

* `Student` â†’ name of the class.
* `roll` and `name` â†’ **attributes** (data members) of a student.
* `takeLeave()` and `bunkClass()` â†’ **methods** (functions) that describe actions a student can perform.
* `public:` â†’ **access specifier**, means these members can be used **outside the class**.

---

### 2. What is an Object?

An **object** is a **real instance** of a class. If class is the blueprint, the object is the actual â€œthingâ€ made from that blueprint.

```cpp
Student sid;
```

* `sid` is an **object of Student**.
* Each object has its **own copy** of `roll`, `name`, and can use `takeLeave()` or `bunkClass()`.

---

### 3. Accessing Data Members and Methods

Once you have an object, you can access its attributes or methods using the **dot operator (`.`)**:

```cpp
sid.bunkClass(); // Calls the method
sid.name = "Siddhartha Hazra"; // Sets the name
cout << sid.name << endl; // Prints the name
```

**Step by step execution:**

1. `sid.bunkClass();` â†’ prints `Go out and play:`
2. `sid.name = "Siddhartha Hazra";` â†’ assigns a value to the `name` attribute.
3. `cout << sid.name;` â†’ prints `Siddhartha Hazra`.

---

### 4. How it all works together

```
Class: Student (Blueprint)
--------------------------------
Attributes: roll, name
Methods: takeLeave(), bunkClass()

Object: sid
--------------------------------
sid.roll -> empty (not assigned)
sid.name -> "Siddhartha Hazra"
sid.takeLeave() -> prints "on leave"
sid.bunkClass() -> prints "Go out and play:"
```

Think of it like:

| Blueprint       | Object          |
| --------------- | --------------- |
| Student class   | sid             |
| has roll        | sid.roll        |
| has name        | sid.name        |
| can takeLeave() | sid.takeLeave() |
| can bunkClass() | sid.bunkClass() |

---

### 5. Key Concepts from this example

1. **Class** = template / blueprint
2. **Object** = real instance of class
3. **Data members** = variables inside class
4. **Member functions** = functions inside class
5. **Access specifier `public:`** = can access from outside
6. **Dot operator (`.`)** = used to access objectâ€™s attributes and methods


## Encapsulation
### 1ï¸âƒ£ What is Encapsulation?

Encapsulation = **binding data + methods together inside a class** + **restricting direct access** to data for safety.

* Data members are usually kept **private**.
* You expose only **controlled access** via **getter (read)** and **setter (write)** methods.

Think of it like a **capsule**: the medicine (data) is hidden inside, and you can only access it in a controlled way.

---

### 2ï¸âƒ£ Code Breakdown

### Class Definition

```cpp
class Employee {
private:
    int id;
    std::string name;
```

* `private:` â†’ Members cannot be accessed **directly** outside the class.
  Example: `emp.id = 5;` âŒ (not allowed).
* `id` and `name` are **data members**.

---

### Setter Methods

```cpp
public:
    void setId(int id) {
        this->id = id;
    }

    void setName(std::string name) {
        this->name = name;
    }
```

* **Setter** methods allow us to **assign values** to private data.
* `this->id = id;` â†’ Here `this` is a pointer to the current object. It helps distinguish between **class variable** (`this->id`) and **function parameter** (`id`).

---

### Getter Methods

```cpp
    int getId() {
        return id;
    }

    std::string getName() {
        return name;
    }
```

* **Getter** methods allow us to **retrieve values** of private data.
* Instead of directly accessing `emp.id`, we call `emp.getId()`.

---

### Main Function

```cpp
int main() {
    Employee emp;

    // Using setters
    emp.setId(101);
    emp.setName("Geek");

    // Using getters
    std::cout << "Employee ID: " << emp.getId() << std::endl;
    std::cout << "Employee Name: " << emp.getName() << std::endl;

    return 0;
}
```

Execution Flow:

1. Object `emp` is created.
2. `emp.setId(101);` â†’ stores `101` in private `id`.
3. `emp.setName("Geek");` â†’ stores `"Geek"` in private `name`.
4. `emp.getId();` â†’ fetches `101`.
5. `emp.getName();` â†’ fetches `"Geek"`.
   Output:

```
Employee ID: 101
Employee Name: Geek
```

---

### 3ï¸âƒ£ Why use Getters and Setters?

ğŸ‘‰ Without encapsulation:

```cpp
emp.id = -999;   // âŒ anyone can assign invalid values
```

ğŸ‘‰ With encapsulation:

```cpp
emp.setId(-999);  // âœ… you can add checks inside setter to block invalid values
```

Example:

```cpp
void setId(int id) {
    if (id > 0) {
        this->id = id;
    } else {
        std::cout << "Invalid ID!" << std::endl;
    }
}
```

Now, `emp.setId(-999);` will print `"Invalid ID!"` instead of silently assigning.

---

### 4ï¸âƒ£ Key Takeaways

* **Private** members â†’ secure data, no direct outside access.
* **Setters** â†’ assign values safely.
* **Getters** â†’ read values safely.
* **Encapsulation** = data hiding + controlled access.
* `this->` keyword â†’ refers to the current object, used to avoid name conflicts.

---

## Abstraction

### 1ï¸âƒ£ What is Abstraction?

ğŸ‘‰ **Abstraction** = showing **only the essential details** and hiding **complex internal logic**.

* For example, when you **drive a car**, you know:

  * Turn the key â†’ engine starts
  * Press gas pedal â†’ car accelerates
  * Press brake â†’ car slows down

But you **donâ€™t need to know** the **internal mechanics** (fuel injection, hydraulics, etc.).

Thatâ€™s exactly what your code does!

---

### 2ï¸âƒ£ Abstract Class in C++

```cpp
class Vehicle {
public:
    // Pure virtual functions
    virtual void accelerate() = 0;
    virtual void brake() = 0;

    // Concrete method
    void startEngine() {
        std::cout << "Engine started!" << std::endl;
    }
};
```

* `class Vehicle` â†’ Abstract class (because it has at least one pure virtual function).
* `virtual void accelerate() = 0;` â†’ Pure virtual function (must be implemented by derived classes).
* `virtual void brake() = 0;` â†’ Same as above.
* `startEngine()` â†’ Normal function with actual implementation (can be reused by derived classes).

ğŸ‘‰ You **cannot create an object of Vehicle directly**, only a pointer/reference to it.


---

### âš¡ Abstract Class in C++


### What does *Abstract* mean?

* **Abstract = Not complete**
* In C++ â†’ A class is **abstract** if it has at least **one pure virtual function** (`=0`).
* Abstract classes act like **blueprints**.
* They define **what should be done**, but not **how**.

ğŸ‘‰ Think: "Abstract = Idea only, no full implementation."

---

### 1. Why canâ€™t we create an object of `Vehicle`?

* Because `Vehicle` has **pure virtual functions** (`accelerate()`, `brake()`).
* These functions **donâ€™t have any body/implementation** in `Vehicle`.
* If you tried to create an object, C++ wouldnâ€™t know **how to run accelerate() or brake()** â†’ incomplete!
* But, we **can create a pointer/reference** to `Vehicle` â†’ so that it can point to a **child class object** which provides the missing details.

---

### 2. Why does `class Vehicle` become abstract?

* Rule in C++:
  If a class has **â‰¥ 1 pure virtual function**, it is **abstract**.
* Pure virtual function syntax:

  ```cpp
  virtual void functionName() = 0;
  ```
* This forces **all child classes** to **override and implement** those functions.


### Example

```cpp
class Vehicle {
public:
    virtual void accelerate() = 0; // Pure virtual
    virtual void brake() = 0;      // Pure virtual

    void startEngine() {           // Concrete function
        cout << "Engine started!" << endl;
    }
};

class Car : public Vehicle {
public:
    void accelerate() override {
        cout << "Car accelerating" << endl;
    }
    void brake() override {
        cout << "Car braking" << endl;
    }
};

int main() {
    // Vehicle v; âŒ Not allowed (abstract class)

    Vehicle* v = new Car(); // âœ… Pointer to abstract class
    v->startEngine();
    v->accelerate();
    v->brake();
    delete v;
}
```

---

### Real-life Analogy

* `Vehicle` = **blueprint** (idea) â†’ "Every vehicle must accelerate and brake."
* `Car`, `Bike` = **real things** (implementation).
* You cannot use the **blueprint** directly â†’ you must build a real car/bike first.

---

âœ… **Abstract Class Summary:**

* Abstract = incomplete class (has pure virtual function).
* Cannot create object of it.
* Used as a **base/blueprint** for other classes.
* Child classes must implement missing details.

---

### âš¡ `virtual void anything()` in C++
---

This means:

1. **`void`** â†’ return type (the function doesnâ€™t return anything).
2. **`anything()`** â†’ function name (could be `bark()`, `draw()`, `accelerate()`, etc.).
3. **`virtual`** â†’ keyword that makes this function **overridable in derived (child) classes**.

---

### Why `virtual`?

Normally in C++, **function calls are resolved at compile time** (called *compile-time binding*).
But with `virtual`, function calls are resolved at **runtime** (called *runtime polymorphism*).

ğŸ‘‰ In simple words:

* Without `virtual` â†’ parent function always runs, even if child overrides it.
* With `virtual` â†’ If child has its own way, listen to the child.

---

### Example: Without `virtual`

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void sound() {  // not virtual
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() {
        cout << "Dog barks" << endl;
    }
};

int main() {
    Animal* a = new Dog();
    a->sound();  // Output: Animal makes a sound âŒ (parent version runs)
    delete a;
}
```

---

### Example: With `virtual`

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() {   // now virtual
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {   // child overrides
        cout << "Dog barks" << endl;
    }
};

int main() {
    Animal* a = new Dog();
    a->sound();  // Output: Dog barks âœ… (child version runs)
    delete a;
}
```

---

### Real-life analogy

Think of `virtual` as saying:
ğŸ‘‰ â€œHey, parent class is just a blueprint.
If a child provides its own version, **use that instead at runtime**.â€


âœ… So,
`virtual void anything();` â†’ means â€œthis function can be overridden in child classes, and when called via a parent pointer/reference, **the childâ€™s version will run**.â€

---

### 3ï¸âƒ£ Concrete Class

```cpp
class Car : public Vehicle {
public:
    void accelerate() override {
        std::cout << "Car: Pressing gas pedal..." << std::endl;
    }

    void brake() override {
        std::cout << "Car: Applying brakes..." << std::endl;
    }
};
```

* `Car` inherits from `Vehicle`.
* Since `Car` provides definitions for `accelerate()` and `brake()`, it becomes a **concrete class** (can be instantiated).
* `override` â†’ helps the compiler check that youâ€™re actually overriding a base class function.

---

### 4ï¸âƒ£ Polymorphism in Action

```cpp
int main() {
    Vehicle* myCar = new Car();  // Base class pointer, derived class object
    myCar->startEngine();        // Uses Vehicle's implementation
    myCar->accelerate();         // Calls Car's version
    myCar->brake();              // Calls Car's version
    delete myCar;
    return 0;
}
```

* `Vehicle* myCar = new Car();`
  â†’ Base class pointer pointing to derived class object.
  This is **runtime polymorphism** (decides which function to call at runtime).

* `myCar->accelerate();`
  Even though `myCar` is a `Vehicle*`, it executes **Carâ€™s accelerate()** because of **virtual functions**.

---

### 5ï¸âƒ£ Output of the Program

```
Engine started!
Car: Pressing gas pedal...
Car: Applying brakes...
```

---

### 6ï¸âƒ£ Key Concepts Learned Here

1. **Abstraction** â†’ Hide complex implementation, expose only necessary methods.
2. **Abstract Class** â†’ A class with pure virtual functions. Cannot create objects of it.
3. **Pure Virtual Function** (`= 0`) â†’ Must be implemented by derived classes.
4. **Polymorphism** â†’ Base class pointer can call derived class functions at runtime.
5. **Virtual Functions** â†’ Enable runtime polymorphism (without them, it would call the base class version).

---

âœ… In short:
This example is about **Abstraction (hiding details)** + **Polymorphism (runtime decision of which method to run)**.

---

## Inheritance

### 1ï¸âƒ£ What is Inheritance?

ğŸ‘‰ **Inheritance** = one class (child) reuses the properties and behaviors of another class (parent).

It helps us **avoid code duplication** and supports the idea of **reusability**.

Think of it like:

* Parent = *Animal* (has basic behaviors: eat, sleep)
* Child = *Dog* (inherits all basic behaviors from Animal + adds its own: bark)

---

### 2ï¸âƒ£ Code Breakdown

### Superclass (Parent)

```cpp
class Animal {
public:
    void eat() {
        std::cout << "Animal is eating..." << std::endl;
    }

    void sleep() {
        std::cout << "Animal is sleeping..." << std::endl;
    }
};
```

* `Animal` class defines **common behaviors**: `eat()` and `sleep()`.
* These are **public methods**, so any subclass can use them.

---

### Subclass (Child)

```cpp
class Dog : public Animal {
public:
    void bark() {
        std::cout << "Dog is barking!" << std::endl;
    }
};
```

* `class Dog : public Animal` â†’ Dog **inherits publicly** from Animal.
* This means:

  * Dog **automatically gets** `eat()` and `sleep()` from Animal.
  * Dog also adds its own behavior: `bark()`.

---

### Main Function

```cpp
int main() {
    Dog myDog;

    // Inherited methods (from Animal)
    myDog.eat();
    myDog.sleep();

    // Child class method
    myDog.bark();
    return 0;
}
```

* `myDog.eat();` â†’ Dog object is able to use `eat()` because it inherited from Animal.
* `myDog.sleep();` â†’ Same reason.
* `myDog.bark();` â†’ Dogâ€™s own method.

---

### 3ï¸âƒ£ Output

```
Animal is eating...
Animal is sleeping...
Dog is barking!
```

---

### 4ï¸âƒ£ Key Concepts from this Example

1. **Superclass (Parent)** â†’ `Animal`
2. **Subclass (Child)** â†’ `Dog`
3. **Inheritance** â†’ Dog inherits all public methods of Animal.
4. **Reusability** â†’ No need to redefine `eat()` and `sleep()` inside Dog.
5. **Extendability** â†’ Dog adds its own extra method `bark()`.

---

### 5ï¸âƒ£ Types of Inheritance in C++

C++ supports multiple forms of inheritance:

* **Single Inheritance** (your example: Dog â† Animal)
* **Multilevel Inheritance** (e.g., Puppy â† Dog â† Animal)
* **Multiple Inheritance** (a class can inherit from multiple parents)
* **Hierarchical Inheritance** (multiple children inherit from one parent)
* **Hybrid Inheritance** (combination of above)

---

âœ… In short:
This is an example of **Single Inheritance** â€” Dog inherits from Animal and reuses its methods while adding new ones.

## Polymorphism

ğŸ‘‰ **Polymorphism** = *"One name, many forms"*.
It allows the same function (or operator) to behave **differently** depending on the context.

In C++, there are **two types** of polymorphism:

1. **Compile-time Polymorphism** (also called *Static Binding / Early Binding*)

   * Achieved using **function overloading** and **operator overloading**.
        * Function Overloading (same function name, different parameters).
        * Operator Overloading (+, -, etc. used in custom ways).
        * Example 
        ```cpp
        class Math {
        public:
            int add(int a, int b) { return a + b; }
            double add(double a, double b) { return a + b; }
        };

        Math m;
        cout << m.add(2, 3);      // Uses int version
        cout << m.add(2.5, 3.5);  // Uses double version

        ```
        ğŸ‘‰ The compiler already knows which function to call before running.
   * Decision happens **at compile time**.

2. **Run-time Polymorphism** (also called *Dynamic Binding / Late Binding*)

   * Achieved using **virtual functions** (via inheritance).
        * Example 
        ```cpp
        class Animal {
        public:
            virtual void sound() { cout << "Animal sound" << endl; }
        };

        class Dog : public Animal {
        public:
            void sound() override { cout << "Dog barks" << endl; }
        };

        Animal* a = new Dog();
        a->sound();  // Decided at runtime â†’ Dog barks
 
        ``` 
        ğŸ‘‰ Here, program decides at runtime which version (parentâ€™s or childâ€™s) to run.
   * Decision happens **at runtime**.

---

### 1ï¸âƒ£ Compile-Time Polymorphism (Function Overloading)

```cpp
#include <iostream>
using namespace std;

class Math {
public:
    // Same function name, different parameters
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
};

int main() {
    Math obj;
    cout << obj.add(2, 3) << endl;         // calls add(int, int)
    cout << obj.add(2.5, 3.5) << endl;     // calls add(double, double)
    cout << obj.add(1, 2, 3) << endl;      // calls add(int, int, int)
    return 0;
}
```

### Output:

```
5
6
6
```

âœ… Same function name `add()` behaves differently depending on arguments.

---

### 2ï¸âƒ£ Run-Time Polymorphism (Virtual Functions)

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() {   // virtual function
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {  // overriding base class function
        cout << "Dog barks" << endl;
    }
};

class Cat : public Animal {
public:
    void sound() override {
        cout << "Cat meows" << endl;
    }
};

int main() {
    Animal* a1 = new Dog();  // Base class pointer â†’ Dog object
    Animal* a2 = new Cat();  // Base class pointer â†’ Cat object

    a1->sound();  // calls Dog's sound()
    a2->sound();  // calls Cat's sound()

    delete a1;
    delete a2;
    return 0;
}
```

### Output:

```
Dog barks
Cat meows
```

âœ… Even though `a1` and `a2` are of type `Animal*`, at **runtime** the correct function (Dogâ€™s or Catâ€™s) is chosen.

This is **runtime polymorphism** using **virtual functions**.

---

* *Compile-time Polymorphism = Decision made before program runs (overloading).*
* *Run-time Polymorphism = Decision made while program runs (virtual functions).*

###  Summary Table

| Type                          | How?                                       | When Decided? | Example                              |
| ----------------------------- | ------------------------------------------ | ------------- | ------------------------------------ |
| **Compile-time Polymorphism** | Function Overloading, Operator Overloading | Compile Time  | `add(2,3)` vs `add(2.5,3.5)`         |
| **Run-time Polymorphism**     | Virtual Functions (Method Overriding)      | Runtime       | `Animal* a = new Dog(); a->sound();` |

---

ğŸ‘‰ So **Inheritance** gives us the relationship between parent & child classes, while **Polymorphism** makes those relationships powerful by allowing the *same method call to do different things*.


## **New and Delete**  C++.

### 1ï¸âƒ£ Object Creation in Different Ways

In C++ you can create objects in **two main ways**:

### (A) **Stack Allocation** (Automatic storage)

```cpp
Dog d;       // object on stack
d.sound();
```

* Object `d` is created on the **stack**.
* It is automatically destroyed when it goes **out of scope** (like when function ends).
* No need to call `delete`. âœ…

---

### (B) **Heap Allocation** (Dynamic storage)

```cpp
Dog* d = new Dog();   // object on heap
d->sound();
delete d;             // manual cleanup required â—
```

* `new Dog()` â†’ creates the object on the **heap**.
* Only a pointer (`d`) is on the stack.
* Object will **NOT** be destroyed automatically when scope ends.
* You must explicitly call `delete d;` to free memory.

ğŸ‘‰ If you donâ€™t call `delete`, that memory remains reserved â†’ this is called a **memory leak**.

---

### 2ï¸âƒ£ Why delete the object in your `main()` example?

In your polymorphism example:

```cpp
Animal* a1 = new Dog();
Animal* a2 = new Cat();

a1->sound();
a2->sound();

delete a1;
delete a2;
```

* You used `new` â†’ so the objects are on the heap.
* If you donâ€™t use `delete`, memory used by Dog and Cat objects will **not be freed** until program ends.
* For small programs, it may not look like a big issue, but in real systems (servers, games, apps) this can lead to **serious memory leaks**.

---

### 3ï¸âƒ£ What if I didnâ€™t use `new`?

If you write:

```cpp
Dog d;
Cat c;

Animal* a1 = &d;
Animal* a2 = &c;

a1->sound();
a2->sound();
```

ğŸ‘‰ Here objects are on **stack**, so when `main()` ends, `d` and `c` are automatically destroyed.
No need to `delete`.

But difference is:

* `new` â†’ you control object lifetime manually.
* Stack object â†’ lifetime tied to scope.

---

### 4ï¸âƒ£ Bonus: Virtual Destructor âš ï¸

When using polymorphism with `new` and `delete`, always make the base class destructor **virtual**, otherwise only the base class destructor is called (not the childâ€™s).

Example:

```cpp
class Animal {
public:
    virtual ~Animal() {   // âœ… virtual destructor
        cout << "Animal destroyed\n";
    }
};

class Dog : public Animal {
public:
    ~Dog() {
        cout << "Dog destroyed\n";
    }
};
```

Now:

```cpp
Animal* a = new Dog();
delete a;   // both Dog's and Animal's destructor will be called
```

If destructor wasnâ€™t `virtual`, `Dog`'s destructor would be skipped â†’ leading to resource leaks.

---

âœ… **Summary:**

* `delete` is needed only when you used `new`.
* Stack objects are auto-cleaned, heap objects must be manually freed.
* Always use **virtual destructors** in base classes when dealing with polymorphism + heap.
