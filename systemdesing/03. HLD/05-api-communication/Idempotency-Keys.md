# Idempotency Keys

![](https://substackcdn.com/image/fetch/$s_!IRfb!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F48613cc7-096d-4ba5-98f5-bf38c85b3201_1600x1150.png)
![](https://www.lewuathe.com/assets/img/posts/2019-04-30-idempotency-key-in-the-stripe-ruby-sdk/idempotent-request.png)
![](https://miro.medium.com/1*kLUTL3u7Dy0QylqYCoC9hQ.gif)
![](https://substackcdn.com/image/fetch/$s_!YCT1!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3beec9e-cd04-4748-ae7e-3299b42883f6_2360x2824.png)
![](https://eda-visuals.boyney.io/assets/visuals/eda/event-driven-migration.png)

Idempotency means:

**Calling the same API multiple times should produce the same result.
No duplicates. No double-processing. No double-charging.**

An **Idempotency Key** is a unique token sent by the client to ensure that
even if the request is retried, **the server processes it only once**.

Used heavily in:

* Payments (Stripe, Razorpay, PayPal)
* Orders (Amazon)
* Ticket booking
* Banking transactions
* OTP verification
* Any “this must never happen twice” operation

---

# 1. The Core Problem Idempotency Solves

Without idempotency:

* A retry may create **duplicate payment**
* A network glitch may submit the same form twice
* User double-click may create **two orders**
* API timeout may cause the client to retry → double processing

Example:
Client sends request → timeout → retries → server receives **two** requests.

Idempotency key ensures **only one succeeds**, others reuse the same result.

---

# 2. What is an Idempotency Key?

A **unique identifier** generated by the client for a request.

Example:

```
Idempotency-Key: 9f1c-44df-a23b-99877
```

Client sends:

```
POST /payments
Idempotency-Key: X123
```

Server stores:

```
(X123 → Result of this request)
```

If the same key comes again:

Server **returns the stored result**,
and does NOT repeat the operation.

---

# 3. How Idempotency Works (Step-by-Step)

### Step 1: Client generates unique key

Could be UUID, random string, timestamp-hash.

### Step 2: Client sends request with that key

```
POST /order
Idempotency-Key: abc-123
```

### Step 3: Server checks storage (cache/DB)

If key already seen:

* Return stored response
* Do NOT execute logic again

If key not seen:

* Process normally
* Save the result against the key
* Return response

### Step 4: Future retries return same response

This prevents:

* Duplicate writes
* Duplicate charges
* Race conditions
* Double-inserts

---

# 4. Why Do Systems Need Idempotency Keys?

### Scenario 1: Network Timeout

Client receives no response → retries
Without idempotency → server processes twice

### Scenario 2: User double-clicks

Two requests sent instantly → one must be ignored

### Scenario 3: Mobile request dies mid-flight

When resumed, client retries with same key → safe

### Scenario 4: Payment systems

Charging twice = dangerous → idempotency required

---

# 5. What Operations Should be Idempotent?

### Idempotent by nature

* GET
* PUT
* DELETE

### Not idempotent

* POST (create resource) → this is where idempotency keys matter
* PATCH

---

# 6. Idempotency Key Storage (Very Important)

Servers must store:

* Incoming idempotency key
* Request body hash (optional)
* Result (response JSON, status code)
* Timestamp

Storage options:

### 1. Redis (Best Choice)

* Fast
* TTL-based cleanup
* Supports atomic operations

### 2. Database Table

Simple structure:

```
idempotency_key | request_hash | response | status | timestamp
```

### 3. In-Memory Cache

Only works for single server → not good for distributed systems.

---

# 7. Request Hashing (Optional but Recommended)

To prevent misuse:

* Store a hash of the request body
* If same key used with a different request → reject

Prevents:

```
POST /order (idempotency-key: X)
Request1 → amount=100
Request2 → amount=200
```

Server should return:

```
409 Conflict – Different request for same idempotency key
```

---

# 8. Simple Example (Payments API)

### First request:

```
POST /pay
Amount: 500
Key: K123
```

Server:

* Charge card
* Save record: (K123 → Success)
* Return success

### Retry (network error):

```
Key: K123
```

Server:

* Does NOT charge card again
* Returns same success response instantly

---

# 9. Failure Cases Without Idempotency

* Two orders placed → duplicate packages
* Two tickets booked → overbooking
* Two payments → double charge
* Two messages → duplicate send

Idempotency keys prevent these disasters.

---

# 10. Key Differences from Traditional Retry Logic

| Aspect            | Retry Logic                      | Idempotency Key             |
| ----------------- | -------------------------------- | --------------------------- |
| Guarantee         | No guarantee of single execution | Guaranteed single execution |
| Duplicate work    | Possible                         | Prevented                   |
| Safe for payments | No                               | Yes                         |
| Scope             | Client-only                      | Server-enforced             |

---

# 11. Best Practices

### 1. Require idempotency keys for POST APIs

Especially money, booking, or resource creation.

### 2. Use Redis with TTL

Example: keep idempotency key for 24 hours.

### 3. Validate request body hash

Catch mismatched repeated requests.

### 4. Return same response on repeat

Do not regenerate new IDs or new responses.
Client expects identical result.

### 5. Keys should be client-generated

Not server-generated.

---

# 12. Interview-Ready Summary (30 seconds)

An idempotency key is a unique token sent by the client to ensure that a POST request is processed **only once**, even if it is retried due to network issues or user actions. The server stores the result of the first request and returns the same response for subsequent attempts with the same key. This prevents duplicate payments, orders, bookings, and other non-idempotent actions. Usually implemented using Redis or a DB with TTL-based cleanup.

---
