# Prototype Pattern — Why, When, and How

---

## 1. Problem — Why Do We Need Prototype?

In many systems, creating an object from scratch is **expensive** or **complex**.

Examples:

* Object has heavy configuration.
* Object loads large data from disk/network.
* Object requires deep setup (DB configs, UI themes, game characters, ML models, etc.).

### ❌ Traditional Approach

You create every new object using constructors:

```cpp
Car car1("BMW", "Black", 5000, true, true, true);
Car car2("BMW", "Black", 5000, true, true, true);
Car car3("BMW", "Black", 5000, true, true, true);
```

Problems:

* Repeating configuration logic
* High initialization cost
* Hard to modify structure later

### ✅ Desired Behaviour

> “Create new objects by copying an existing fully-configured object instead of building from scratch.”

This is exactly what **Prototype Pattern** solves.

---

## 2. Definition (Core Concept)

Prototype Pattern allows you to:

> Create new objects by cloning an existing object (prototype) rather than instantiating a new one using constructor.

It delegates object creation to the object itself via a `clone()` method.

---

## 3. Real-Life Analogy

Think of a **photocopy machine**:

* You create one original document.
* Then generate multiple copies from it.
* You don’t rewrite the document again.

Prototype works exactly like this.

---

## 4. When To Use Prototype

Use it when:

* Object creation is costly.
* Need many similar objects with minor changes.
* Want to decouple client from concrete class.
* Object state is complex and pre-configured.

---

## 5. Structure (UML Concept)

```
+----------------+
|   Prototype   |
+----------------+
| + clone()     |
+----------------+
        ^
        |
+---------------------+
| ConcretePrototype  |
+---------------------+
| data members       |
| clone() override   |
+---------------------+
```

Client never uses `new`. It uses `clone()`.

---

## 6. Without Prototype (Problem Example)

### ❌ Heavy Object Created Repeatedly

```cpp
#include <iostream>
using namespace std;

class GameCharacter {
public:
    string name;
    int health;
    int power;

    GameCharacter(string n, int h, int p) {
        cout << "Expensive character creation...\n";
        name = n;
        health = h;
        power = p;
    }

    void show() {
        cout << name << " | Health: " << health << " | Power: " << power << endl;
    }
};

int main() {
    GameCharacter c1("Warrior", 100, 50);
    GameCharacter c2("Warrior", 100, 50);
    GameCharacter c3("Warrior", 100, 50);

    c1.show();
    c2.show();
    c3.show();
}
```

### Problems:

* Constructor called 3 times
* Same configuration repeated
* Performance waste

---

## 7. With Prototype Pattern

### ✅ Correct Design Using clone()

```cpp
#include <iostream>
using namespace std;

/*
============================================================
PROTOTYPE BASE CLASS
Defines interface for cloning
============================================================
*/
class Prototype {
public:
    virtual Prototype* clone() = 0;
    virtual void show() = 0;
    virtual ~Prototype() {}
};

/*
============================================================
CONCRETE PROTOTYPE
Implements clone logic
============================================================
*/
class GameCharacter : public Prototype {
private:
    string name;
    int health;
    int power;

public:
    GameCharacter(string n, int h, int p) {
        cout << "Expensive character creation...\n";
        name = n;
        health = h;
        power = p;
    }

    // CLONE METHOD (Core of Prototype Pattern)
    Prototype* clone() override {
        return new GameCharacter(*this); // copy existing object
    }

    void show() override {
        cout << name << " | Health: " << health << " | Power: " << power << endl;
    }
};

int main() {

    // Create original object only once
    GameCharacter* original = new GameCharacter("Warrior", 100, 50);

    // Clone instead of creating new
    Prototype* c1 = original->clone();
    Prototype* c2 = original->clone();

    original->show();
    c1->show();
    c2->show();
}
```

---

## 8. Output Explanation

```
Expensive character creation...
Warrior | Health: 100 | Power: 50
Warrior | Health: 100 | Power: 50
Warrior | Health: 100 | Power: 50
```

✅ Notice:
Only ONE expensive creation
Other objects were efficient clones

---

## 9. Shallow vs Deep Copy (Important Interview Topic)

### Shallow Copy:

* Copies pointer references
* Shared memory

### Deep Copy:

* Duplicates actual data

In Prototype:

* Prefer **deep copy** if object owns dynamic memory.

---

## 10. Advantages

* Reduces heavy initialization cost
* Increases performance
* Cleaner object creation
* Flexible & extensible

---

## 11. Disadvantages

* Complex when deep copying required
* Hard when object has circular references
* Clone implementation must be carefully maintained

---

## 12. Real System Example Mapping

| Area             | Prototype Example                |
| ---------------- | -------------------------------- |
| Game Dev         | Cloning characters or enemies    |
| UI Frameworks    | Copying button templates         |
| Document Systems | Resume / Invoice duplication     |
| CAD Systems      | Copying design objects           |
| Analytics        | Replicating model configurations |

---

## 13. Quick Interview Summary

| Question               | Answer                                                              |
| ---------------------- | ------------------------------------------------------------------- |
| What is Prototype?     | Creational pattern that clones objects instead of creating new ones |
| Why use it?            | Avoids expensive object creation                                    |
| How is it implemented? | Using clone() method                                                |
| Key benefit?           | Performance and flexibility                                         |

---

## 14. Mental Model

Singleton = One shared object
Prototype = Many cloned objects

---

## 15. Compare with Singleton

| Aspect         | Singleton      | Prototype             |
| -------------- | -------------- | --------------------- |
| Instances      | Always one     | Multiple via cloning  |
| Creation Style | Restricted     | Replicated            |
| Main Purpose   | Global control | Efficient duplication |

---

## 16. When NOT To Use Prototype

Avoid when:

* Object is lightweight
* Clone logic is more expensive than creation
* No need for duplication

---

## 17. Final Takeaway

Prototype Pattern is ideal when:

* You want similar objects
* Object setup is costly
* You want performance + flexibility

---

## 18. Further Reading
- Deep Copy Prototype (with pointers)
- Prototype Registry Pattern