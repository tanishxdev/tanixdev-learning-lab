# 16.3 createSlice Deep Dive

---

# 1. Why createSlice?

### The core problem (before Redux Toolkit)

Classic Redux required:

* Action types
* Action creators
* Reducers with long switch-case statements
* Immutable update logic (manual)
* Boilerplate everywhere

Example of classic Redux:

```js
const initialState = { value: 0 };

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, value: state.value + 1 };
    default:
      return state;
  }
}
```

Problems:

* Too much repetitive code
* Hard to scale
* Error-prone
* Tedious immutable updates
* Splitting logic across multiple files
* Every dev/team wrote Redux differently

`createSlice` solves this with:

* A single file per feature
* Auto-generated action types
* Auto-generated action creators
* Reducers written in mutation style
* Clean, targeted, domain-specific state logic

---

# 2. What is createSlice?

`createSlice` is a Redux Toolkit function that creates:

* A slice of global state
* Reducers
* Immutable update logic using Immer
* Auto-generated action creators
* Auto-generated action type strings
* ExtraReducers for async logic

A slice bundles everything for one feature domain.

Example:

```js
const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value++;
    }
  }
});
```

---

# 3. When to use createSlice?

Use createSlice when:

* Managing state for a particular domain (auth, cart, todos, UI theme)
* You want a clean architecture
* You want autogenerated actions + reducers
* You want to use mutation-like syntax
* You want better scalability
* You want fewer files and less boilerplate

Do NOT use createSlice:

* For server state (React Query is better)
* For extremely small projects where global state is not needed
* When logic fits local component state better

---

# 4. Analogy

Think of a slice as a toolbox for a specific room in a house.

* “Kitchen Slice” → tools, rules, and items for the kitchen
* “Bedroom Slice” → different tools and rules
* “Living Room Slice” → another set

Each slice contains:

* The items in that room (initialState)
* The allowed operations (reducers)
* Automatically generated tools (actions)

Everything is neatly organized in one place.

---

# 5. How createSlice works internally

Step-by-step internal flow:

1. createSlice receives:

   * slice name
   * initial value
   * reducers
   * async actions (optional via extraReducers)

2. Redux Toolkit generates:

   * Action type strings like `"counter/increment"`
   * Action creators: `increment()`
   * A reducer function

3. Reducers use Immer:

   * You write: `state.value++`
   * Immer converts into immutable update automatically

4. The slice reducer is added to store:

   * `state.counter` becomes the slice state

5. Components dispatch actions through useDispatch

6. State updates trigger re-renders
   Only affected slices re-render (via useSelector)

---

# 6. Developer Mindset Thinking

Ask:

1. Is this feature logically independent enough for a slice?
2. Does the logic naturally group into one domain?
3. Should I colocate actions, reducers, and state?
4. Will this state be global and used across multiple components?
5. Is mutation-like reducer code preferable?

If YES → create a slice.

---

# 7. Simple Code Example (Core createSlice)

## File: counterSlice.js

```jsx
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
    incrementByAmount(state, action) {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;
```

Notes:

* Action types generated:

  * `counter/increment`
  * `counter/decrement`
  * `counter/incrementByAmount`
* Action creators generated automatically
* Reducer logic written as mutation, internally immutable

---

# 8. Dry Run of Example

1. Redux initializes state: `{ value: 0 }`
2. User clicks increment:
   – dispatch(increment())
   – reducer runs: `state.value += 1`
3. Immer generates new state `{ value: 1 }`
4. Component reading counter value re-renders

The mutation you write is not a real mutation.
Immer captures it and returns a new state object.

---

# 9. Example 2: Separate Slice for Authentication

## File: authSlice.js

```jsx
import { createSlice } from "@reduxjs/toolkit";

const authSlice = createSlice({
  name: "auth",
  initialState: { user: null, isAuthenticated: false },
  reducers: {
    login(state, action) {
      state.user = action.payload;
      state.isAuthenticated = true;
    },
    logout(state) {
      state.user = null;
      state.isAuthenticated = false;
    }
  }
});

export const { login, logout } = authSlice.actions;
export default authSlice.reducer;
```

This slice is responsible for:

* Storing user data
* Tracking auth status
* Providing login/logout actions

---

# 10. Example 3: Using extraReducers for async thunks

```jsx
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export const fetchTodos = createAsyncThunk("todos/fetch", async () => {
  const res = await fetch("/api/todos");
  return res.json();
});

const todoSlice = createSlice({
  name: "todos",
  initialState: { data: [], status: "idle" },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = "success";
        state.data = action.payload;
      })
      .addCase(fetchTodos.rejected, (state) => {
        state.status = "failed";
      });
  }
});

export default todoSlice.reducer;
```

Notes:

* `.pending`, `.fulfilled`, `.rejected` states auto-created
* Logic for async lives inside slice
* Cleaner than old Redux

---

# 11. Common Mistakes

1. Putting unrelated logic inside one slice
2. Overusing deeply nested initialState
3. Writing slow, expensive reducer logic
4. Using return inside reducer when mutation syntax is simpler
5. Treating createSlice as local state replacement unnecessarily
6. Forgetting that reducers must be pure functions
7. Using multiple slices for trivial state

---

# 12. When NOT to Use createSlice

* If state belongs naturally to a single component
* If all your app’s data is server state (use React Query)
* If Zustand or Jotai provide cleaner patterns for your app
* If app has no global state

createSlice is perfect for **application-level client state**, not server state.

---

# 13. Best Practices

1. One slice per domain
2. Keep initial state shallow
3. Keep reducers small and single-purpose
4. Prefer Immer mutation syntax
5. Use extraReducers for async thunk
6. Export actions and reducer cleanly
7. Test reducers independently

---

# 14. Compare: createSlice vs classic Redux reducers

| Feature         | Classic Redux      | createSlice           |
| --------------- | ------------------ | --------------------- |
| Action types    | Manual             | Auto-generated        |
| Action creators | Manual             | Auto-generated        |
| Reducers        | switch-case        | Object-based          |
| Update logic    | Immutable manually | Immer mutation syntax |
| Boilerplate     | High               | Low                   |
| Async handling  | Complex            | Built-in support      |
| Structure       | Developer-defined  | Feature-driven        |

createSlice is the major reason Redux Toolkit is now the official approach.

---

# 15. Follow-up questions

1. How does Immer help createSlice reduce boilerplate?
2. Why does createSlice improve readability and maintainability?
3. What is the purpose of slice name in createSlice?
4. Why should slices be feature-specific rather than huge combined reducers?
5. How do auto-generated actions change developer workflow?
6. How does extraReducers integrate async thunks into slices?
7. Why does mutation-like syntax work safely inside createSlice?
8. What happens internally when dispatching a slice action?
9. Why is createSlice not suitable for server-side state?
10. How should slice architecture scale for enterprise apps?
