# 16.2 Store + Slice Architecture

---

# 1. Why Store + Slice Architecture?

### The core problem

Before Redux Toolkit, Redux apps suffered from:

* Scattered logic across multiple files
* Action types in one file
* Action creators in another
* Reducers in switch-case patterns
* Store setup with many steps
* Hard-to-follow state structure
* Difficult debugging
* Scaling issues as app grows

Classic Redux architecture required **4–6 files just for a simple feature**.

Redux Toolkit simplifies this with a **Store + Slice** architecture:

* Each domain of the app gets its own slice
* All logic for that domain lives inside one file
* Store composes slices
* Architecture is clean, predictable, scalable

---

# 2. What is Store + Slice Architecture?

### A Slice

A slice is:

* A piece of global state
* Its reducer logic
* Its actions
* Optional async thunks

Everything in **one file**, created via `createSlice()`.

### The Store

The global store combines all slices using `configureStore()`.

Benefits:

* Clear separation of concerns
* Feature-driven structure
* Less boilerplate
* Better code readability
* Industry-standard pattern

---

# 3. When to use Store + Slice structure?

Use this architecture when:

* App has multiple logical domains (auth, user, cart, products, sidebar, theme)
* You want predictable and scalable state structure
* Multiple developers work on different features
* You want to organize Redux in a professional, maintainable way

Avoid Store + Slice when:

* App is tiny with almost no global state
* You use Zustand or Jotai (different paradigms)
* You don’t need global shared state

---

# 4. Analogy

Think of your application as a library:

* Each slice = a separate bookshelf (auth, cart, products)
* Store = the entire library where all bookshelves are organized
* Reducers = librarians maintaining their section
* Actions = tasks performed in each section

Slices keep everything organized and modular.

---

# 5. How Store + Slice works internally

1. createSlice() generates:

   * Initial state
   * Reducers
   * Actions
   * Action types

2. configureStore() collects slices and sets up:

   * Root reducer
   * Redux DevTools
   * Middleware (Thunk)

3. Components use:

   * useSelector → read slice state
   * useDispatch → trigger slice actions

4. Redux uses Immer to convert “mutating code” into immutable updates.

Flow:

```
Dispatch action
↓
Slice reducer runs
↓
Immer produces next immutable state
↓
Store updates
↓
React re-renders subscribed components
```

---

# 6. Folder Structure (Recommended)

```
src/
 └── features/
      ├── counter/
      │    ├── counterSlice.js
      │    ├── counterAPI.js (optional)
      │    └── Counter.jsx
      ├── auth/
      │    ├── authSlice.js
      │    ├── LoginForm.jsx
      │    └── authAPI.js
 └── app/
      ├── store.js
      └── rootReducer.js (optional)
```

---

# 7. Simple Code Example (Store + Slice)

## File: src/features/counter/counterSlice.js

```jsx
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value++;
    },
    decrement(state) {
      state.value--;
    },
    reset(state) {
      state.value = 0;
    }
  }
});

export const { increment, decrement, reset } = counterSlice.actions;
export default counterSlice.reducer;
```

## File: src/app/store.js

```jsx
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "../features/counter/counterSlice";

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});
```

## File: Counter.jsx

```jsx
import { useSelector, useDispatch } from "react-redux";
import { increment, decrement, reset } from "./counterSlice";

export default function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Count: {count}</p>

      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(reset())}>Reset</button>
    </div>
  );
}
```

---

# 8. Dry Run of the Example

1. store.js registers counterReducer under key `counter`.
2. App renders Counter component.
3. useSelector reads `state.counter.value`.
4. Click on increment:
   – dispatch(increment())
   – RTK runs counterSlice reducer
   – state.value++ updates internally through Immer
5. Store updates state.tree
6. React re-renders Counter
7. UI shows updated value

Everything is managed cleanly and efficiently.

---

# 9. Example 2: Multiple slices combined

## authSlice.js

```jsx
const authSlice = createSlice({
  name: "auth",
  initialState: { user: null },
  reducers: {
    login(state, action) {
      state.user = action.payload;
    },
    logout(state) {
      state.user = null;
    }
  }
});
```

## store.js

```jsx
export const store = configureStore({
  reducer: {
    counter: counterReducer,
    auth: authReducer
  }
});
```

Now the state tree looks like:

```js
{
  counter: { value: 0 },
  auth: { user: null }
}
```

Each slice cleanly owns its own state domain.

---

# 10. Common Mistakes

1. Creating too many slices unnecessarily
2. Putting unrelated logic into one slice
3. Deeply nested initialState (harder to update)
4. Writing manual immutable logic (Immer already handles mutation syntax)
5. Mixing slice actions with classic Redux actions
6. Not organizing slices by feature
7. Putting async logic inside reducers instead of createAsyncThunk

---

# 11. When NOT to Use Slice Architecture

* Very small apps with no global state
* Apps built using Zustand or Jotai
* If all your state is server data (React Query required)
* If state lives naturally in components (local state)

Slices are ideal for medium to large apps, not trivial ones.

---

# 12. Best Practices

1. One slice per domain (authSlice, cartSlice, themeSlice)
2. Do NOT combine unrelated features in one slice
3. Keep initial state shallow
4. Prefer createAsyncThunk for async work
5. Keep reducers pure and predictable
6. Use selector functions for cleaner components
7. Organize slices in /features/domain folders
8. Never modify the store directly

---

# 13. Compare: Classic Redux vs Store+Slice (RTK)

| Feature         | Classic Redux     | RTK Slice Architecture |
| --------------- | ----------------- | ---------------------- |
| Boilerplate     | Very high         | Very low               |
| Reducers        | switch-case       | createSlice            |
| Action creators | Manual            | Auto-generated         |
| Structure       | Developer-defined | Standardized           |
| Async handling  | Complex           | createAsyncThunk       |
| DevTools        | Manual            | Built-in               |
| Learning curve  | Hard              | Easier                 |
| Best practice   | Not enforced      | Enforced               |

---

# 14. Follow-up questions

1. Why does Redux Toolkit prefer slice-based structure?
2. What are the benefits of keeping reducers inside slices?
3. Why does RTK use Immer behind the scenes?
4. How does configureStore simplify setup?
5. What happens internally when createSlice generates actions?
6. What problems occur when slices hold deeply nested states?
7. How do slices improve team collaboration in large apps?
8. Why do we avoid writing switch-case reducers in RTK?
9. When should separate slices be merged into one?
10. Why is RTK architecture more scalable than React Context?
