# 16.4 AsyncThunk (API Calls)

---

# 1. Why createAsyncThunk?

### The core problem

Before Redux Toolkit, handling async logic in Redux was painful.

Developers needed to:

* Write 3 separate action types (`REQUEST`, `SUCCESS`, `FAILURE`)
* Write 3 action creators
* Write thunk functions manually
* Handle loading/error states in reducers
* Coordinate API logic + Redux logic

Example of classic Redux async:

```js
dispatch({ type: "FETCH_START" });
try {
  const data = await api();
  dispatch({ type: "FETCH_SUCCESS", payload: data });
} catch (err) {
  dispatch({ type: "FETCH_ERROR", error: err });
}
```

Problems:

* Too much boilerplate
* Repetitive patterns across features
* Easy to make mistakes
* No standard error handling
* Complex flow for each API call
* Hard to track states

`createAsyncThunk` solves this by generating the entire async lifecycle automatically.

---

# 2. What is createAsyncThunk?

`createAsyncThunk` is a Redux Toolkit function that lets you create:

* An async function
* Auto-generated pending, fulfilled, rejected actions
* Built-in error handling
* Easy integration with slices (extraReducers)

Syntax:

```js
const myThunk = createAsyncThunk("sliceName/actionName", async (arg, thunkAPI) => {
  const response = await someAPI(arg);
  return response;
});
```

When dispatched:

```js
dispatch(myThunk(argument));
```

RTK automatically triggers:

1. `myThunk.pending`
2. `myThunk.fulfilled` (if resolved)
3. `myThunk.rejected` (if error)

No boilerplate.

---

# 3. When to use createAsyncThunk?

Use it when:

* Fetching API data
* Posting/putting/deleting data
* Running async logic before updating Redux state
* Handling server errors
* Coordinating loading + success + failure states

Do NOT use createAsyncThunk when:

* You need server-side caching → use RTK Query
* Logic doesn’t require Redux state → use local state or React Query
* Async code is not tied to global state

---

# 4. Analogy

Think of `createAsyncThunk` as a delivery management system:

* You place an order → pending
* It arrives → fulfilled
* It fails → rejected

Redux Toolkit automatically manages these states, logs them, and updates Redux.

You only write the order logic, RTK handles everything else.

---

# 5. How createAsyncThunk works internally

Steps:

1. Dispatch `fetchData()`
2. RTK dispatches `fetchData/pending` internally
3. RTK executes async function
4. If resolved → dispatches `fetchData/fulfilled`
5. If rejected → dispatches `fetchData/rejected`
6. Reducer handles all three actions via `extraReducers`

RTK also:

* Provides error messages automatically
* Passes helpers through thunkAPI
* Ensures predictable behavior in concurrent rendering

---

# 6. Developer Mindset Thinking

Ask:

1. Does this async logic update global Redux state?
2. Do I need loading/error indicators?
3. Should this data be persisted across components?
4. Does component-level fetching cause prop drilling or duplication?
5. Should this API result live in Redux?

If YES → use createAsyncThunk.

If the data is server state (cache, refetch, stale handling) → use RTK Query or React Query instead.

---

# 7. Simple Code Example

## File: todosSlice.js

```jsx
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export const fetchTodos = createAsyncThunk(
  "todos/fetchTodos",
  async () => {
    const res = await fetch("https://jsonplaceholder.typicode.com/todos");
    return res.json();
  }
);

const todosSlice = createSlice({
  name: "todos",
  initialState: { data: [], status: "idle", error: null },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.status = "success";
        state.data = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.status = "error";
        state.error = action.error.message;
      });
  }
});

export default todosSlice.reducer;
```

## Component

```jsx
import { useDispatch, useSelector } from "react-redux";
import { fetchTodos } from "./todosSlice";

export default function TodoList() {
  const dispatch = useDispatch();
  const { data, status } = useSelector((state) => state.todos);

  return (
    <div>
      <button onClick={() => dispatch(fetchTodos())}>Load Todos</button>

      {status === "loading" && <p>Loading...</p>}
      {status === "error" && <p>Error loading data</p>}
      {status === "success" &&
        data.slice(0, 5).map((todo) => <p key={todo.id}>{todo.title}</p>)}
    </div>
  );
}
```

---

# 8. Dry Run of the Example

1. Component dispatches `fetchTodos()`
2. createAsyncThunk triggers:
   – `todos/fetchTodos/pending` → updates status to loading
3. API resolves
4. Redux Toolkit dispatches `todos/fetchTodos/fulfilled`
5. Slice reducer updates state.data with fetched todos
6. Component re-renders with updated data

If API fails:

* RTK dispatches `fetchTodos/rejected`
* slice sets status to error

Developer writes minimal code.

---

# 9. Example 2: Passing arguments to Thunk

```jsx
export const fetchUser = createAsyncThunk(
  "users/fetchUser",
  async (userId) => {
    const res = await fetch(`/api/users/${userId}`);
    return res.json();
  }
);
```

Usage:

```jsx
dispatch(fetchUser(5));
```

Thunk receives 5 as argument.

---

# 10. Example 3: Using thunkAPI (advanced)

Inside the async function, you get helpful tools:

```jsx
async (arg, thunkAPI) => {
  const state = thunkAPI.getState();
  const dispatch = thunkAPI.dispatch;
  const reject = thunkAPI.rejectWithValue;
}
```

Typical usage:

* Reading current state before making request
* Dispatching another action
* Custom error messages

---

# 11. Common Mistakes

1. Putting API logic inside reducers (reducers must stay pure)
2. Not handling pending/fulfilled/rejected properly
3. Mutating nested state incorrectly (immer helps but avoid complexity)
4. Dispatching thunk in a loop without caching
5. Using createAsyncThunk for server cache (RTK Query is better)

---

# 12. When NOT to Use createAsyncThunk

* When your app needs server-side cache and automatic refetch
* When the data changes often and needs stale/fresh logic
* For local UI-based async behavior
* When global state is unnecessary

In these cases, **use RTK Query or React Query**.

---

# 13. Best Practices

1. Name thunks by feature + action
2. Always handle pending, fulfilled, rejected states
3. Keep slice initialState simple
4. Avoid deeply nested async state structure
5. Use thunkAPI.rejectWithValue for clean error handling
6. Use selectors to access state
7. Do not dispatch thunks from reducers

---

# 14. Compare: useEffect fetching vs createAsyncThunk

| Feature                    | useEffect | createAsyncThunk |
| -------------------------- | --------- | ---------------- |
| Local state                | Yes       | No               |
| Global shared state        | No        | Yes              |
| Auto async lifecycle       | No        | Yes              |
| Auto error/pending         | No        | Yes              |
| Boilerplate                | High      | Low              |
| Recommended for large apps | No        | Yes              |
| SSR friendliness           | Medium    | Good             |

---

# 15. Follow-up questions

1. How does Redux Toolkit automatically create pending, fulfilled, rejected actions?
2. Why is createAsyncThunk safer than putting async code in components?
3. When should you replace createAsyncThunk with RTK Query?
4. Why must reducers remain pure while thunks can contain side-effects?
5. What is the advantage of using thunkAPI.getState()?
6. Why does Redux require extraReducers for async logic?
7. How does RTK simplify immutable updates inside async reducers?
8. What are the performance implications of many async thunks?
9. How do you cancel a running thunk?
10. How should you structure your project when using multiple thunks?
