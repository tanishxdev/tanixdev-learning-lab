# **22.2 Smart vs Dumb Components Pattern**

---

# 1. What Are Smart and Dumb Components?

This pattern divides components into two categories:

### 1. **Smart Components** (a.k.a. Stateful, Container, Logic Components)

They handle:

* fetching data
* connecting to React Query / Redux / Zustand
* state management
* business rules
* event handlers
* deciding which UI to show

### 2. **Dumb Components** (a.k.a. Presentational Components)

They handle:

* layout
* styling
* rendering props
* simple UI interactions
* no business logic
* no network calls

The separation makes large apps predictable and scalable.

---

# 2. Why Do We Need This Pattern?

### Problem 1: Components become bloated

Logic + UI in one file becomes impossible to maintain.

### Problem 2: UI is not reusable

A card UI cannot be reused if logic is embedded inside.

### Problem 3: Testing becomes hard

Mixed components require full integration tests.

### Problem 4: Redesigns break logic

Changing CSS affects business logic.

### Problem 5: Logic gets duplicated

Multiple components fetching the same data.

Smart–Dumb separation fixes all these issues.

---

# 3. How the Pattern Works (Architecture Overview)

```
Smart Component = What to render (logic)
Dumb Component  = How to render (UI)
```

Smart components decide the *data* and *actions*.
Dumb components decide the *presentation*.

Common structure:

```
ProductCardSmart.jsx → data, state, events
ProductCardUI.jsx     → pure UI
```

---

# 4. Basic Example (Simple)

### Dumb Component (UI Only)

```jsx
export function UserCardUI({ user }) {
  return (
    <div className="card">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

### Smart Component (Logic)

```jsx
export function UserCardSmart() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch("/api/user/1")
      .then(res => res.json())
      .then(setUser);
  }, []);

  if (!user) return <p>Loading...</p>;

  return <UserCardUI user={user} />;
}
```

---

# 5. Smart Components with React Query (Real Application)

### Smart Component

```jsx
export function ProductSmart({ id }) {
  const { data, isLoading } = useQuery({
    queryKey: ["product", id],
    queryFn: () => api.get(`/products/${id}`).then(res => res.data)
  });

  if (isLoading) return <ProductSkeleton />;

  return <ProductUI product={data} />;
}
```

### Dumb Component

```jsx
export function ProductUI({ product }) {
  return (
    <div className="shadow p-4">
      <h1>{product.title}</h1>
      <p>${product.price}</p>
    </div>
  );
}
```

---

# 6. How This Differs From Container–Presenter Pattern

| Feature      | Container–Presenter    | Smart vs Dumb                    |
| ------------ | ---------------------- | -------------------------------- |
| Origin       | Specific React pattern | Broad architectural principle    |
| Relationship | Always 1:1 pair        | Not required to be paired        |
| Purpose      | Split UI vs logic      | Categorize all components in app |
| Scope        | Component level        | Entire system                    |

In short:

```
All Presenter components are Dumb
Not all Dumb components are Presenters
```

---

# 7. Smart Component Responsibilities

Smart components can:

* fetch or mutate data
* manage global or local state
* coordinate side effects
* choose which Dumb component to render
* perform business logic
* pass down callbacks

Smart components should not:

* render heavy UI
* care about styling
* contain display logic

---

# 8. Dumb Component Responsibilities

Dumb components can:

* render UI
* show props
* manage tiny display state (toggle, hover)

Dumb components must not:

* fetch data
* read global stores
* apply business logic
* modify application state

They must remain **pure UI**.

---

# 9. Complex Example: Table UI

### Smart Component

```jsx
export function ProductsTableSmart() {
  const [page, setPage] = useState(1);

  const { data, isLoading } = useQuery({
    queryKey: ["products", page],
    queryFn: () => api.get(`/products?page=${page}`).then(res => res.data)
  });

  return (
    <ProductsTableUI
      products={data?.items}
      page={page}
      loading={isLoading}
      onPageChange={setPage}
    />
  );
}
```

### Dumb Component

```jsx
export function ProductsTableUI({ products, loading, page, onPageChange }) {
  if (loading) return <TableSkeleton />;

  return (
    <div>
      <table>
        {products.map(p => (
          <tr key={p.id}>
            <td>{p.name}</td>
          </tr>
        ))}
      </table>

      <button onClick={() => onPageChange(page - 1)}>Prev</button>
      <button onClick={() => onPageChange(page + 1)}>Next</button>
    </div>
  );
}
```

---

# 10. Folder Structure Matching This Pattern

```
User/
  UserSmart.jsx
  UserUI.jsx

Products/
  ProductsTableSmart.jsx
  ProductsTableUI.jsx
```

Or at scale:

```
features/
  user/
    smart/
      UserSmart.jsx
    ui/
      UserUI.jsx
```

---

# 11. Anti-Patterns

Avoid:

### 1. Dumb components accessing React Query or Zustand

This makes them “smart”.

### 2. Smart components containing complex JSX

UI should be delegated.

### 3. Dumb components containing business rules

Example: filtering, mapping, or transforming data.

### 4. Smart components deeply nested in UI trees

Smart components belong near the top of a feature.

### 5. Using Smart/Dumb split for tiny components

Adds unnecessary complexity.

---

# 12. When Should You Use Smart vs Dumb Pattern?

Use it when:

* UI is reused in many places
* your component has heavy data logic
* you want testable components
* design team frequently changes the UI
* multiple pages share the same visual components

Avoid it when:

* component is tiny
* logic is trivial
* UI is unlikely to be reused
* time pressure doesn’t allow extra layers

---

# 13. Follow-up Questions

1. Which UI components in your codebase should become Dumb components?
2. Which parts of your app currently mix logic + UI and should be separated?
3. Should Smart components live at page-level or inside a `containers/` folder?
4. Do you want to pair Smart components with custom hooks for cleaner logic?
5. Do you want examples for Smart/Dumb pattern in forms or modals?
6. Should your UI library expose only Dumb components?
7. Should Smart components connect to React Query or Zustand exclusively?
8. Do you need a mixed approach (some components both smart and dumb)?
9. Should Smart components be memoized for render performance?
10. Do you want to combine this pattern with Container–Presenter or keep them separate?
