# **22.3 Render Props Pattern**

A complete explanation of **what the Render Props pattern is**, why it exists, how it solves reusable-behavior problems, how modern React uses (and avoids) it, and how to implement it in clean, production-grade architecture.

This pattern was one of the most influential before hooks, and it still matters for understanding advanced React design.

---

# 1. What Is the Render Props Pattern?

A **Render Prop** is a function passed as a prop that a component calls to decide **what UI to render**.

Instead of passing JSX, you pass a function:

```jsx
<Component render={(state) => <UI state={state} />} />
```

or more commonly:

```jsx
<Component>{(state) => <UI state={state} />}</Component>
```

The component handles behavior,
The render prop consumer controls UI.

---

# 2. Why Does This Pattern Exist?

### Problem 1: Need to share logic across many components

Before hooks, React had no simple way to share:

* hover logic
* toggle logic
* scrolling logic
* tracking positions
* async state
* animations
* mouse tracking

Render props solved **reusable behavior**.

### Problem 2: HOC limitations

Higher-Order Components often cause:

* naming conflicts
* wrapper hell
* unclear dependencies

Render props give direct control.

### Problem 3: You need flexible UI with fixed behavior

One logic implementation → infinite UI variations.

---

# 3. How the Pattern Works (Architecture Overview)

A render-prop component:

1. Owns internal state or logic
2. Calls `children` or `render` with that state
3. Lets the parent decide what UI to display

Flow:

```
Logic Component → provides state
Render Prop → decides UI
```

This decouples logic from UI without using containers.

---

# 4. Basic Example: Toggle Behavior

### Logic component (render props provider)

```jsx
export function Toggle({ children }) {
  const [on, setOn] = useState(false);

  function toggle() {
    setOn((v) => !v);
  }

  return children({ on, toggle });
}
```

### Usage

```jsx
<Toggle>
  {({ on, toggle }) => (
    <button onClick={toggle}>
      {on ? "On" : "Off"}
    </button>
  )}
</Toggle>
```

UI is not fixed at all.
Logic is fully reusable.

---

# 5. Example: Mouse Position Tracker (Classic)

### Logic

```jsx
function MouseTracker({ children }) {
  const [pos, setPos] = useState({ x: 0, y: 0 });

  return (
    <div
      onMouseMove={(e) =>
        setPos({ x: e.clientX, y: e.clientY })
      }
    >
      {children(pos)}
    </div>
  );
}
```

### UI Variations

#### Variation 1: Show coordinates text

```jsx
<MouseTracker>
  {(pos) => <p>X: {pos.x}, Y: {pos.y}</p>}
</MouseTracker>
```

#### Variation 2: Move a box with cursor

```jsx
<MouseTracker>
  {(pos) => (
    <div style={{
      position: "absolute",
      top: pos.y,
      left: pos.x,
      width: 20,
      height: 20,
      background: "red"
    }} />
  )}
</MouseTracker>
```

Same logic → infinite UI.

---

# 6. Real Production Use Case: Dropdown or Popover Positioning

### Logic component

```jsx
function Positioner({ children }) {
  const ref = useRef();
  const [coords, setCoords] = useState(null);

  useLayoutEffect(() => {
    if (ref.current) {
      const rect = ref.current.getBoundingClientRect();
      setCoords(rect);
    }
  }, []);

  return children({ ref, coords });
}
```

### UI

```jsx
<Positioner>
  {({ ref, coords }) => (
    <>
      <button ref={ref}>Open</button>
      {coords && <div style={{ top: coords.bottom }}>Menu</div>}
    </>
  )}
</Positioner>
```

Modern libraries like **Headless UI** and **Radix** evolved from this pattern.

---

# 7. Render Props vs Container–Presenter Pattern

| Pattern             | Purpose                                 |
| ------------------- | --------------------------------------- |
| Container–Presenter | Separate logic vs UI                    |
| Render Props        | Inject reusable logic into arbitrary UI |

Render props can even replace containers.

---

# 8. Render Props vs Custom Hooks (Modern React)

Hooks replaced most render-prop usage.

### Render props version

```jsx
<Toggle>
  {({ on, toggle }) => <Button on={on} toggle={toggle} />}
</Toggle>
```

### Hook version

```jsx
const { on, toggle } = useToggle();
<Button on={on} toggle={toggle} />;
```

Hooks are:

* simpler
* cleaner
* avoid nested functions
* avoid “render props pyramid”

However, render props still matter for:

* UI libraries
* component API flexibility
* animation systems
* exposing reusable behavior

---

# 9. Nested Render Props Problem (Anti-pattern)

```jsx
<Mouse>
  {(mouse) => (
    <Toggle>
      {(toggle) => (
        <FetchUser>
          {(user) => <UI mouse={mouse} toggle={toggle} user={user} />}
        </FetchUser>
      )}
    </Toggle>
  )}
</Mouse>
```

This becomes unreadable.

Custom hooks eliminate this problem.

---

# 10. Modern Example: Animation Library Pattern

Framer Motion uses a similar concept internally:

```jsx
<AnimatePresence>
  {isOpen && <Modal />}
</AnimatePresence>
```

Children-as-function or children-as-behavior pattern is derived from Render Props.

---

# 11. Anti-Patterns

Avoid:

### 1. Too many nested render props

Leads to callback pyramids.

### 2. Passing large objects each render

Causes re-renders.

### 3. Using render props when hook is simpler

Choose patterns productively.

### 4. Using render props in performance-critical sections

Inline functions re-render often.

---

# 12. When Should You Use Render Props?

Use render props when:

* logic must be shared across arbitrary UI
* consumer must control UI structure
* component must inject behavior
* building headless UI libraries
* building reusable animations
* building dynamic positioners (dropdowns, tooltips)

Do not use when:

* hooks or composition solve the problem cleaner
* the component becomes deeply nested
* UI library already provides hooks

---

# 13. Full Production Example: Headless Tabs

Logic component:

```jsx
export function Tabs({ children }) {
  const [active, setActive] = useState(0);
  return children({ active, setActive });
}
```

UI:

```jsx
<Tabs>
  {({ active, setActive }) => (
    <>
      <div className="tab-list">
        <button onClick={() => setActive(0)}>Tab 1</button>
        <button onClick={() => setActive(1)}>Tab 2</button>
      </div>

      {active === 0 && <Content1 />}
      {active === 1 && <Content2 />}
    </>
  )}
</Tabs>
```

This is how older headless libraries were designed.

---

# 14. Follow-up Questions

1. Do you need render props for sharing behavior in your current project?
2. Should your UI library expose hooks or render props or both?
3. Are there any animations or interactions where render props make more sense?
4. Do you want to build a headless UI pattern using render props?
5. Should render props internally use custom hooks for cleaner logic?
6. Are you trying to build reusable dropdown, tooltip, or popover logic?
7. Do any of your components have logic that needs injection into arbitrary UI?
8. Should we combine render props + state reducer pattern in later chapters?
9. Do you want a deep dive on replacing render props with hooks?
10. Do you need a migration guide: Render Props → Hooks?

