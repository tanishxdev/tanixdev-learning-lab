# **22.4 Higher-Order Components (HOC) Pattern**

A complete explanation of **what HOCs are**, why they were heavily used before hooks, what problems they solved, why modern React uses them less, and when they still matter in production.

---

# 1. What Is a Higher-Order Component?

A **Higher-Order Component (HOC)** is a function that takes a component and returns a new component with enhanced behavior.

Definition:

```jsx
const EnhancedComponent = withSomething(BaseComponent);
```

General form:

```jsx
function withX(Component) {
  return function WrappedComponent(props) {
    // inject logic
    return <Component {...props} />;
  };
}
```

HOCs add reusable logic on top of UI components **without modifying them directly**.

---

# 2. Why Do We Need HOCs? (Original Problem)

Before hooks, React had no simple way to share logic.
Developers needed a pattern to reuse behavior such as:

* fetching data
* listening to events
* authentication logic
* permissions (RBAC)
* window size or scroll tracking
* analytics
* subscriptions

HOCs solved:

### Problem 1: Code duplication

Same logic repeated in many components.

### Problem 2: Need to add logic without editing original component

HOCs wrap the component from outside.

### Problem 3: Need to provide extra props

HOCs inject props seamlessly.

### Problem 4: Need to enforce cross-cutting behavior

Analytics, logging, timing, permissions.

---

# 3. How HOCs Work (Architecture Overview)

```
withLogic(Component) â†’ EnhancedComponent
```

Flow:

1. Pass the original component to a function
2. Logic is applied inside the wrapper
3. Wrapper renders the original component with extra props

This is similar to middleware in backend frameworks.

---

# 4. Basic Example: Adding Window Size Logic

### HOC (logic provider)

```jsx
function withWindowSize(Component) {
  return function Wrapped(props) {
    const [size, setSize] = useState(window.innerWidth);

    useEffect(() => {
      const handler = () => setSize(window.innerWidth);
      window.addEventListener("resize", handler);
      return () => window.removeEventListener("resize", handler);
    }, []);

    return <Component {...props} windowWidth={size} />;
  };
}
```

### Usage

```jsx
function Header({ windowWidth }) {
  return <div>Width: {windowWidth}</div>;
}

export default withWindowSize(Header);
```

UI becomes behavior-aware without internal logic.

---

# 5. Example: Authentication Guard HOC

### HOC

```jsx
function withAuth(Component) {
  return function Protected(props) {
    const token = localStorage.getItem("token");

    if (!token) return <p>Unauthorized</p>;

    return <Component {...props} />;
  };
}
```

### Usage

```jsx
function Dashboard() {
  return <h1>Dashboard</h1>;
}

export default withAuth(Dashboard);
```

This pattern is still used in enterprise apps for RBAC.

---

# 6. Example: Data Fetching HOC (Pre-hooks Era)

### HOC

```jsx
function withUser(Component) {
  return function Wrapped(props) {
    const { data, isLoading } = useQuery({
      queryKey: ["user"],
      queryFn: fetchUser
    });

    return <Component {...props} user={data} loading={isLoading} />;
  };
}
```

### Usage

```jsx
function Profile({ user }) {
  return <h1>{user.name}</h1>;
}

export default withUser(Profile);
```

HOCs integrate naturally with React Query or Zustand.

---

# 7. Why HOCs Are Used Less Today

Hooks replaced most HOCs because:

* HOCs create deeply nested component trees
* hard to debug
* messy stack traces
* naming conflicts (`displayName`)
* wrapper hell
* hard to type in TypeScript
* hooks give the same power with fewer layers

Modern pattern:

```jsx
const data = useUser();
<Profile data={data} />;
```

Cleaner. No wrapper component needed.

---

# 8. HOC vs Render Props vs Custom Hooks

| Feature         | HOC                 | Render Props  | Hooks       |
| --------------- | ------------------- | ------------- | ----------- |
| Adds behavior   | Yes                 | Yes           | Yes         |
| UI flexibility  | Medium              | High          | Highest     |
| Code complexity | Medium              | High (nested) | Low         |
| Extra layers    | Yes                 | No            | No          |
| Best for        | Cross-cutting logic | UI injection  | Logic reuse |

Hooks replaced **90%** of HOC use cases.

HOCs remain useful for cross-cutting concerns:

* analytics
* permission guards
* feature flags
* error logging
* experiment toggles
* theming wrappers

---

# 9. Real Production Example: Feature Flag HOC

### HOC

```jsx
function withFeatureFlag(flagName) {
  return function (Component) {
    return function Wrapped(props) {
      const flags = useFeatureFlags();

      if (!flags[flagName]) return null;

      return <Component {...props} />;
    };
  };
}
```

### Usage

```jsx
const NewUI = withFeatureFlag("newDashboard")(DashboardUI);
```

Used heavily in large companies.

---

# 10. Anti-Patterns

Avoid:

### 1. HOCs inside render functions

Causes new components on every render.

### 2. HOCs that mutate props

They must be pure wrappers.

### 3. Multiple nested HOCs

Hard to read and debug.

### 4. Using HOCs when hooks solve the problem

Pattern should improve clarity, not reduce it.

### 5. Wrapping too many components with the same HOC

Better to wrap at layout or route level.

---

# 11. When Should You Use HOCs Today?

Use HOCs when:

* you need cross-cutting logic without modifying UI components
* you are building a design system or internal tooling
* you need to apply behavior without touching UI code
* routes or pages need guards
* analytics/monitoring should automatically wrap components
* implementing A/B testing or feature toggles

Avoid HOCs when:

* hooks give the same result
* UI flexibility is important
* readability matters
* code is likely to be maintained by juniors

---

# 12. Follow-up Questions

1. Do you need HOCs for authentication, permission checks, or RBAC?
2. Should your project implement cross-cutting concepts with HOCs or hooks?
3. Do you want to combine HOCs with React Router for route protection?
4. Are there duplicated behaviors that could be extracted into HOCs?
5. Should HOCs internally use hooks for logic?
6. Do you need TypeScript versions of HOC patterns?
7. Should we build a feature flag system using HOCs later?
8. Are there areas in your UI where wrapping components makes sense?
9. Should HOCs control visibility or inject props?
10. Do you want a comparison: HOC vs Context vs Render Props in detail?
