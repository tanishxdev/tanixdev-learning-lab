# 18.4 Caching (React Query)

A complete, deep, production-level explanation of **how caching works in React Query**, what problems it solves, how the cache lifecycle works, how data is stored and reused, and how to tune cache behavior for your app.

Caching is one of the main reasons React Query exists — without understanding caching, you cannot architect server state correctly.

---

# 1. Why Do We Need Caching?

The real-world server-state problems:

### Without caching:

* Every mount → new API call
* Switching pages → flicker
* Back button → reload everything
* Multiple components → duplicate requests
* Slow pages
* Expensive APIs overused
* Inconsistent UI
* Stale data bugs

Caching solves all of these.

---

# 2. What Is React Query's Cache?

React Query cache = **in-memory storage of server responses**, managed by QueryClient.

The cache stores:

* data
* timestamps
* status
* request metadata
* observers (components subscribed)
* retry information
* stale/fresh state

The important idea:

```
Cache survives component unmounts.
Cache lives as long as QueryClient lives.
```

So navigating between pages does NOT lose data.

---

# 3. Basic Cache Example

```jsx
const query = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  cacheTime: 1000 * 60 * 5,   // 5 minutes
});
```

Meaning:

* Data stays in cache for 5 minutes after last use
* If component remounts before 5 minutes → cached data reused instantly

No flicker.
No refetch unless stale.

---

# 4. Difference Between staleTime and cacheTime (Very Important)

| Concept       | Meaning                              | Controls           | Default   |
| ------------- | ------------------------------------ | ------------------ | --------- |
| **staleTime** | How long data is considered fresh    | Refetch behavior   | 0 ms      |
| **cacheTime** | How long unused data stays in memory | Garbage collection | 5 minutes |

### staleTime controls freshness.

### cacheTime controls memory persistence.

---

# 5. Cache Lifecycle Diagram

```
FETCH → CACHE → FRESH → STALE → (unused) → EXPIRE
```

Full cycle:

1. Data fetched → stored in cache (fresh)
2. After staleTime → becomes stale
3. If not used (no components read it)
4. After cacheTime → removed

---

# 6. Cache Data Flow (Internal Working)

When a query runs:

```
queryFn executes → response stored in QueryCache → notify subscribers
```

On next component mount:

```
QueryClient checks cache:
  If exists → return cached data instantly
  If stale → refetch in background
  If expired → fetch again
```

This design is why React Query feels fast.

---

# 7. Why Caching in React Query Is Better Than Manual Global State?

Manual fetch with Zustand / Redux:

```
fetch → store data
leave page → lose data
return → refetch
no stale/fresh logic
no deduplication
no background sync
```

React Query cache solves:

✔ Keep server data alive
✔ Reuse cached data
✔ Auto-refetch stale queries
✔ Keep UI consistent
✔ Prevent duplicate requests
✔ Manage memory

---

# 8. Query Keys Control Cache Entries

Different query keys = different cache entries.

```jsx
useQuery(["todos"], fetchTodos)
useQuery(["todos", 1], fetchTodosByPage)
useQuery(["todos", "stats"], fetchStats)
```

React Query stores them separately.

This makes caching reliable and structured.

---

# 9. Example: Shared Cache Across Components

Component A:

```jsx
const { data } = useQuery(["user"], fetchUser);
```

Component B:

```jsx
const { data } = useQuery(["user"], fetchUser);
```

React Query **does not make two API calls**.

Both get the same cached data.

---

# 10. Example: Cache Followed by Background Refetch

Assume:

```jsx
staleTime: 10_000
```

At T=0:

* fetch user
* cache value
* fresh for 10 sec

At T=5 sec:

Component remount:

* Data returned instantly (cached)
* No refetch

At T=12 sec:

Component remount:

* Cached stale data shown immediately
* Background refetch triggered
* UI updates when new data arrives

Great UX + performance.

---

# 11. cacheTime Use Cases

### Use long cacheTime when:

* back/forward navigation should feel instant
* users frequently revisit pages
* you want minimal API calls
* slow networks

Example:

```jsx
cacheTime: 20 * 60 * 1000 // 20 minutes
```

---

### Use short cacheTime when:

* data is sensitive
* data becomes invalid quickly
* you want memory-free environment

Example:

```jsx
cacheTime: 0
```

This removes cache immediately after last subscriber unsubscribes.

---

# 12. Clearing Cache

You may want to clear cache when:

* user logs out
* switching accounts
* data becomes invalid globally

Use:

```jsx
queryClient.clear();
```

Or targeted:

```jsx
queryClient.removeQueries(["cart"]);
```

---

# 13. Updating Cache Manually (Optimistic)

React Query allows:

```jsx
queryClient.setQueryData(["todos"], (old) => [...old, newTodo]);
```

This lets you:

* update UI instantly
* avoid waiting for refetch
* create optimistic updates

Useful for:

* chat apps
* posts/comments
* carts
* likes

---

# 14. Example: Cache Deduplication

Two components request same data at same time:

```jsx
useQuery(["posts"], fetchPosts)
useQuery(["posts"], fetchPosts)
```

React Query:

* runs queryFn only once
* stores result
* shares result among components

This deduplication is a massive performance boost.

---

# 15. Cache Reset vs Invalidation vs Removal

| Operation             | Action                 |
| --------------------- | ---------------------- |
| **invalidateQueries** | mark stale → refetch   |
| **removeQueries**     | delete cache entry     |
| **resetQueries**      | reset to initial state |
| **clear**             | remove all caches      |

Most common:

```jsx
queryClient.invalidateQueries(["products"]);
```

This marks stale → triggers refetch.

---

# 16. Memory Impact

React Query stores cached data in memory.
With large API responses, consider:

* pagination
* infinite scroll
* shorter cacheTime
* server filtering
* normalized responses

But most apps don't need micro-optimization — memory usage is small.

---

# 17. Best Practices for Caching

1. **Always define staleTime intentionally**
2. Use **long staleTime** for slow-changing data
3. Use **short staleTime** for dashboards or real-time apps
4. Do NOT store server data in Zustand or Redux
5. Use `setQueryData` for optimistic UI updates
6. Use `invalidateQueries` after mutations
7. Keep queryKey stable and descriptive
8. Avoid fetching huge lists unnecessarily
9. Use pagination for large datasets
10. Let React Query manage the lifecycles — don’t fight it

---

# 18. Summary Table

| Concept            | Meaning                          |
| ------------------ | -------------------------------- |
| Cache              | In-memory store of API responses |
| staleTime          | When data becomes “old”          |
| cacheTime          | When data is garbage-collected   |
| setQueryData       | Manually update cache            |
| invalidateQueries  | Mark stale → refetch             |
| deduplication      | Prevent duplicate API calls      |
| background refetch | Fetch new data when stale        |

---

# 19. Follow-up Questions

1. Why does React Query keep stale data instead of removing it?
2. What happens when cacheTime expires?
3. How does React Query choose when to refetch?
4. Why is queryKey important for caching?
5. Why shouldn't server data be stored in Zustand?
6. How does deduplication improve performance?
7. What is the difference between invalidation and removal?
8. How does setQueryData enable optimistic updates?
9. When should cacheTime be reduced?
10. What happens if staleTime = Infinity?

---