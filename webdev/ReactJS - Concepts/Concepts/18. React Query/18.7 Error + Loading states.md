# 18.7 Error + Loading States (React Query)

A clean, deep, production-level explanation of **how React Query handles loading and error states**, why they are better than manual state management, how UI behaves across query lifecycles, and patterns used in real apps.

This topic is crucial because handling async state is usually the most repetitive, buggy, and inconsistent part of frontend apps — React Query solves this elegantly.

---

# 1. Why Do We Need Better Loading/Error Handling?

### The core problem

Most developers manually manage:

```jsx
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);
```

Problems:

* duplicated loading logic
* inconsistent error handling
* race conditions
* spinners everywhere
* handling stale data is hard
* simultaneous fetches overwrite each other
* no automatic retry
* error and loading states scattered across components

React Query centralizes and automates all of this.

---

# 2. How React Query Handles Loading States

React Query gives loading states automatically:

### useQuery states:

```ts
isLoading        // first fetch, no cache
isFetching       // any fetch (initial or background)
isRefetching     // refetch triggered manually
isInitialLoading // initial load for infinite queries
```

### What isLoading means:

```
No cached data + currently fetching
```

### What isFetching means:

```
Fetching in background (even if stale or cached data exists)
```

---

# 3. Why React Query Loading is Superior

React Query automatically decides loading behavior:

### Case A: No cache → show loading

User opens page first time
→ show loader (isLoading = true)

### Case B: Cache exists but stale → do NOT block UI

*show cached data*
→ background refetch
→ no flicker
→ no spinner blocking UI

### Case C: Manual refetch

isFetching is true but UI doesn’t blank out.

This matches expectations of modern UX.

---

# 4. Example: Handling Loading Cleanly

```jsx
const { data, isLoading, isFetching } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
});
```

### UI:

```jsx
if (isLoading) return <p>Loading...</p>;

return (
  <>
    {data.map(todo => <div>{todo.text}</div>)}
    {isFetching && <small>Updating...</small>}
  </>
);
```

User sees:

* main loading for initial load
* non-blocking spinner for background refresh

Production-grade UX.

---

# 5. How React Query Handles Error States

React Query gives automatic error state:

```ts
isError
error
```

Meaning:

```
queryFn failed → store error → display cleanly
```

You do NOT write:

```jsx
setError(err)
setLoading(false)
```

React Query owns that logic.

---

# 6. Example: Error Handling

```jsx
const { data, isLoading, isError, error } = useQuery({
  queryKey: ["users"],
  queryFn: async () => {
    const res = await fetch("/api/users");
    if (!res.ok) throw new Error("Unable to fetch users");
    return res.json();
  }
});
```

UI:

```jsx
if (isLoading) return <p>Loading...</p>;
if (isError) return <p>Error: {error.message}</p>;
```

No boilerplate.

---

# 7. Retry Logic (Automatic)

React Query retries failed queries automatically:

Default:

```
retry: 3
```

Behavior:

* network glitch → retry
* API unstable → retry
* offline → wait → retry on reconnect

You don’t manage this manually.

Override:

```jsx
retry: false
```

or

```jsx
retry: (failureCount, error) => failureCount < 2
```

---

# 8. Error Boundaries (React Query + React)

If you want React-level error UI:

```jsx
useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  useErrorBoundary: true
});
```

Then React Boundary handles rendering fallback screens.

---

# 9. Loading/Error Behavior During Refetch

Assume staleTime = 5 minutes.

Scenario:

User visits page → data fetched → cached.

Now after 3 minutes, user focuses window.

### React Query will:

* return cached data instantly
* start background refetch
* isLoading = false
* isFetching = true (non-blocking)
* no spinner covering the UI
* no flicker

If error occurs:

* UI does not break
* error appears only if you want to show it
* stale data still shown (prevents blank screen)

This is a huge UX improvement over `useEffect fetch`.

---

# 10. Manual Refetching and States

React Query adds:

```ts
refetch()
```

Calling:

```jsx
refetch()
```

Sets:

```
isFetching = true
isLoading stays false if cached data exists
```

This means:

* UI stays visible
* spinner shows on small corner
* no blocking behavior

---

# 11. useMutation Loading + Error

Mutations have separate loading/error handling:

```jsx
const mutation = useMutation({
  mutationFn: saveUser
});
```

Mutation states:

```ts
mutation.isPending
mutation.isError
mutation.isSuccess
mutation.error
```

Why different?

Mutations do NOT use cache.
They run on demand.

---

# 12. Mutation Example

```jsx
const mutation = useMutation({
  mutationFn: (user) =>
    fetch("/api/user", {
      method: "POST",
      body: JSON.stringify(user)
    })
});
```

UI:

```jsx
<button onClick={() => mutation.mutate(formData)}>
  {mutation.isPending ? "Saving..." : "Save"}
</button>

{mutation.isError && <p>Error: {mutation.error.message}</p>}
{mutation.isSuccess && <p>Saved!</p>}
```

React Query handles:

* loading state
* success state
* error state
* retry (if configured)

---

# 13. Best Practices for Loading States

### 1. Always differentiate:

```
isLoading vs isFetching
```

### 2. Use isLoading only for initial screen

Block UI only first time.

### 3. use isFetching for background refresh

Use small non-blocking indicators.

### 4. NEVER blank UI when cached data exists

React Query prevents this.

### 5. Use Suspense + Error Boundaries for cleaner screens (optional)

---

# 14. Best Practices for Error Handling

### 1. Use descriptive messages in queryFn

```jsx
if (!res.ok) throw new Error("Failed to fetch orders.");
```

### 2. Use useErrorBoundary for fatal failures

### 3. Show fallback UI but keep stale data on screen

### 4. Disable retry when error shouldn’t retry

```jsx
retry: false
```

### 5. For mutations, attach user-friendly messages

---

# 15. Comparison Table: Loading/Error States

| Task                       | React Query | Zustand/Redux |
| -------------------------- | ----------- | ------------- |
| Loading auto-managed       | Yes         | No            |
| Error auto-managed         | Yes         | No            |
| Background refetch         | Yes         | Manual        |
| Retry system               | Yes         | Manual        |
| Stale data retention       | Yes         | No            |
| Prevents UI flicker        | Yes         | Manual        |
| Cached data shown on error | Yes         | No            |
| Multi-component sync       | Automatic   | Manual        |

React Query is superior for server-state logic.

---

# 16. Dry Run Example (Full Lifecycle)

Let’s say staleTime = 10 seconds.

### Initial Load:

```
isLoading = true
fetch
success → cache data
isLoading = false
```

### After 12 seconds:

Component remounts.

```
show cached data
isLoading = false
isFetching = true   // background refetch

fetch success → update UI
```

### If fetch fails:

```
UI keeps showing stale data
isError = true
error displayed (optional)
```

This is ideal user experience.

---

# 17. Follow-up Questions

1. Why is isFetching better than showing a full-screen loader?
2. Why does React Query keep showing stale data during errors?
3. What is the difference between isLoading and isFetching?
4. When should you use useErrorBoundary in queries?
5. Why does React Query retry by default?
6. How does keeping cached data prevent UI flicker?
7. Should you show error UI or stale UI after a failed refetch?
8. Why is mutation loading/error separate from query loading/error?
9. When should retry be disabled for mutations?
10. How does React Query simplify async lifecycle management?
