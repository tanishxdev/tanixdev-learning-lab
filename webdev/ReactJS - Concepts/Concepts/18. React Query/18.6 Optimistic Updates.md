# 18.6 Optimistic Updates (React Query)

A complete, production-grade explanation of **what optimistic updates are**, why they matter, how React Query implements them, how to avoid common bugs, and how to architect mutation workflows safely.

This is an essential concept for building seamless, fast, modern UI experiences.

---

# 1. Why Optimistic Updates?

### The Core Problem

When a user performs an action like:

* adding an item to cart
* liking a post
* adding a comment
* editing a profile
* updating a todo
* deleting an item

Waiting for the server response causes:

* slow UI
* lag
* poor UX
* “click feels broken” moments

The user expects the interface to update **instantly**.

Optimistic updates solve this.

---

# 2. What Are Optimistic Updates?

Optimistic update means:

```
UI updates first (instantly),
server request happens next,
if success → keep changes,
if failure → rollback to previous state.
```

User feels zero lag.

React Query makes this flow automatic using:

* `onMutate`
* `onError`
* `onSuccess`
* `onSettled`
* `setQueryData`
* rollback functions

---

# 3. When Should You Use Optimistic Updates?

Use optimistic updates when user actions:

* are small and reversible
* benefit from instant feedback
* rarely fail
* modify small portions of data

Examples:

✔ Like/unlike a post
✔ Add/remove item from cart
✔ Toggle todo complete
✔ Delete comment
✔ Update quantity in cart
✔ Insert new post into feed

Do NOT use optimistic updates when:

* expensive or dangerous operations
* payment processing
* irreversible actions
* operations that frequently fail
* backend needs validation before UI change

---

# 4. Analogy

Imagine you hand cash to a shopkeeper for a chocolate.

Optimistic update =
The shopkeeper gives you the chocolate **before** counting the cash.

If there's a mistake, they take the chocolate back.

Same idea:

```
UI gives result instantly.
Server verifies later.
```

---

# 5. Core API for Optimistic Updates

React Query mutation supports:

```jsx
onMutate
onError
onSuccess
onSettled
```

flow:

```
onMutate         → run BEFORE mutationFn
mutationFn       → API request
onError          → if fails → rollback
onSuccess        → refetch/invalidate
onSettled        → always runs
```

---

# 6. Basic Example: Add Todo (Optimistic)

```jsx
const queryClient = useQueryClient();

const mutation = useMutation({
  mutationFn: (newTodo) =>
    fetch("/api/todos", {
      method: "POST",
      body: JSON.stringify(newTodo)
    }),

  onMutate: async (newTodo) => {
    // pause outgoing refetches
    await queryClient.cancelQueries(["todos"]);

    // snapshot current state
    const previousTodos = queryClient.getQueryData(["todos"]);

    // optimistic update
    queryClient.setQueryData(["todos"], (old) => [
      ...old,
      { id: Math.random(), ...newTodo, optimistic: true }
    ]);

    // return rollback function
    return { previousTodos };
  },

  onError: (err, newTodo, context) => {
    // rollback
    queryClient.setQueryData(["todos"], context.previousTodos);
  },

  onSettled: () => {
    // always refetch real data
    queryClient.invalidateQueries(["todos"]);
  }
});
```

This code:

1. Instantly updates UI
2. Sends request
3. Rolls back if error
4. Refetches to sync with real server data

Perfect and safe.

---

# 7. Dry Run of the Example

### 1. User adds a todo → mutation.mutate()

### 2. onMutate runs BEFORE API call

* freeze existing refetches
* save previous state
* insert optimistic todo

UI updates instantly.

### 3. mutationFn runs → API call happens

### 4. onError (if server fails)

* rollback to previousTodos
* UI restores original data

### 5. onSuccess

* real saved todo fetched
* optimistic item replaced

### 6. onSettled

* invalidate queries
* ensure UI syncs with backend

---

# 8. Why Cancel Queries Before Updating?

```jsx
await queryClient.cancelQueries(["todos"]);
```

Without this:

* background refetch may override optimistic data
* race conditions occur
* UI may flicker

Cancelling ensures stability.

---

# 9. Example: Like Button (Simplest Optimistic Update)

```jsx
const mutation = useMutation({
  mutationFn: toggleLike,

  onMutate: async (postId) => {
    await queryClient.cancelQueries(["post", postId]);

    const previous = queryClient.getQueryData(["post", postId]);

    queryClient.setQueryData(["post", postId], (old) => ({
      ...old,
      liked: !old.liked,
      likesCount: old.liked
        ? old.likesCount - 1
        : old.likesCount + 1
    }));

    return { previous };
  },

  onError: (err, variables, context) => {
    queryClient.setQueryData(["post", variables], context.previous);
  },

  onSettled: (data, error, postId) => {
    queryClient.invalidateQueries(["post", postId]);
  }
});
```

This is how:

* Twitter
* Instagram
* YouTube

all implement instant “likes”.

---

# 10. Example: Delete Item (Optimistic)

```jsx
onMutate: async (id) => {
  await queryClient.cancelQueries(["cart"]);

  const previous = queryClient.getQueryData(["cart"]);

  queryClient.setQueryData(["cart"], (old) =>
    old.filter((item) => item.id !== id)
  );

  return { previous };
}
```

Instant delete UI, even before server response.

---

# 11. When NOT to Use Optimistic Updates

Avoid optimistic updates when:

* server strictly validates data
* operations frequently fail
* the cost of mismatch is high
* related data is large or complex
* operation is irreversible

Examples:

* payment checkout
* banking transactions
* backend validation-heavy workflows
* deleting user accounts
* posting irreversible content

These should use:

```
pessimistic updates (wait for success)
```

---

# 12. Handling Error Rollbacks Safely

Rollback strategy:

```jsx
onError: (error, variables, context) => {
  queryClient.setQueryData(queryKey, context.previousState);
}
```

Important:

* context must always return snapshot
* setQueryData restores previous state exactly
* UI remains correct even after failure

---

# 13. Best Practices

## 1. Always snapshot previous data

Use onMutate return value.

## 2. Always cancel running queries

Avoids race conditions.

## 3. Always invalidate after success

Ensures server truth wins.

## 4. Use stable queryKeys

Cache consistency depends on keys.

## 5. Keep optimistic updates small

Do not apply optimistic logic to giant datasets.

## 6. Avoid optimistic updates for complex relational data

Hard to roll back correctly.

## 7. Use unique temporary IDs

Prevent rendering bugs in list UI.

---

# 14. Optimistic Updates vs Pessimistic Updates

| Style       | UI Behavior              | Use Case                   |
| ----------- | ------------------------ | -------------------------- |
| Optimistic  | Instant UI change        | Likes, small edits         |
| Pessimistic | Wait for server response | Payments, critical actions |

---

# 15. React Query Lifecycle for Optimistic Update

```
onMutate → optimistic UI
mutationFn → server request
onError → rollback
onSuccess → refetch or update cache
onSettled → always invalidate
```

---

# 16. Follow-up Questions

1. Why are snapshots (previous data) required for rollback?
2. Why do we call cancelQueries before optimistic updates?
3. What happens if you forget to invalidate queries after success?
4. Why should optimistic updates not be used for critical operations?
5. How does setQueryData enable instant UI updates?
6. How does React Query avoid race conditions?
7. Why should optimistic items have temporary IDs?
8. What is the difference between optimistic and pessimistic updates?
9. When is it better to just refetch instead of doing optimistic updates?
10. Why is mutation context important in rollback logic?
