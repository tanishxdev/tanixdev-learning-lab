# **21.7 Reusable UI Library**

A complete, production-grade explanation of **how to build a reusable UI component library** for React—similar to libraries like Chakra UI, Radix UI, MUI, and internal company design systems—covering architecture, component patterns, build tooling, documentation, versioning, publishing, and real dev workflows.

This chapter focuses on building your own UI library that can be reused across multiple projects or teams.

---

# 1. What Is a Reusable UI Library?

A reusable UI library is a **collection of ready-to-use UI components** that can be imported into any React project:

```
import { Button, Input, Modal } from "@your/ui";
```

It includes:

* foundational components (Button, Input, Select, Card)
* advanced components (Tabs, Accordion, Dropdown, Tooltip)
* patterns (FormField, Layout)
* design tokens (colors, spacing, typography)
* theme support
* accessibility rules
* documentation

A UI library must be:

* consistent
* extensible
* themeable
* stable
* predictable

---

# 2. Why Build a UI Library?

## Reason 1: Reuse across multiple apps

One change updates all projects.

## Reason 2: Consistency

Same look and feel everywhere.

## Reason 3: Faster development

Teams assemble screens, not rewrite buttons.

## Reason 4: Bug fixes roll out globally

Patch one component → fix across apps.

## Reason 5: Easier onboarding

Developers learn your UI primitives once.

## Reason 6: You define your design language

Your buttons, your spacing, your animations.

---

# 3. Architecture of a UI Library (Core Structure)

Recommended folder structure:

```
/ui-library
  /src
    /tokens
      colors.js
      spacing.js
      typography.js
      radii.js

    /components
      Button/
        Button.jsx
        button.css
      Input/
        Input.jsx
      Card/
        Card.jsx
      Modal/
        Modal.jsx
      Tabs/
        Tabs.jsx
        TabsList.jsx
        TabsTrigger.jsx
        TabsContent.jsx

    /patterns
      FormField.jsx
      PageLayout.jsx

    /providers
      ThemeProvider.jsx

    /utils
      classNames.js

  index.js
  package.json
  tsconfig.json
  README.md
```

This structure separates **tokens**, **components**, **patterns**, and **providers**.

---

# 4. Design Tokens (Foundation of the Library)

Tokens control appearance:

### colors.js

```js
export const colors = {
  primary: "#2563eb",
  danger: "#dc2626",
  success: "#16a34a",
  gray100: "#f3f4f6",
  gray900: "#111827"
};
```

### spacing.js

```js
export const spacing = {
  sm: "4px",
  md: "8px",
  lg: "16px"
};
```

### radii.js

```js
export const radii = {
  sm: "4px",
  md: "6px",
  lg: "10px"
};
```

Tokens allow global theming and instant redesigns.

---

# 5. Example: Reusable Button (Professional)

```jsx
import cls from "classnames";

export function Button({
  children,
  variant = "primary",
  size = "md",
  disabled,
  ...props
}) {
  const styles = cls(
    "font-medium rounded-md transition",
    {
      primary: "bg-blue-600 text-white hover:bg-blue-700",
      danger: "bg-red-600 text-white hover:bg-red-700",
      ghost: "bg-transparent text-gray-800 hover:bg-gray-100"
    }[variant],
    {
      sm: "px-2 py-1 text-sm",
      md: "px-4 py-2 text-base",
      lg: "px-6 py-3 text-lg"
    }[size],
    disabled && "opacity-50 cursor-not-allowed"
  );

  return (
    <button className={styles} disabled={disabled} {...props}>
      {children}
    </button>
  );
}
```

This is the real structure of enterprise-grade UI components.

---

# 6. Compound Components in Your Library

Tabs example:

```
<Tabs>
  <Tabs.List>
    <Tabs.Trigger>Overview</Tabs.Trigger>
    <Tabs.Trigger>Billing</Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content>...</Tabs.Content>
</Tabs>
```

This pattern makes the library powerful and flexible.

Your library must support composition over configuration.

---

# 7. Accessibility Built-in

Every component must include:

* ARIA roles
* keyboard navigation
* tab order
* focus rings
* escape key support (modals, menus)
* arrow key support (tabs, dropdowns)

Example:

```jsx
<button role="tab" aria-selected={active}>
```

Without accessibility, the library is incomplete.

---

# 8. Theming System (Light/Dark + Brands)

Use ThemeProvider:

```jsx
import { ThemeProvider } from "styled-components";

<ThemeProvider theme={defaultTheme}>
  <App />
</ThemeProvider>
```

Support multiple themes:

```js
export const darkTheme = {
  colors: { background: "#0f172a", text: "#f1f5f9" }
};
```

Design systems must support theming from day one.

---

# 9. Build Tools for UI Libraries

Use one of:

### 1. **Vite Library Mode**

Fastest, simplest.

### 2. **Rollup**

Most common for libraries (treeshaking, ESM, CJS).

### 3. **tsup**

Minimal configuration, great for TypeScript.

### 4. **Turborepo**

For monorepo with multiple packages.

Your library should output:

* ES module build
* CommonJS build
* Declarations (TypeScript)

---

# 10. Publishing the UI Library

Publish to:

* npm
* private registry
* GitHub Packages
* internal monorepo packages

Example publish steps:

```
npm version patch
npm publish
```

Consumed as:

```
npm install @your/ui
```

---

# 11. Documentation (Critical for a UI Library)

Use **Storybook** or **Ladle**.

Each component needs:

* examples
* props table
* do/don’t usage
* accessibility notes
* theming examples
* code snippets

Storybook improves developer adoption dramatically.

---

# 12. Strict API Design Rules

Your library should follow:

1. **Consistent prop names**
   Example: every component uses `size`, `variant`, `disabled`.

2. **Controlled + Uncontrolled support**
   Example: Input should support both modes.

3. **Minimal props**
   Let composition do the rest.

4. **Stable component signatures**
   Do not break APIs often.

5. **Composable structure**
   Use compound components when needed.

---

# 13. Testing the UI Library

Tests must verify:

* component renders
* variant combinations
* accessibility behavior
* keyboard interactions
* style application
* custom classNames
* controlled/uncontrolled modes

Use:

* Jest
* React Testing Library
* Storybook tests
* Visual regression tests (Chromatic)

---

# 14. Versioning Strategy

Use semantic versioning:

* **patch** → bug fixes
* **minor** → new components or features
* **major** → breaking changes

This is mandatory for reusable libraries.

---

# 15. Real Production Example: Select Component Architecture

Select.jsx:

```jsx
export function Select({ children }) {
  return <div className="relative">{children}</div>;
}
```

Select.Trigger:

```jsx
Select.Trigger = function Trigger({ value, placeholder }) {
  return (
    <button className="border p-2 rounded w-full">
      {value || placeholder}
    </button>
  );
};
```

Select.Menu:

```jsx
Select.Menu = function Menu({ children, open }) {
  if (!open) return null;

  return (
    <div className="absolute mt-1 border bg-white shadow rounded w-full">
      {children}
    </div>
  );
};
```

Select.Option:

```jsx
Select.Option = function Option({ children, onSelect }) {
  return (
    <button onClick={onSelect} className="block w-full text-left p-2 hover:bg-gray-100">
      {children}
    </button>
  );
};
```

Usage:

```jsx
<Select>
  <Select.Trigger value={selected} placeholder="Select item" />
  <Select.Menu open={open}>
    <Select.Option onSelect={() => setSelected("A")}>A</Select.Option>
    <Select.Option onSelect={() => setSelected("B")}>B</Select.Option>
  </Select.Menu>
</Select>
```

This is exactly how professional UI libraries build components.

---

# 16. Follow-up Questions

1. Will your UI library be used across multiple projects or only one?
2. Do you prefer Tailwind-based components or styled-components-based?
3. Should your library support dark mode and multiple brand themes?
4. Which core components should be built first?
5. Do you want compound components for Tabs/Modal/Dropdown/Select?
6. Should your library integrate with your Design System tokens?
7. Will you publish the library on npm or keep it internal?
8. Do you want Storybook documentation built automatically?
9. How strict should versioning and breaking changes be handled?
10. Do you want real-world examples for complex components like Table, DatePicker, or Pagination?
