# **21.6 Building a Design System**

A complete, production-grade explanation of **how to architect a real Design System for a React application**, including tokens, components, patterns, accessibility rules, theming, dark mode, composition, documentation, and versioning.
This is the same approach used by professional teams at Stripe, Shopify, GitHub, and Vercel.

A Design System is not just UI components.
It is a **scalable architecture** for building consistent products.

---

# 1. What Is a Design System?

A Design System is a structured collection of:

* **Design tokens** (colors, spacing, typography, radii)
* **Reusable components** (Button, Input, Modal, Tabs)
* **Interaction patterns** (loading, errors, focus, keyboard behavior)
* **Layout guidelines** (grid, spacing, responsiveness)
* **Documentation** (usage rules, do/don’t)
* **Accessibility standards**

A Design System ensures:

* visual consistency
* engineering consistency
* faster development
* easier maintenance
* better UX
* shared language for designers + developers

---

# 2. Why Do We Build a Design System?

### Reason 1: Consistency across the whole product

Every page uses the same rules.

### Reason 2: Faster development

Stop rewriting the same Button 50 times.

### Reason 3: Scalability

New team members onboard faster.

### Reason 4: Accessibility baked in

Components follow ARIA + keyboard patterns.

### Reason 5: Easy redesigns

Update tokens, entire product updates.

### Reason 6: Reduces tech debt

Clear patterns = fewer bugs.

Large apps cannot scale without a Design System.

---

# 3. The Three Layers of a Design System

A modern design system consists of:

## Layer 1 — **Tokens**

Foundation rules for styling.

## Layer 2 — **Components**

Reusable UI pieces.

## Layer 3 — **Patterns**

How components work together.

Illustration:

```
Tokens → Components → Patterns → Screens
```

---

# 4. Layer 1: Design Tokens (The Foundation)

Tokens are **atomic design values**.

### Colors

```js
export const colors = {
  primary: "#2563eb",
  danger: "#dc2626",
  gray100: "#f3f4f6",
  gray900: "#111827"
};
```

### Spacing

```js
export const spacing = {
  xs: "4px",
  sm: "8px",
  md: "16px",
  lg: "24px"
};
```

### Typography

```js
export const typography = {
  h1: "24px",
  body: "16px",
  small: "14px"
};
```

### Radii

```js
export const radii = {
  sm: "4px",
  md: "6px",
  lg: "10px"
};
```

Tokens ensure global consistency.

---

# 5. Layer 2: Components (The Building Blocks)

Examples of core components:

* Button
* Input
* Select
* Checkbox
* Switch
* Modal
* Card
* Tooltip
* Tabs

Every component must follow:

1. **consistent API**
2. **scalable variants**
3. **predictable behavior**
4. **accessible patterns**
5. **theme-aware styling**

Example Button:

```jsx
export function Button({ children, variant = "primary", ...props }) {
  return (
    <button
      className={`px-4 py-2 rounded-md text-white ${
        variant === "primary" ? "bg-blue-600" : "bg-gray-600"
      }`}
      {...props}
    >
      {children}
    </button>
  );
}
```

---

# 6. Layer 3: Patterns (The Real Power)

Patterns define **common UI flows**, not just components.

Examples:

* **Form layout**: Label → Input → Helper → Error
* **Modal pattern**: Header → Body → Footer
* **Card layout**: Title → Description → Actions
* **Page layout**: Sidebar → Header → Content
* **Filter panels**
* **Data tables**

Patterns guarantee consistency across screens.

---

# 7. Folder Structure for a Design System

Recommended structure:

```
/design-system
  /tokens
     colors.js
     spacing.js
     typography.js
     radii.js

  /components
     Button.jsx
     Input.jsx
     Card.jsx
     Modal.jsx
     Tabs/
       Tabs.jsx
       TabsList.jsx
       TabsTrigger.jsx
       TabsContent.jsx

  /patterns
     FormField.jsx
     PageLayout.jsx

  /providers
     ThemeProvider.jsx

  /utils
     classNames.js

  index.js
```

This structure is clean and modular.

---

# 8. How Styling Integrates with Design Systems

You can build a design system with:

* Tailwind CSS
* Styled-components
* CSS Modules
* Emotion
* Vanilla CSS

The system remains the same: tokens + components + patterns.

### Styled-components Example

```jsx
const Box = styled.div`
  padding: ${(p) => p.theme.spacing.md};
  background: ${(p) => p.theme.colors.primary};
`;
```

### Tailwind Example

```jsx
<div className="p-4 bg-blue-600">...</div>
```

Tailwind design systems use Tailwind config as tokens.

---

# 9. Theming (Light, Dark, Brand Themes)

Use ThemeProvider:

```jsx
export const theme = {
  colors,
  spacing,
  typography,
  radii
};
```

Wrap app:

```jsx
<ThemeProvider theme={theme}>
  <App />
</ThemeProvider>
```

Dark mode theme:

```js
export const darkTheme = {
  colors: {
    primary: "#3b82f6",
    background: "#0f172a",
    text: "#f1f5f9"
  }
};
```

Switch themes:

```jsx
<ThemeProvider theme={isDark ? darkTheme : lightTheme}>
```

---

# 10. Accessibility Built Into Components

Design system components must include:

* ARIA attributes
* proper roles
* keyboard navigation
* focus ring
* skip links for forms
* semantic elements

Example for Button:

```jsx
<button aria-label="Save Changes">Save</button>
```

Accessibility cannot be optional.

---

# 11. Variants Pattern (Core for Scalable Components)

Variant-based styling:

```jsx
export function Button({ variant = "primary", size = "md", ...props }) {
  const styles = {
    primary: "bg-blue-600 text-white",
    danger: "bg-red-600 text-white",
    ghost: "bg-transparent text-gray-800"
  };

  const sizes = {
    sm: "px-2 py-1",
    md: "px-4 py-2",
    lg: "px-6 py-3"
  };

  return (
    <button className={`${styles[variant]} ${sizes[size]}`} {...props} />
  );
}
```

Variant system must be:

* predictable
* minimal
* scalable

---

# 12. Composition in the Design System

Components must be composable:

```jsx
<Modal>
  <Modal.Header />
  <Modal.Body />
  <Modal.Footer />
</Modal>
```

This enables UX consistency.

---

# 13. Documentation (Critical for Teams)

A design system is only effective if documented.

Documentation includes:

* usage examples
* API references
* code snippets
* do/don’t guidelines
* accessibility notes
* prop tables

Tools for documentation:

* Storybook
* Ladle
* Docs site using Next.js

This is how teams onboard fast.

---

# 14. Versioning the Design System

You should version your design system like a library:

* patch updates for small changes
* minor updates for new components
* major updates for breaking changes

This allows continuous improvement without breaking apps.

---

# 15. Real Production Example: Card System

Base Card:

```jsx
function Card({ children }) {
  return (
    <div className="p-4 bg-white shadow rounded-md">
      {children}
    </div>
  );
}
```

Card.Title:

```jsx
Card.Title = ({ children }) => (
  <h2 className="text-lg font-semibold">{children}</h2>
);
```

Card.Body:

```jsx
Card.Body = ({ children }) => (
  <p className="text-gray-600 mt-2">{children}</p>
);
```

Card.Actions:

```jsx
Card.Actions = ({ children }) => (
  <div className="mt-4 flex gap-2">{children}</div>
);
```

Usage:

```jsx
<Card>
  <Card.Title>Product A</Card.Title>
  <Card.Body>Description goes here.</Card.Body>
  <Card.Actions>
    <Button>Edit</Button>
    <Button variant="danger">Delete</Button>
  </Card.Actions>
</Card>
```

This is how real design systems are built at scale.

---

# 16. Follow-up Questions

1. Will your design system use Tailwind, Styled-components, or both?
2. Do you need light/dark themes or brand-level themes?
3. Which base components should be built first (Button, Input, Modal)?
4. Will your UI library expose compound components?
5. Do you need a tokens system for typography, spacing, and colors?
6. Should your system support multiple app teams?
7. Does your product require internationalization-aware components?
8. Should you add accessibility testing for your design system?
9. Do you want Storybook integration for documenting components?
10. Should your design system be versioned as a separate package?
