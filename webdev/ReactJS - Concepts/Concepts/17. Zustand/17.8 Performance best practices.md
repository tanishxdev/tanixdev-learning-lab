# 17.8 Performance Best Practices (Zustand)

A complete, production-level guide focused on **making Zustand fast at scale**, preventing unnecessary re-renders, using selectors correctly, structuring stores for speed, and avoiding anti-patterns.

This is the equivalent of “React Performance Deep Dive” but for Zustand.

---

# 1. Why Performance Matters in Zustand?

Zustand is fast by default, but developers often break performance because they:

* Subscribe to too much state
* Use one large store
* Recreate objects in selectors
* Mix UI + business logic
* Store derived values
* Use deep nesting
* Update many fields unnecessarily
* Misuse persist/devtools middleware

Goal:

```
Minimize re-renders.
Maximize predictable updates.
Keep store logic flat, efficient, and clean.
```

Zustand is capable of *extremely fine-grained reactivity* — but only if you use it correctly.

---

# 2. How Zustand Rendering Works Internally (Important)

When a component does:

```jsx
const count = useStore((state) => state.count);
```

Zustand:

1. Subscribes the component **only** to `state.count`
2. After every store update, compares previous vs next selected value (shallow compare)
3. Re-renders the component **only if that value changed**
4. Ignores all other state changes

This is the secret to Zustand’s high performance.

Your job:
Make sure your selectors and store design allow this fine-grained reactivity.

---

# 3. Performance Principle #1

## Always Use Selectors — Never Read Whole Store

Bad:

```jsx
const store = useUserStore();
```

This causes:

* Re-render on **ANY** state update
* Same problem as React Context
* Terrible scalability

Good:

```jsx
const user = useUserStore((s) => s.user);
```

Better:

```jsx
const name = useUserStore((s) => s.user.name);
```

Granular subscriptions = minimal re-renders.

---

# 4. Performance Principle #2

## Split Stores by Domain (Small, Fast Stores)

Bad:

```jsx
const useStore = create((set) => ({
  user: {},
  cart: [],
  products: [],
  modalOpen: false,
  sidebarOpen: false
}));
```

One change anywhere → many components re-render.

Good:

```
uiStore.js
authStore.js
cartStore.js
productStore.js
filterStore.js
```

Separate stores = isolated updates = faster UI.

Zustand makes this easy — use it.

---

# 5. Performance Principle #3

## Keep Store State Flat (Avoid Deep Nesting)

Bad:

```jsx
user: {
  profile: {
    info: {
      name: "Tanish"
    }
  }
}
```

Each nested update:

* Requires deep copy (even if using Immer)
* Creates more re-renders
* Harder to manage

Good:

```jsx
user: {
  name: "Tanish",
  age: 20
}
```

Flat state = faster updates, easier debugging.

---

# 6. Performance Principle #4

## Derived State Should Not Be Stored

Bad:

```jsx
totalPrice: items.reduce(...),
```

Why bad?

* Recomputes on every unrelated update
* Duplicates data
* Harder to keep in sync
* Causes more re-renders

Good:

```jsx
const totalPrice = useCartStore((s) =>
  s.items.reduce((sum, item) => sum + item.price * item.qty, 0)
);
```

Derived state should be computed **inside selectors**, not stored.

---

# 7. Performance Principle #5

## Do Not Return New Objects in Selectors

Bad:

```jsx
useStore((s) => ({ name: s.user.name }))
```

This always creates a **new object** → always re-renders.

Good:

```jsx
useStore((s) => s.user.name);
```

If you must select multiple fields:

Use shallow comparison:

```jsx
import { shallow } from "zustand/shallow";

useStore((s) => ({ a: s.a, b: s.b }), shallow);
```

Now components re-render only if a or b actually changed.

---

# 8. Performance Principle #6

## Do Not Store UI State With Business Data

Bad:

```jsx
useStore = create((s) => ({
  modalOpen: false,
  theme: "light",
  user: {},
  cart: []
}));
```

Updating UI → re-renders business components.
Updating business → re-renders UI components.

Good:

```
uiStore.js
business stores (auth, cart, products)
```

Separation = better render isolation.

---

# 9. Performance Principle #7

## Avoid Large Objects/Arrays Unless Needed

Large arrays inside Zustand:

* Slow down updates
* More expensive shallow compares

Better:

* Use pagination
* Use React Query for server data
* Normalize data when possible

Zustand is best for **client-side, small-to-medium data**.

---

# 10. Performance Principle #8

## Use Middleware Carefully (Persist, Devtools)

### Persist

Avoid persisting:

* large arrays
* server responses
* sensitive data

Persist only:

* theme
* UI preferences
* last opened state
* minimal essential config

### Devtools

Good for debugging, but use **only in development**.

It adds overhead in production.

---

# 11. Performance Principle #9

## Avoid Storing Functions Inside State (Unless They Are Actions)

Zustand stores sometimes put functions inside state (actions).

This is fine:

```jsx
increment: () => set(...)
```

But avoid:

```jsx
state: {
  filters: {
    apply: () => {...}  // bad
  }
}
```

Nested functions cause unnecessary object recreation and deeper subscription trees.

---

# 12. Performance Principle #10

## Use subscribeWithSelector for External Logic

Example:

```jsx
useCartStore.subscribe(
  (s) => s.items.length,
  (len) => {
    if (len > 10) console.log("Big cart");
  }
);
```

Keep heavy logic **outside components** to keep the UI fast.

---

# 13. Performance Principle #11

## Keep Updates Minimal

Bad:

```jsx
set({
  items: [...items], 
  user: {...user}, 
  theme: "dark"
});
```

Updating unrelated fields triggers extra work.

Good:

Update only what changed:

```jsx
set((s) => ({ items: [...s.items, item] }));
```

Minimal updates = minimal re-renders.

---

# 14. Performance Principle #12

## Avoid “One Global Store” Anti-Pattern

People sometimes assume “Zustand is one store per app”.
Incorrect and leads to performance collapse.

Correct:

Zustand supports **any number of stores**.

Use:

* one store per domain
* one store per UI cluster
* one store per complex feature

More stores = more isolation = more performance.

---

# 15. Summary of Performance Rules (Quick Table)

| Rule                                 | Benefit                         |
| ------------------------------------ | ------------------------------- |
| Use selectors                        | Prevent unnecessary re-renders  |
| Split stores by domain               | Better isolation                |
| Keep state flat                      | Faster updates                  |
| Don't store derived values           | Prevent double updates          |
| Use shallow comparison               | Reduce re-renders               |
| Avoid object selectors               | Prevent new-reference rerenders |
| Use middleware smartly               | Avoid overhead                  |
| Avoid giant stores                   | Maintain clarity & speed        |
| Minimal updates                      | Better performance              |
| Subscribe externally for heavy logic | Keeps component tree light      |

---

# 16. Example of Highly Optimized Store

```jsx
import { create } from "zustand";
import { shallow } from "zustand/shallow";

export const useCartStore = create((set) => ({
  items: [],

  addItem: (item) =>
    set((s) => ({ items: [...s.items, item] })),

  removeItem: (id) =>
    set((s) => ({ items: s.items.filter((i) => i.id !== id) })),

  clear: () => set({ items: [] })
}));

// Fine-grained consumption
export const useCartCount = () =>
  useCartStore((s) => s.items.length);

export const useCartTotal = () =>
  useCartStore(
    (s) => s.items.reduce((sum, i) => sum + i.price * i.qty, 0),
    shallow
  );
```

This design:

* Reduces re-renders
* Uses derived selectors
* Uses shallow compares
* Keeps business logic inside actions
* Uses minimal state

---

# 17. Follow-up Questions

1. Why do selectors drastically improve Zustand performance?
2. When should you use shallow comparison?
3. Why must derived values not be stored in Zustand?
4. Why is flat state faster than nested state?
5. When does one large store become a bottleneck?
6. Why should UI state be separated from business state?
7. Why is object selector always a bad idea unless shallow is used?
8. When should you switch to React Query instead of Zustand?
9. How do subscribeWithSelector patterns help reduce re-renders?
10. Which performance mistakes cause full-app re-rendering?
