# 17.7 Zustand Architecture

A complete, deep, production-level explanation of **how to architect Zustand in real projects**, how to scale it, how to organize files, and how to avoid anti-patterns.

This chapter answers the real question:
**“How do I use Zustand in a clean, scalable way in a real app?”**

---

# 1. Why “Architecture” Matters in Zustand?

### The core problem

Zustand is extremely flexible.
Beginners often make mistakes:

* One giant store containing everything
* Scattered store files
* UI and business logic mixed
* No naming conventions
* Nested objects causing slow updates
* Hard-to-scale store structure
* No separation of domain stores
* No middleware-driven organization

Zustand gives freedom.
Architecture ensures **long-term maintainability**.

---

# 2. What Architecture Means Here

Architecture =

* How many stores you should have
* How to group state logically
* How to structure files
* How to separate UI state vs business state
* How to use selectors
* How to integrate middleware
* How to scale to multiple features
* How to keep logic clean and predictable

Zustand architecture is **feature-driven**, NOT Redux-style strict.

---

# 3. Architecture Goals

A good Zustand architecture must:

1. Prevent unnecessary re-renders
2. Have clear domain separation
3. Keep stores flat
4. Avoid mixing UI + business logic
5. Keep async logic contained
6. Use selector-based patterns
7. Be easy for multiple devs to understand
8. Support long-term maintainability
9. Allow middleware-based enhancements

---

# 4. High-Level Architecture Diagram

```
src/
 └── stores/
      ├── ui/
      │    ├── modalStore.js
      │    ├── themeStore.js
      │    └── sidebarStore.js
      │
      ├── features/
      │    ├── authStore.js
      │    ├── cartStore.js
      │    ├── productStore.js
      │    └── filterStore.js
      │
      ├── shared/
      │    ├── networkStore.js
      │    └── appStore.js
      │
      └── middleware/
           ├── persistedStore.js
           ├── devtoolsWrapper.js
           └── immerWrapper.js
```

This structure supports scalability similar to a **mini Redux slices**, but with Zustand simplicity.

---

# 5. The Most Important Rule: Split by Domain, Not by Type

Do NOT do this:

```
bad/
 ├── state.js
 ├── actions.js
 ├── async.js
 ├── selectors.js
```

This is a Redux anti-pattern when applied to Zustand.

Do this instead:

### Split stores by feature (domain architecture)

```
features/
 ├── authStore.js
 ├── cartStore.js
 ├── productStore.js
```

Business logic remains grouped by business domain.

---

# 6. Architecture Principle #1

## UI State and Business State Must Not Mix

Bad:

```jsx
useStore = create((set) => ({
  user: null,
  cart: [],
  modalOpen: false,
  theme: "light"
}));
```

Problems:

* UI triggers might re-render business components
* State becomes unmanageable
* Middleware becomes confusing

Good:

### uiStore.js

```jsx
export const useUIStore = create((set) => ({
  modalOpen: false,
  sidebarOpen: false,
  theme: "light",
  toggleModal: () => set((s) => ({ modalOpen: !s.modalOpen }))
}));
```

### cartStore.js

```jsx
export const useCartStore = create((set) => ({
  items: [],
  addItem: (item) => set((s) => ({ items: [...s.items, item] })),
}));
```

Each domain owns its logic.

---

# 7. Architecture Principle #2

## Keep Store Flat — No Deep Nesting

Bad:

```jsx
user: {
  profile: {
    address: { city: "Delhi", pin: 110001 }
  }
}
```

Updating deep objects causes:

* Complex update logic
* Slow re-renders
* Hard to maintain
* Too much usage of immer

Good:

```jsx
user: {
  name: "Tanish",
  city: "Delhi",
  pin: 110001
}
```

Flat state improves:

* performance
* readability
* mutation simplicity

---

# 8. Architecture Principle #3

## Selectors Everywhere (Never Use The Whole Store)

Bad:

```jsx
const store = useUserStore(); 
```

Re-renders on ANY change.

Good:

```jsx
const user = useUserStore((s) => s.user);
const login = useUserStore((s) => s.login);
```

State granularity = performance.

This prevents global re-rendering.

---

# 9. Architecture Principle #4

## Use Middlewares Strategically

### UI state → persist

### Debugging → devtools

### Complex nested state → immer

### Event triggers → subscribeWithSelector

Architecture uses middleware **to enhance**, not to complicate.

---

# 10. Architecture Principle #5

## Use One Store Per Feature (Domain-Driven)

Examples:

### authStore.js

```jsx
export const useAuthStore = create((set) => ({
  user: null,
  login: (user) => set({ user }),
  logout: () => set({ user: null })
}));
```

### productStore.js

```jsx
export const useProductStore = create((set) => ({
  products: [],
  fetchProducts: async () => {
    const res = await fetch("/api/products");
    set({ products: await res.json() });
  }
}));
```

### filterStore.js

```jsx
export const useFilterStore = create((set) => ({
  category: "all",
  setCategory: (c) => set({ category: c })
}));
```

Each store manages its domain.

---

# 11. Architecture Principle #6

## Separation of Responsibilities

Store contains:

* state
* actions
* async logic
* simple business logic

NOT:

* UI code
* Derived calculations (selectors should handle this)
* Constant transformations
* Server cache logic (React Query better)

---

# 12. Architecture Principle #7

## Use Derived Selectors, Not Derived State

Bad:

```jsx
totalPrice: items.reduce(...)
```

This stores derived data and leads to bugs.

Good:

```jsx
const totalPrice = useCartStore((s) =>
  s.items.reduce((sum, item) => sum + item.price * item.qty, 0)
);
```

Keep store data raw.
Compute derived values in selectors.

---

# 13. Example: Well-Architected Zustand Store

### /stores/authStore.js

```jsx
import { create } from "zustand";
import { persist } from "zustand/middleware";

export const useAuthStore = create(
  persist(
    (set, get) => ({
      user: null,
      loading: false,
      error: null,

      login: async (credentials) => {
        set({ loading: true });
        try {
          const res = await fetch("/api/login", {
            method: "POST",
            body: JSON.stringify(credentials)
          });
          const data = await res.json();
          set({ user: data.user, loading: false });
        } catch (err) {
          set({ error: "Login failed", loading: false });
        }
      },

      logout: () => set({ user: null })
    }),
    { name: "auth-storage" }
  )
);
```

This is production-ready.

---

# 14. Architecture Principle #8

## UI and Business Stores may interact, but never merge

Example:

Modal affects product filtering:

```jsx
const toggleModal = useUIStore((s) => s.toggleModal);
const setCategory = useFilterStore((s) => s.setCategory);
```

Interaction is allowed.
Mixing them into one store is not.

---

# 15. Multi-Store Architecture (Highly Recommended)

```
src/stores/

ui/
 ├─ modalStore.js
 ├─ themeStore.js

features/
 ├─ authStore.js
 ├─ cartStore.js
 ├─ productStore.js
 ├─ filterStore.js

shared/
 ├─ connectionStore.js
 ├─ appStore.js
```

This is scalable across teams and features.

---

# 16. When Zustand Architecture Fails

Zustand fails for:

* Large enterprise apps
* 50+ domain stores
* Massive business data relationships
* Complex async workflows
* Server-side caching
* Normalization across domains
* Undo/redo workflows
* Multi-team scale

At that point → **Redux Toolkit + RTK Query** is superior.

Zustand is not meant to replace Redux in enterprise scale.

---

# 17. Common Architecture Mistakes

1. One giant store for everything
2. No selectors → global re-renders
3. Using Zustand as server cache
4. Deeply nested state
5. Storing derived values
6. No folder structure
7. UI + business logic mixed
8. Overusing middleware
9. Heavy async logic inside multiple stores
10. Not splitting domain stores

These mistakes kill scalability.

---

# 18. Best Practices Summary

1. Split stores by feature/domain
2. Keep state flat
3. Use selectors always
4. Keep async logic inside store
5. Use middleware only where needed
6. Don’t store derived values
7. Multiple stores > One giant store
8. UI state + business state must be separate
9. Use React Query for server data
10. Use selectors for derived calculations

---

# 19. Follow-up Questions

1. Why is domain-driven structure important in Zustand?
2. Why must UI state be separated from business state?
3. When is a single store architecture harmful?
4. How does Zustand prevent global re-renders?
5. Why should derived values not be stored in Zustand?
6. What middleware suits which architectural need?
7. When should Redux replace Zustand in large apps?
8. How do selectors fit into Zustand architecture?
9. Why should state be flat in Zustand?
10. How to scale Zustand in a multi-developer project?
