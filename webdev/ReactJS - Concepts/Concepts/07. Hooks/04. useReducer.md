# useReducer Hook – Deep, Clear & Practical Understanding

Think of **useReducer as the BIG BROTHER of useState**.

When state logic becomes complex, useState becomes messy.
useReducer brings **structure and control**.

---

## 1️⃣ Why useReducer Exists (Problem First)

With useState, complex logic looks like this:

```jsx
const [count, setCount] = useState(0);

setCount(count + 1);
setCount(count - 1);
setCount(count * 2);
```

Now imagine:

- 10 different state changes
- Many conditions
- Different actions

Code becomes:

- Hard to read
- Hard to debug
- Error-prone

This is where useReducer is needed.

---

## 2️⃣ Simple Definition

> useReducer manages state using a fixed logic system based on actions.

Instead of:

```
setState(value)
```

You say:

```
dispatch({ type: "INCREMENT" })
```

And a special function decides what to do.

---

## 3️⃣ Real-world analogy

useState:
You directly change things yourself.

useReducer:
You give instructions to a manager:
"Increase", "Decrease", "Reset"

Manager decides HOW to update.

---

## 4️⃣ Basic Structure of useReducer

```js
const [state, dispatch] = useReducer(reducerFunction, initialState);
```

Parts:

- state → current value
- dispatch → sends action
- reducer → brain of logic

---

# useReducer Core Concept

```
UI → dispatch(action) → reducer → newState → UI update
```

Everything flows predictably.

---

# Progressive Examples

We will start simple and increase level.

---

## ✅ Example 1: Simple Counter using useReducer

### Concept: Same counter but structured

### Example1_ReducerCounter.jsx

```jsx
import { useReducer } from "react";

// Reducer function
// This is a PURE function:
// - It does NOT modify state directly
// - It returns a NEW state based on action
function reducer(state, action) {
  // If action type is "increment"
  if (action.type === "increment") {
    // Return new state (old state + 1)
    return state + 1;
  }

  // If action type is "decrement"
  if (action.type === "decrement") {
    // Return new state (old state - 1)
    return state - 1;
  }

  // IMPORTANT:
  // If action type does not match anything,
  // always return current state to avoid breaking React
  return state;
}

function Example1_ReducerCounter() {
  // useReducer returns:
  // count    -> current state value
  // dispatch -> function to send actions to reducer
  // reducer  -> logic controller
  // 0        -> initial state
  const [count, dispatch] = useReducer(reducer, 0);

  return (
    <div>
      <h3>useReducer Counter</h3>

      {/* Display current state */}
      <p>Count: {count}</p>

      {/* Increment button */}
      {/* On click, we DISPATCH an action object */}
      <button onClick={() => dispatch({ type: "increment" })}>+</button>

      {/* Decrement button */}
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
    </div>
  );
}

export default Example1_ReducerCounter;
```

#### Dry Run — `useReducer` Counter Flow

**Initial Render**

1. `useReducer(reducer, 0)` is executed.
2. `count = 0`
3. `dispatch = function reference`
4. UI shows: `Count: 0`

---

**When `+` button is clicked (Increment)**

1. `onClick` runs → `dispatch({ type: "increment" })`
2. React calls: `reducer(currentState, action)`
   - `state = 0`
   - `action = { type: "increment" }`

3. Inside reducer:
   - `action.type === "increment"` → `return state + 1`
   - Returns `1`

4. React updates state:
   - `count = 1`

5. Component re-renders.
6. UI shows: `Count: 1`

---

**When `+` button is clicked again**

1. `dispatch({ type: "increment" })`
2. Reducer receives:
   - `state = 1`

3. Returns `2`
4. React updates:
   - `count = 2`

5. UI shows: `Count: 2`

---

**When `-` button is clicked (Decrement)**

1. `dispatch({ type: "decrement" })`
2. Reducer receives:
   - `state = 2`
   - `action = { type: "decrement" }`

3. Inside reducer:
   - `action.type === "decrement"` → `return state - 1`
   - Returns `1`

4. React updates:
   - `count = 1`

5. UI shows: `Count: 1`

---

**If an unknown action is dispatched**

1. Example: `dispatch({ type: "reset" })`
2. Reducer receives:
   - `state = current value`

3. No `if` condition matches.
4. `return state`
5. React keeps state unchanged.
6. UI remains same (no crash).

---

**Core Mental Model**

- UI **never changes state directly**
- Button → `dispatch(action)`
- `dispatch` → calls `reducer(oldState, action)`
- `reducer` → returns **new state**
- React → re-renders with new state

If you want:

- same dry run but **step-by-step call stack**
- or compare this with `useState` internally
- or debug a wrong reducer example

### Flow:

Click "+"
→ dispatch({type:"increment"})
→ reducer runs
→ updates state
→ UI re-renders

---

## ✅ Example 2: Multi-action State (Real Logic)

### Concept: Bank Account Simulation

### Example2_Bank.jsx

```jsx
import { useReducer } from "react";

function bankReducer(state, action) {
  switch (action.type) {
    case "deposit":
      return { balance: state.balance + 100 };

    case "withdraw":
      return { balance: state.balance - 100 };

    case "reset":
      return { balance: 0 };

    default:
      return state;
  }
}

function Example2_Bank() {
  const [state, dispatch] = useReducer(bankReducer, { balance: 0 });

  return (
    <div>
      <h3>Bank Account</h3>
      <p>Balance: ₹{state.balance}</p>

      <button onClick={() => dispatch({ type: "deposit" })}>
        Deposit ₹100
      </button>

      <button onClick={() => dispatch({ type: "withdraw" })}>
        Withdraw ₹100
      </button>

      <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
    </div>
  );
}

export default Example2_Bank;
```

This is realistic:

- Payment apps
- Wallet systems
- Finance apps

---

## ✅ Example 3: Form with Multiple Fields

### Concept: Managing 3 fields with single reducer

```jsx
import { useReducer } from "react";

const initialState = {
  name: "",
  email: "",
  age: "",
};

function formReducer(state, action) {
  return {
    ...state,
    [action.field]: action.value,
  };
}

function Example3_Form() {
  const [form, dispatch] = useReducer(formReducer, initialState);

  return (
    <div>
      <h3>Form using useReducer</h3>

      <input
        placeholder="Name"
        value={form.name}
        onChange={(e) => dispatch({ field: "name", value: e.target.value })}
      />

      <input
        placeholder="Email"
        value={form.email}
        onChange={(e) => dispatch({ field: "email", value: e.target.value })}
      />

      <input
        placeholder="Age"
        value={form.age}
        onChange={(e) => dispatch({ field: "age", value: e.target.value })}
      />

      <p>{JSON.stringify(form)}</p>
    </div>
  );
}

export default Example3_Form;
```

Used in:

- Login forms
- Registration panels
- Multi-field data systems

---

# Connecting to App.jsx

```jsx
import Example1_ReducerCounter from "./components/Example1_ReducerCounter";
import Example2_Bank from "./components/Example2_Bank";
import Example3_Form from "./components/Example3_Form";

function App() {
  return (
    <div>
      <h1>useReducer Examples</h1>

      <Example1_ReducerCounter />
      <hr />

      <Example2_Bank />
      <hr />

      <Example3_Form />
    </div>
  );
}

export default App;
```

---

# When to use useReducer instead of useState?

Use useReducer when:

- Many state transitions
- Complex logic
- Multiple conditions
- Predictable flow required

Use useState when:

- Simple isolated state

---

## Quick Comparison

| useState      | useReducer         |
| ------------- | ------------------ |
| Easy          | Structured         |
| Simple        | Scalable           |
| Direct update | Action-based logic |

---

# Mental Model

```
useState → small memory
useReducer → organised control system
```

---

## Quick Check (to confirm understanding)

Which is more suitable for complex logic?

A) useState
B) useReducer
