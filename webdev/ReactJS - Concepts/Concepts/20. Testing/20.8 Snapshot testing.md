# **20.8 Snapshot Testing**

A complete, production-grade explanation of **Snapshot Testing in Jest + React**, why it exists, when to use it, when NOT to use it, how snapshots are stored, how updates work, and how to integrate snapshot tests correctly into a real React project without overusing them.

Snapshot testing is powerful when used correctly and dangerous when used incorrectly.
This chapter teaches the exact way professionals use snapshots.

---

# 1. What Is Snapshot Testing?

Snapshot testing captures a **serialized version of rendered UI** and stores it in a file.

Example:

```jsx
expect(component).toMatchSnapshot();
```

Jest generates a `.snap` file containing the rendered output.

Next time the test runs:

* Jest re-renders the component
* Compares with the existing snapshot
* Fails if anything changed

Snapshots detect **unexpected UI changes**.

---

# 2. Why Snapshot Testing Exists

Snapshot testing helps catch:

* accidental UI changes
* breaking layout modifications
* unintended DOM changes
* regressions caused by refactoring
* changes in data-driven UI structures

Snapshots are especially useful for:

* stable, static UI
* components with many props
* formatting functions
* configuration objects

Snapshots provide a **baseline contract** for what UI should look like.

---

# 3. How Snapshot Files Work

When you run a snapshot test:

1. Jest serializes the rendered output
2. Stores it in a `.snap` file inside `__snapshots__` folder
3. Future test runs compare current output to stored snapshot

File structure example:

```
MyComponent.test.js
__snapshots__/
   MyComponent.test.js.snap
```

Snapshots are version-controlled and must be reviewed like code.

---

# 4. Writing Your First Snapshot Test

Component:

```jsx
function Greeting({ name }) {
  return <h1>Hello {name}</h1>;
}
```

Test:

```jsx
import { render } from "@testing-library/react";

test("Greeting matches snapshot", () => {
  const { container } = render(<Greeting name="Tanish" />);
  expect(container).toMatchSnapshot();
});
```

Jest produces a snapshot of the DOM output.

---

# 5. Updating Snapshots

If a snapshot is outdated because UI changed intentionally:

Run:

```
npm test -- -u
```

or:

```
jest -u
```

This updates the `.snap` file.

Snapshots should never be updated blindly.
Review changes carefully before updating.

---

# 6. When NOT to Use Snapshot Testing

Snapshot testing is **not** suitable for:

1. highly dynamic components
2. components with rapidly changing UI
3. verifying text values
4. verifying behavior
5. testing interactions
6. components with large DOM trees
7. components influenced by time or random values

Snapshots should stay small and meaningful.

---

# 7. Snapshot Testing Anti-Pattern (Most Common Mistake)

Bad test:

```jsx
expect(container).toMatchSnapshot();
```

for a large component with:

* loops
* dynamic content
* conditional rendering
* random values
* async content

This makes snapshots fragile and meaningless.

Good snapshots are **small**.

---

# 8. Good Snapshot Use-Cases (Real-world)

### Case 1: UI that changes rarely

Example: Branding elements

```jsx
<Logo />
```

### Case 2: Helper functions producing structured output

Example:

```jsx
expect(formatConfig(obj)).toMatchSnapshot();
```

### Case 3: simple presentational components

Card components
Typography components
Reusable layout wrappers

Snapshots protect against accidental DOM changes.

---

# 9. Snapshot Testing with Props Variations

Component:

```jsx
function Card({ title, subtitle }) {
  return (
    <div className="card">
      <h1>{title}</h1>
      <p>{subtitle}</p>
    </div>
  );
}
```

Test:

```jsx
test("Card snapshot", () => {
  const { container } = render(
    <Card title="Hello" subtitle="Subtitle" />
  );
  expect(container).toMatchSnapshot();
});
```

If the Card component changes structure or styling classes, snapshot test will fail.

---

# 10. Inline Snapshot Testing

Instead of using `.snap` files, Jest can embed snapshot inside the test:

```js
expect(container.firstChild).toMatchInlineSnapshot(`
  <div>
    Hello
  </div>
`);
```

Inline snapshots:

* are reviewed instantly
* useful for small components
* make tests self-contained

---

# 11. Snapshot Testing for Utility Functions

Example utility:

```jsx
export function format(user) {
  return {
    id: user.id,
    full: `${user.first} ${user.last}`
  };
}
```

Test:

```jsx
expect(format({ first: "John", last: "Doe", id: 1 }))
  .toMatchSnapshot();
```

Snapshots are effective for complex structured objects.

---

# 12. Snapshot Testing Components with Children

Component:

```jsx
function Wrapper({ children }) {
  return <section className="box">{children}</section>;
}
```

Test:

```jsx
test("wrapper snapshot", () => {
  const { container } = render(
    <Wrapper>
      <p>Content</p>
    </Wrapper>
  );

  expect(container).toMatchSnapshot();
});
```

Snapshots work well with stable markup.

---

# 13. Snapshot Testing + Storybook (Industry Standard)

Many teams generate snapshots automatically from Storybook stories.

Benefit:

* UI stories act as snapshot tests
* each story becomes a test case
* ensures stable visual DOM

But again—keep snapshots small and intentional.

---

# 14. Snapshot Testing + Emotion/Styled Components

Snapshot testing preserves classnames from CSS-in-JS.

Example:

```js
import renderer from "react-test-renderer";

const tree = renderer.create(<StyledBox />).toJSON();
expect(tree).toMatchSnapshot();
```

Useful for ensuring layout consistency.

---

# 15. Common Mistakes When Using Snapshots

Avoid:

1. Snapshotting huge components
2. Updating snapshots without checking diff
3. Relying on snapshots for behavior testing
4. Taking multiple snapshots in one test
5. Snapshotting async-loading components
6. Using snapshots as primary test strategy

Snapshots are a complement to behavior tests, not a replacement.

---

# 16. Full Production Example (Ideal Snapshot)

Styled component:

```jsx
function Divider() {
  return <hr className="divider" />;
}
```

Snapshot test:

```jsx
test("Divider UI remains consistent", () => {
  const { container } = render(<Divider />);
  expect(container).toMatchSnapshot();
});
```

Small, static, stable component → perfect for snapshots.

---

# 17. Follow-up Questions

1. Which components in your project are stable enough for snapshot tests?
2. Are you snapshotting large components unnecessarily?
3. Should some snapshots be replaced with behavior-based tests?
4. Do you review snapshot diffs carefully before updating?
5. Are dynamic components wrongly included in snapshot tests?
6. Should inline snapshots be used for small components?
7. Does your CI prevent accidental snapshot updates?
8. Can utility functions benefit from snapshot testing?
9. Are snapshot files growing too large?
10. Should some snapshot tests be removed to reduce noise?
