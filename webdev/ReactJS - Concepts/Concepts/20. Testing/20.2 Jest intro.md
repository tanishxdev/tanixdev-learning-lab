# **20.2 Jest Intro**

A complete, production-focused introduction to **Jest**, covering what it is, why React developers use it, how it fits into the testing ecosystem, how test execution works, and the foundational patterns you need before writing React Testing Library tests.

---

# 1. What Is Jest?

Jest is a **JavaScript testing framework** created by Facebook (Meta). It is the de-facto standard for testing:

* React applications
* JavaScript utilities
* Node.js backend logic
* Integrated API flows (with mocks)

Jest provides:

* test runner
* assertion library
* mocking system
* snapshot testing
* code coverage

All in one tool.

You do not need Mocha, Chai, Sinon, or Jasmine when using Jest.
Jest replaces all of them.

---

# 2. Why Jest Is the Standard for React Testing

## Reason 1: Built-in mocking capabilities

Jest can mock:

* functions
* modules
* network requests
* timers
* global objects

Mocking is essential for testing React apps without making real network calls.

---

## Reason 2: Fast parallel test execution

Jest runs tests in parallel using worker processes.
Large test suites finish quickly even in big projects.

---

## Reason 3: Works perfectly with React Testing Library

RTL controls the DOM.
Jest controls the test environment.

Together, they simulate real user behavior without a browser.

---

## Reason 4: Snapshot testing for stable UI components

Snapshot tests record output and compare on future runs.
Useful for checking structural changes.

---

## Reason 5: Rich ecosystem and plugins

Jest supports:

* TypeScript
* Babel
* ESLint
* React Testing Library
* Vite, Next.js, CRA configurations

Most React boilerplates already include Jest support.

---

# 3. How Jest Executes Tests

Jest runs all files matching this pattern:

```
*.test.js  
*.test.jsx  
*.spec.js  
*.spec.jsx  
```

Execution flow:

1. Load the test environment
2. Import tested module
3. Execute test blocks (`test`, `it`)
4. Evaluate assertions
5. Report failures
6. Provide coverage (if enabled)

Example:

```js
test("adds two numbers", () => {
  expect(1 + 1).toBe(2);
});
```

If any assertion fails, Jest marks the test as failed.

---

# 4. Writing Your First Jest Test

Example utility:

```js
export function sum(a, b) {
  return a + b;
}
```

Test file:

```js
import { sum } from "./sum";

test("sum adds numbers correctly", () => {
  expect(sum(2, 3)).toBe(5);
});
```

Run:

```
npm test
```

Jest finds the file and runs the test.

---

# 5. Basic Jest Syntax

## Test block

```js
test("description", () => {
  // assertions
});
```

Equivalent:

```js
it("description", () => {
  // assertions
});
```

## Assertions

```js
expect(value).toBe(expected)
expect(value).toEqual(object)
expect(value).toContain(item)
expect(value).toBeTruthy()
expect(value).toBeFalsy()
```

Assertions verify correctness of code behavior.

---

# 6. Grouping Tests with describe

Organize related tests:

```js
describe("math utilities", () => {
  test("adds", () => { ... });
  test("subtracts", () => { ... });
});
```

This helps document features and keep tests readable.

---

# 7. Testing Asynchronous Code

### Using async/await

```js
test("fetchUser returns data", async () => {
  const data = await fetchUser();
  expect(data.id).toBe(1);
});
```

### Using mock resolved values

```js
mockFn.mockResolvedValue({ id: 1 });
```

Jest handles async tests through Promises.

---

# 8. Mocking Functions

Jest can replace real functions with fake ones:

```js
const mockFn = jest.fn();
mockFn("hello");

expect(mockFn).toHaveBeenCalled();
expect(mockFn).toHaveBeenCalledWith("hello");
```

Mocking is crucial for testing:

* API calls
* expensive operations
* network flows
* timers

---

# 9. Mocking Modules

Example: mock axios globally.

```js
jest.mock("axios", () => ({
  get: jest.fn(),
  post: jest.fn()
}));
```

Then in tests:

```js
axios.get.mockResolvedValue({ data: { id: 5 } });
```

Mocking ensures React components do not hit real servers during testing.

---

# 10. Testing Errors with Jest

```js
function explode() {
  throw new Error("Boom");
}

test("throws an error", () => {
  expect(explode).toThrow("Boom");
});
```

Error testing is important for:

* validators
* reducers
* API wrappers

---

# 11. Jest with JSDOM (React environment)

Jest uses **JSDOM**, a simulated browser environment.
This lets you test UI code without a real browser.

React Testing Library runs components inside this virtual DOM.

Example:

```js
document.body.innerHTML = "<button>Click</button>";
```

This DOM behaves like a browser for testing purposes.

---

# 12. How Jest Fits into Modern React Dev Workflow

Typical flow:

1. Developer writes component
2. Developer writes test
3. Developer runs Jest in watch mode
4. Test passes â†’ commit
5. CI pipeline runs Jest
6. Deployment only happens if tests pass

This produces stable, predictable releases.

---

# 13. Basic Jest Configuration Example

File: `jest.config.js`

```js
export default {
  testEnvironment: "jsdom",
  transform: {
    "^.+\\.(js|jsx)$": "babel-jest"
  },
  moduleNameMapper: {
    "\\.(css|scss)$": "identity-obj-proxy"
  }
};
```

This config works with most React projects.

---

# 14. What Jest Does NOT Do

Jest does not:

* render React components (React Testing Library does this)
* simulate real browser behavior (Playwright/Cypress do that)
* replace need for integration tests
* replace need for E2E tests

Jest is primarily the **testing engine**.

---

# 15. Follow-up Questions

1. Does your project already include Jest or do you need to configure it manually?
2. Which utilities or pure functions in your project should be unit tested first?
3. Are you comfortable with mocking modules and functions?
4. Does your CI pipeline run Jest automatically on commits?
5. How do you plan to structure your test files (folder-per-feature or colocation)?
6. Have you used async/await tests before?
7. Do you understand the difference between JSDOM vs real browser?
8. Which parts of your app depend on mocking (API, context, Redux, etc.)?
9. Are you planning to add snapshot tests for UI components?
10. Do you want tests to run in watch mode during development?
