# 11.3 useCallback Optimization

useCallback is one of the most misunderstood hooks in React.
Most beginners either:

* never use it (which causes unnecessary re-renders), or
* overuse it everywhere (which harms performance).

You will learn exactly **why**, **when**, and **how** to use useCallback.

We will go slowly, step-by-step.

---

# 1. What is useCallback?

useCallback returns a **memoized version of a function**, meaning the function will keep the same reference across re-renders unless its dependency changes.

Example:

```jsx
const fn = useCallback(() => {
  console.log("hello");
}, []);
```

React guarantees that `fn` will be the same function reference on every render.

---

# 2. Why do we need useCallback?

Because in JavaScript:

```
Every time a component renders, functions are recreated.
```

Example:

```jsx
<Child onClick={() => setCount(count + 1)} />
```

Here `() => setCount(count + 1)` is a new function every render.

Even if the logic is same, the function reference is different.

React.memo checks props using shallow comparison:

```
oldFn === newFn  // always false
```

So Child re-renders unnecessarily.

useCallback solves this.

---

# 3. When to Use useCallback?

Use it when:

1. You pass a function to a memoized child component
2. That child should re-render only when the function's logic truly changes
3. Without useCallback the child re-renders even when unnecessary

Real-world scenarios:

* List items
* Buttons inside heavy components
* Accordion, Tabs, Cards
* Forms with multiple children
* Data tables

---

# 4. How useCallback Actually Works (Internally)

useCallback stores:

* The function reference
* The dependency values

On each render:

* If dependencies are the same → return old function reference
* If dependencies change → create new function

This ensures function identity stability.

---

# 5. Example: Without useCallback (Child always re-renders)

Create file:

`RenderCallback1_NoCallback.jsx`

```jsx
import { useState, memo } from "react";

const Child = memo(function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
});

export default function RenderCallback1_NoCallback() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  console.log("Parent rendered");

  return (
    <div>
      <h3>No useCallback Example</h3>

      <button onClick={increment}>Parent Button</button>

      <Child onClick={increment} />
    </div>
  );
}
```

Result:

* Parent renders
* Child renders every time because `increment` is a new function

React.memo cannot stop Child from re-rendering because props changed.

---

# 6. With useCallback (Correct Optimization)

`RenderCallback2_WithCallback.jsx`

```jsx
import { useState, memo, useCallback } from "react";

const Child = memo(function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Child Button</button>;
});

export default function RenderCallback2_WithCallback() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  console.log("Parent rendered");

  return (
    <div>
      <h3>useCallback Example</h3>

      <button onClick={increment}>Parent Button</button>

      <Child onClick={increment} />
    </div>
  );
}
```

Now:

* Parent renders
* increment has the same function reference every render
* Child does not re-render unnecessarily

---

# 7. Common Mistake: Using useCallback everywhere

Bad example:

```jsx
const add = useCallback(() => setValue(v => v + 1), []);
const subtract = useCallback(() => setValue(v => v - 1), []);
const multiply = useCallback(() => setValue(v => v * 2), []);
```

Overusing useCallback creates overhead:

* React must compare dependencies
* React must store memoized references
* It adds memory cost

Never use useCallback unless:

* You pass the function to a memoized child
* The child re-renders without useCallback
* The function creation is expensive

---

# 8. When NOT to Use useCallback

Avoid useCallback when:

1. You are not passing the function down as a prop
2. Child is not memoized
3. Component is small and cheap
4. You are prematurely optimizing
5. The function is trivial

Example where useCallback is unnecessary:

```jsx
<button onClick={() => setCount(count + 1)}>Increase</button>
```

There is no performance benefit here.

---

# 9. Combining React.memo + useCallback

This is the real optimization pattern:

```
React.memo prevents unnecessary re-renders
useCallback keeps function stable
```

Together they prevent:

* Child re-renders
* List re-renders
* Heavy UI re-renders

This is extremely common in production apps.

---

# 10. Summary of useCallback

useCallback is used to:

* Keep function reference stable
* Prevent child components from unnecessary re-renders
* Enhance React.memo efficiency

Do not use it everywhere.
Use it when it solves a real re-render problem.

---

