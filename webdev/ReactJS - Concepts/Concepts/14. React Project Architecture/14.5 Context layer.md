

# 14.5 CONTEXT LAYER

Context is one of the most misunderstood parts of React.

You must understand **when to use it**, **why to use it**, and **how to structure it** properly in a scalable architecture.

Let’s proceed step-by-step, clean and clear.

---

# 1. What Problem Does Context Solve?

Without context, data flows only like this:

```
Parent → Child → Grandchild → DeepChild → ...
```

This is called **prop drilling**.

Example:

* User authentication
* Theme
* Language
* Cart
* Global settings

These values must travel deep into the component tree.

Prop drilling makes everything messy.

Context solves this.

---

# 2. What Context Does

Context allows you to:

* Store global data
* Make it available to all components
* Without passing props manually

It creates a global container for values.

But context is NOT a replacement for:

* Redux
* Zustand
* Complex state management

It is suitable for small global states.

---

# 3. When To Use Context

Use context for:

* Authentication (user, login, logout)
* Theme (light/dark)
* Language
* Current user settings
* Application layout settings (sidebar open/close)
* Very small global state

---

# 4. When NOT To Use Context

Do NOT use context for:

* Large global state
* High-frequency updates
* List of products
* Cart with many operations
* Search filters
* Messaging systems

Because context re-renders everything inside it.

Better to use:

* Redux Toolkit
* Zustand
* Jotai

---

# 5. Folder Structure for Context Layer

```
src/context/
    AuthContext.jsx
    ThemeContext.jsx
    LanguageContext.jsx
```

Each context file contains:

* Create context
* Provider
* State
* Actions

---

# 6. Example: AuthContext (Most Common in Applications)

File: `src/context/AuthContext.jsx`

```jsx
import { createContext, useState } from "react";

export const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);

  const login = (data) => setUser(data);
  const logout = () => setUser(null);

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}
```

Now wrap the entire app:

In `main.jsx` or `App.jsx`:

```jsx
<AuthProvider>
  <AppRouter />
</AuthProvider>
```

Now any component can access auth.

---

# 7. How to Use Context Inside Components

Create a helper hook (very important).

File: `src/hooks/useAuth.js`

```jsx
import { useContext } from "react";
import { AuthContext } from "../context/AuthContext";

export default function useAuth() {
  return useContext(AuthContext);
}
```

Use it anywhere:

```jsx
const { user, login, logout } = useAuth();
```

This makes context consumption clean.

---

# 8. Example Usage

Login Component:

```jsx
import useAuth from "../hooks/useAuth";

export default function Login() {
  const { login } = useAuth();

  const handleSubmit = () => {
    login({ name: "Tanish", id: 10 });
  };

  return (
    <button onClick={handleSubmit}>Login</button>
  );
}
```

Navbar Component:

```jsx
import useAuth from "../hooks/useAuth";

export default function Navbar() {
  const { user, logout } = useAuth();

  return (
    <nav>
      {user ? (
        <>
          <span>Welcome {user.name}</span>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <button>Login</button>
      )}
    </nav>
  );
}
```

Context made this extremely simple.

---

# 9. Real Architecture Technique: Split Context Logic

Professional pattern:

```
AuthContext.jsx → context
useAuth.js → hook
authService.js → API calls
authSlice/store → global store (optional)
```

This creates:

* Clean separation
* Scalable logic
* Context for small global state
* Services for API
* Store for complex workflows

---

# 10. Avoid Context Re-render Problems

Context re-renders EVERY component that consumes it.

To fix it:

A) Split contexts into small ones
B) Memoize provider values
C) Use selectors with Zustand/Redux for large state

Example:

```jsx
<AuthContext.Provider value={{ user, login, logout }}>
```

Better:

```jsx
const value = useMemo(() => ({ user, login, logout }), [user]);

<AuthContext.Provider value={value}>
```

---

# 11. Summary

You now understand:

Context is GOOD for:

* Auth
* Theme
* Settings
* Very small global state

Context is BAD for:

* Large state
* Data-heavy updates
* Frequent re-renders

Context fits perfectly in architecture when:

* You keep it small
* You separate logic
* You wrap the app
* You use custom hooks
* You don't overload context

This is how companies use Context.
