

# 14.6 STATE LAYER

This layer is responsible for **global state management**.

Local state (useState) is not enough for large applications.
Context helps only for small global states.
Real apps need something more predictable, scalable, and optimized.

This is where the **State Layer** comes in.

We will cover:

1. Why global state is needed
2. Problems with context-only state
3. When to use Redux Toolkit
4. When to use Zustand
5. Comparison
6. Folder structure
7. Example of auth/cart global state
8. Industry patterns

Letâ€™s go step-by-step.

---

# 1. Why Do We Need a State Layer?

Local component state is good for:

* Button toggles
* Form inputs
* Component-specific logic

But some data must be shared across the app:

* User authentication
* User profile
* Cart
* Wishlist
* Theme
* Notifications
* Application settings
* Filters
* Search state

Managing all this with props or context becomes:

* Complex
* Slow
* Hard to maintain
* Hard to scale

This is why industry uses **state management libraries**.

---

# 2. What NOT to do: Using Context for Everything

Context is not built to handle:

* Large data
* High-frequency updates
* Deep nested state
* Performance-sensitive data
* Complex async flows

Context re-renders all consumers on every update.
Large applications become slow.

---

# 3. What You Should Use Instead

Modern React uses 2 main tools:

## A) Redux Toolkit

Best for:

* Large apps
* Complex business logic
* API integration
* Predictable state flows
* Team collaboration

Most enterprise apps use Redux Toolkit.

## B) Zustand

Best for:

* Small to medium apps
* Simple global state
* Fast performance
* Minimal boilerplate

Most modern startups prefer Zustand because it is simple and fast.

---

# 4. How to Decide? (Simple Rules)

### Use Redux Toolkit if:

* You have a big app
* You need predictable global state
* You need API integration (RTK Query)
* You have complex logic (cart, payments, orders)
* You work in a team

### Use Zustand if:

* You have medium/small app
* You want very easy state management
* You want minimal re-renders
* You want global state without complexity
* You want high performance

### Never use only Context for:

* Cart
* Products
* Heavy filters
* Async data lists
* Room state in chat apps

This will make your app slow.

---

# 5. Folder Structure for State Layer

```
src/store/
    index.js
    authSlice.js         (Redux) OR authStore.js (Zustand)
    cartSlice.js
    themeSlice.js
    productSlice.js
```

Clear, predictable, scalable.

---

# 6. Example 1: Redux Toolkit (Auth Slice)

File: `src/store/authSlice.js`

```jsx
import { createSlice } from "@reduxjs/toolkit";

const authSlice = createSlice({
  name: "auth",
  initialState: {
    user: null
  },
  reducers: {
    login(state, action) {
      state.user = action.payload;
    },
    logout(state) {
      state.user = null;
    }
  }
});

export const { login, logout } = authSlice.actions;
export default authSlice.reducer;
```

Store setup:

`src/store/index.js`

```jsx
import { configureStore } from "@reduxjs/toolkit";
import authReducer from "./authSlice";

export const store = configureStore({
  reducer: {
    auth: authReducer
  }
});
```

Wrap App:

```jsx
import { Provider } from "react-redux";
import { store } from "./store";

<Provider store={store}>
  <App />
</Provider>
```

Use it:

```jsx
import { useDispatch, useSelector } from "react-redux";
import { login } from "../store/authSlice";

const dispatch = useDispatch();
dispatch(login({ name: "Tanish" }));
```

This is scalable for large apps.

---

# 7. Example 2: Zustand (Auth Store)

File: `src/store/authStore.js`

```jsx
import { create } from "zustand";

export const useAuthStore = create((set) => ({
  user: null,
  login: (data) => set({ user: data }),
  logout: () => set({ user: null })
}));
```

Use it anywhere:

```jsx
const { user, login, logout } = useAuthStore();
```

No provider needed.
No boilerplate.
Very fast.
Zero re-renders for other components.

This is why many modern apps use Zustand.

---

# 8. Industry Recommendation

Today, the industry uses:

### For large + enterprise apps:

**Redux Toolkit + RTK Query**

### For medium apps:

**Zustand**

### For small apps:

**Context + Hooks**

Your skill should include:

* Context (small global state)
* Redux Toolkit (complex state)
* Zustand (simple and fast global state)

This makes you a complete React developer.

---

# 9. What You Should NOT Do

Avoid:

* Overusing Context
* Putting everything in one store file
* Writing unnecessary boilerplate
* Mixing Context, Redux, Zustand together
* Storing random UI state globally

State should be organized and purposeful.

---

# 10. Summary of State Layer

You now know:

* Why global state is needed
* Why context is not enough
* When to use Redux Toolkit
* When to use Zustand
* Folder structure for state layer
* Real examples
* Enterprise-ready patterns

This is exactly how React professionals structure their state.

---