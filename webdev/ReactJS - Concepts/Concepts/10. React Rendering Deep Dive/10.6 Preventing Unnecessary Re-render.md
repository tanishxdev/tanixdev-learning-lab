
# 10.6 PREVENTING UNNECESSARY RE-RENDERS

This topic directly affects:

* App speed
* Smooth UI
* Performance
* Large-scale scalability
* Battery usage (mobile)
* CPU usage (heavy dashboards)

Most React developers understand rendering…
But **do not understand how to STOP re-rendering**.

You will learn **exact techniques + components** to practice.

We will go slowly.

---

# 1. First: Why prevent re-renders?

Rendering is cheap.
DOM updates are expensive.

But unnecessary rendering:

* Slows UI
* Causes lag in lists
* Breaks animations
* Wastes CPU cycles
* Makes React apps feel slower

As apps grow (todo → e-commerce → dashboard) unnecessary re-renders become a real problem.

So now your goal is:

> Keep React components re-rendering only when necessary.

---

# 2. There are 4 main tools to prevent unnecessary re-renders

You will master all of them:

1. **React.memo**
2. **useCallback**
3. **useMemo**
4. **Proper key usage**

We will cover each with code examples and a complete mental model.

---

# 3. TOOL 1 — React.memo

React.memo prevents re-render if props did not change.

Meaning:
If the parent re-renders but the child received the same props, the child WILL NOT re-render.

---

# Example: Without memo (slow)

Create file:

### Render9_NoMemo.jsx

```jsx
import { useState } from "react";

function Child() {
  console.log("Child rendered");
  return <p>Child Component</p>;
}

export default function Render9_NoMemo() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  return (
    <div>
      <h3>No Memo</h3>

      <button onClick={() => setCount(count + 1)}>
        Update Parent
      </button>

      <Child />
    </div>
  );
}
```

Output:
Every time parent updates:

* Parent re-renders
* Child re-renders

Even though Child does not depend on count.

This is wasteful.

---

# Example: With memo (optimized)

### Render10_WithMemo.jsx

```jsx
import { useState, memo } from "react";

const Child = memo(function Child() {
  console.log("Child rendered");
  return <p>Child Component</p>;
});

export default function Render10_WithMemo() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  return (
    <div>
      <h3>With React.memo</h3>

      <button onClick={() => setCount(count + 1)}>
        Update Parent
      </button>

      <Child />
    </div>
  );
}
```

Now Child renders only once.

Parent logs multiple times but Child does not.

---

# 4. TOOL 2 — useCallback

Fixes unnecessary re-renders when passing functions as props.

Problem:
Every render creates a NEW function reference.

Example:

```jsx
<Child onClick={() => setCount(count + 1)} />
```

This forces child to re-render because `() => ...` is a new function each time.

Solution:
Use useCallback.

---

### Render11_UseCallback.jsx

```jsx
import { useState, memo, useCallback } from "react";

const Child = memo(function Child({ onUpdate }) {
  console.log("Child rendered");
  return <button onClick={onUpdate}>Child Button</button>;
});

export default function Render11_UseCallback() {
  const [count, setCount] = useState(0);

  console.log("Parent rendered");

  const handleUpdate = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return (
    <div>
      <h3>useCallback Example</h3>

      <Child onUpdate={handleUpdate} />
    </div>
  );
}
```

Now:

* Child receives stable function reference
* Child re-renders only when necessary

useCallback ensures function identity is stable.

---

# 5. TOOL 3 — useMemo

Used to stabilize value references (objects, arrays) to prevent re-renders.

If you pass:

```jsx
<Child data={{name: "Tanish"}} />
```

React sees a new object every time.
Child re-renders every time.

Fix:

```jsx
const user = useMemo(() => ({ name: "Tanish" }), []);
<Child data={user} />
```

Now user object reference is stable.

---

### Render12_UseMemoValues.jsx

```jsx
import { memo, useMemo, useState } from "react";

const Child = memo(function Child({ user }) {
  console.log("Child rendered with:", user);
  return <p>{user.name}</p>;
});

export default function Render12_UseMemoValues() {
  const [count, setCount] = useState(0);

  const user = useMemo(() => ({ name: "Tanish" }), []);

  return (
    <div>
      <h3>useMemo for Values</h3>

      <button onClick={() => setCount(count + 1)}>
        Update Parent
      </button>

      <Child user={user} />
    </div>
  );
}
```

Child renders only once now.

---

# 6. TOOL 4 — Proper Keys

React uses keys to identify items in lists.

Using **index as key** breaks reconciliation and causes unnecessary re-renders:

```jsx
<li key={index}>...</li>
```

Correct:

```jsx
<li key={item.id}>...</li>
```

Stable keys prevent React from treating unchanged items as new ones.

---

# 7. Summary of Optimization Tools

| Tool        | Use Case                                         |
| ----------- | ------------------------------------------------ |
| React.memo  | Prevent child re-render when props unchanged     |
| useCallback | Prevent new function identity on each render     |
| useMemo     | Prevent new object/array identity on each render |
| Keys        | Prevent list re-renders and DOM misbehavior      |

Together, they create a performance-optimized React app.

---

# 8. Mental Model (Very Important)

React re-renders by default.
You control that rendering by stabilizing:

* Props
* References
* Functions
* Objects
* Arrays

Your job is to reduce re-renders **without breaking data flow**.

---

# 9. Next Topic in Rendering Deep Dive

If you say "next", we proceed to:

# 10.7 Summary + Comparison + Architecture Notes

This final section will combine everything:

* Rendering triggers
* Reconciliation
* Fiber
* Optimization tools
* A mental map of the entire rendering pipeline
* How to structure components for minimum re-renders

Then after finishing rendering deep dive, we move to:

* 2. React Project Architecture
* Project 02 Todo
* Or any next topic you choose.
