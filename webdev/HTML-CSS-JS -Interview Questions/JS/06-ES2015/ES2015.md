# ES2015+ and Modern JavaScript Features

## 31. What are the new features introduced in ES6 (ES2015)?

---

### 1. Concept

**ES6 (ECMAScript 2015)** was a **major update** to JavaScript that transformed it from a “simple scripting language” into a **modern, scalable programming language**.

Core idea:

> ES6 introduced **better syntax, better scoping, better async handling, and better code organization** to write **clean, maintainable, large-scale applications**.

Before ES6:

* JavaScript was messy for large projects
* Too much `var`, callbacks, and boilerplate

After ES6:

* Cleaner syntax
* Predictable behavior
* Modular, scalable code

---

### 2. Why ES6 Was Introdued (Why Interviewers Ask This)

ES6 solved real problems like:

* Global scope pollution (`var`)
* Callback hell
* No module system
* Hard-to-read string concatenation
* Confusing `this`

Interviewers want to know:

* Do you know **what changed**
* Do you know **why it changed**

---

### 3. Major ES6 Features (High-Level List)

ES6 introduced **many features**, but interviews focus on these **core ones**:

| Category   | Feature                   |
| ---------- | ------------------------- |
| Variables  | `let`, `const`            |
| Functions  | Arrow functions           |
| Strings    | Template literals         |
| Objects    | Destructuring, shorthand  |
| Arrays     | Destructuring, spread     |
| Parameters | Default parameters, rest  |
| Async      | Promises                  |
| OOP        | Classes                   |
| Modules    | `import` / `export`       |
| Iteration  | `for...of`                |
| Others     | Spread operator, Map, Set |

---

### 4. Key ES6 Features with Examples (Interview-Focused)

#### 1. `let` and `const` (Block Scope)

```javascript
let count = 10;
const PI = 3.14;
```

Why important:

* Block-scoped
* Prevents bugs caused by `var`
* `const` prevents reassignment

---

#### 2. Arrow Functions

```javascript
const add = (a, b) => a + b;
```

Why important:

* Shorter syntax
* Lexical `this`
* Cleaner callbacks

---

#### 3. Template Literals

```javascript
let name = "Tanish";
console.log(`Hello, ${name}`);
```

Why important:

* Clean string interpolation
* Multi-line strings

---

#### 4. Destructuring Assignment

```javascript
const user = { name: "Tanish", age: 21 };
const { name, age } = user;
```

Why important:

* Cleaner access
* Less repetitive code

---

#### 5. Default Parameters

```javascript
function greet(name = "Guest") {
  return `Hello ${name}`;
}
```

Why important:

* Avoids manual checks like `if (!name)`

---

#### 6. Spread and Rest Operator (`...`)

```javascript
const arr = [1, 2, 3];
const copy = [...arr];
```

Why important:

* Easy copying
* Function arguments handling

---

#### 7. Promises (Async Handling)

```javascript
fetch(url)
  .then(res => res.json())
  .then(data => console.log(data));
```

Why important:

* Replaced callback hell
* Foundation for `async/await`

---

#### 8. Classes (Syntactic Sugar)

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
}
```

Why important:

* Cleaner OOP
* Still prototype-based internally

---

#### 9. Modules (`import` / `export`)

```javascript
export function add(a, b) {
  return a + b;
}
```

Why important:

* Proper code organization
* Avoids global scope pollution

---

### 5. ES5 vs ES6 (Interview Comparison)

| ES5                  | ES6               |
| -------------------- | ----------------- |
| `var`                | `let`, `const`    |
| Function callbacks   | Arrow functions   |
| String concatenation | Template literals |
| No modules           | `import/export`   |
| Callbacks            | Promises          |
| Prototype syntax     | Classes           |

---

### 6. Common Interview Traps

1. ES6 ≠ JavaScript version
   ES6 is a **standard**, not a new language.

2. Classes are **not real classes**
   They are syntax over prototypes.

3. Arrow functions are **not replacements** for all functions
   They don’t have their own `this`.

---

### 7. Interview-Ready Summary

ES6 (ECMAScript 2015) introduced major improvements to JavaScript, including `let` and `const` for block scoping, arrow functions, template literals, destructuring, default parameters, promises, classes, and modules. These features made JavaScript cleaner, more predictable, and suitable for building large-scale applications.

---

### 8. Quick Practice Interview Questions

1. Why was ES6 a major release?
2. Difference between `var` and `let`?
3. Are ES6 classes real classes?
4. Why are arrow functions important?
5. What problem do modules solve?
6. Is ES6 backward compatible?
7. Which ES6 feature do you use most and why?

---
## 32. How do you use destructuring assignments in ES6?

---

### 1. Concept

**Destructuring assignment** is an ES6 feature that allows you to **extract values from arrays or properties from objects** and store them into variables **in a single, clean statement**.

Core idea:

> Destructuring lets you **unpack data structures** (arrays / objects) into variables based on **position (arrays)** or **property name (objects)**.

It is purely **syntax**, but it greatly improves:

* readability
* less repetitive code
* fewer bugs

---

### 2. Why Destructuring Was Introduced (Why Interviewers Care)

Before ES6, extracting values was verbose and repetitive:

```javascript
const user = { name: "Tanish", age: 21 };

const name = user.name;
const age = user.age;
```

Problems:

* Repetition
* Harder to refactor
* Messy with large objects

Destructuring solves this cleanly.

---

### 3. Object Destructuring

#### Basic Object Destructuring

```javascript
const user = {
  name: "Tanish",
  age: 21,
  role: "Developer"
};

const { name, age } = user;

console.log(name); // Tanish
console.log(age);  // 21
```

How it works:

* Variable names must **match object keys**
* Order does **not** matter (keys matter)

---

#### Renaming Variables (Interview Favorite)

```javascript
const { name: userName, age: userAge } = user;

console.log(userName); // Tanish
console.log(userAge);  // 21
```

Use case:

* Avoid name conflicts
* Improve clarity

---

#### Default Values in Object Destructuring

```javascript
const { city = "Delhi" } = user;

console.log(city); // Delhi
```

Why useful:

* Prevents `undefined`
* Common in API responses

---

### 4. Array Destructuring

#### Basic Array Destructuring

```javascript
const numbers = [10, 20, 30];

const [a, b, c] = numbers;

console.log(a); // 10
console.log(b); // 20
console.log(c); // 30
```

Key rule:

* **Order matters**
* Variable names don’t matter

---

#### Skipping Values

```javascript
const [first, , third] = numbers;

console.log(first); // 10
console.log(third); // 30
```

---

#### Default Values in Arrays

```javascript
const [x, y = 5] = [10];

console.log(x); // 10
console.log(y); // 5
```

---

### 5. Destructuring in Function Parameters (Very Important)

#### Object Destructuring in Parameters

```javascript
function printUser({ name, age }) {
  console.log(name, age);
}

printUser({ name: "Tanish", age: 21 });
```

Why interviewers love this:

* Clean function signatures
* Self-documenting code

With defaults:

```javascript
function printUser({ name = "Guest", age = 0 }) {
  console.log(name, age);
}
```

---

#### Array Destructuring in Parameters

```javascript
function sum([a, b]) {
  return a + b;
}

sum([10, 20]); // 30
```

---

### 6. Nested Destructuring (Advanced but Common)

```javascript
const user = {
  name: "Tanish",
  address: {
    city: "Delhi",
    pincode: 110001
  }
};

const {
  address: { city, pincode }
} = user;

console.log(city);    // Delhi
console.log(pincode); // 110001
```

Important note:

* `address` itself is **not created as a variable** here
* Only `city` and `pincode` are extracted

---

### 7. Destructuring with Rest Operator (`...`)

#### Object Rest

```javascript
const user = { name: "Tanish", age: 21, role: "Dev" };

const { name, ...rest } = user;

console.log(name); // Tanish
console.log(rest); // { age: 21, role: "Dev" }
```

---

#### Array Rest

```javascript
const nums = [1, 2, 3, 4];

const [first, ...others] = nums;

console.log(first);  // 1
console.log(others); // [2, 3, 4]
```

---

### 8. Common Interview Traps

#### Trap 1: Destructuring `undefined` or `null`

```javascript
const { x } = undefined; // ❌ TypeError
```

Safe pattern:

```javascript
const { x } = obj || {};
```

---

#### Trap 2: Wrong Variable Names

```javascript
const { username } = user; // undefined if key is `name`
```

Keys must match unless renamed.

---

### 9. Mental Model (Very Important)

* Object destructuring → **match by key**
* Array destructuring → **match by position**
* Defaults apply only when value is `undefined`
* Destructuring does **not modify** original data

---

### 10. Interview-Ready Summary

Destructuring assignment in ES6 allows extracting values from objects and arrays into variables using a concise syntax. Object destructuring is based on property names, while array destructuring depends on position. It supports default values, renaming, nested structures, and function parameter usage, making code cleaner and more readable.

---

### 11. Quick Practice Interview Questions

1. Difference between array and object destructuring?
2. Does order matter in object destructuring?
3. How do you rename variables while destructuring?
4. What happens if a key doesn’t exist?
5. How do default values work in destructuring?
6. Can destructuring be used in function parameters?
7. What is a common destructuring runtime error?

---

## 33. Explain the use of `const` and `let` keywords

---

### 1. Concept

`let` and `const` were introduced in **ES6** to replace most use cases of `var`.

Core idea:

> `let` and `const` provide **block-scoped variables**, predictable behavior, and help avoid common JavaScript bugs caused by `var`.

* `let` → for **values that can change**
* `const` → for **values that should not be reassigned**

Both are **block-scoped**, unlike `var`.

---

### 2. Why `var` Was a Problem (Context for Interviews)

Problems with `var`:

* Function-scoped, not block-scoped
* Hoisting with `undefined`
* Easy to accidentally overwrite variables
* Bugs in loops and conditionals

Example bug:

```javascript
if (true) {
  var x = 10;
}
console.log(x); // 10 (leaks outside block)
```

ES6 fixed this using `let` and `const`.

---

### 3. `let` Keyword

#### Definition

`let` declares a **block-scoped variable** whose value **can be reassigned**.

#### Example

```javascript
let count = 1;
count = 2; // allowed
```

#### Block Scope Behavior

```javascript
if (true) {
  let a = 10;
}
console.log(a); // ReferenceError
```

Key points:

* Exists only inside `{ }`
* Prevents accidental access

---

### 4. `const` Keyword

#### Definition

`const` declares a **block-scoped variable** that **cannot be reassigned**.

```javascript
const PI = 3.14;
PI = 3.1415; // TypeError
```

Important clarification (very common interview trap):

> `const` prevents **reassignment**, not **mutation**.

---

#### `const` with Objects and Arrays

```javascript
const user = { name: "Tanish" };
user.name = "Kumar"; // allowed
```

Why?

* Reference is constant
* Object content can change

But this is NOT allowed:

```javascript
user = {}; // ❌ TypeError
```

Same with arrays:

```javascript
const nums = [1, 2, 3];
nums.push(4); // allowed
nums = [];    // ❌ not allowed
```

---

### 5. Block Scope Comparison (`var` vs `let` vs `const`)

```javascript
{
  var a = 1;
  let b = 2;
  const c = 3;
}

console.log(a); // 1
console.log(b); // ReferenceError
console.log(c); // ReferenceError
```

---

### 6. Hoisting and Temporal Dead Zone (TDZ)

Both `let` and `const` are **hoisted**, but:

* They are **not initialized**
* They stay in **Temporal Dead Zone (TDZ)** until declared

```javascript
console.log(x); // ReferenceError
let x = 10;
```

Key difference from `var`:

* `var` → `undefined`
* `let/const` → ReferenceError

---

### 7. `let` vs `const` (Interview Comparison Table)

| Feature         | `let`           | `const`          |
| --------------- | --------------- | ---------------- |
| Reassignment    | Allowed         | Not allowed      |
| Block scoped    | Yes             | Yes              |
| Hoisted         | Yes (TDZ)       | Yes (TDZ)        |
| Must initialize | No              | Yes              |
| Preferred usage | Changing values | Fixed references |

---

### 8. Best Practices (Must Say in Interview)

* Use `const` **by default**
* Use `let` only when reassignment is required
* Avoid `var` in modern JavaScript

Why this matters:

* Safer code
* Easier reasoning
* Fewer bugs

---

### 9. Common Interview Traps

1. `const` does NOT make objects immutable
2. `let` is NOT global-scoped
3. Both `let` and `const` are hoisted
4. TDZ applies to both

---

### 10. Interview-Ready Summary

`let` and `const` are ES6 keywords used to declare block-scoped variables. `let` allows reassignment, while `const` does not. Both are hoisted but remain in the Temporal Dead Zone until initialized. `const` prevents reassignment but allows mutation of objects and arrays. In modern JavaScript, `const` is preferred by default, and `let` is used only when reassignment is necessary.

---

### 11. Quick Practice Interview Questions

1. Difference between `var`, `let`, and `const`?
2. What is Temporal Dead Zone?
3. Can you modify a `const` object?
4. Why is `const` preferred over `let`?
5. What happens if you access `let` before declaration?
6. Is `const` immutable?
7. When should you use `let`?

---

## 34. What are default parameters in JavaScript functions?

---

### 1. Concept

**Default parameters** allow you to assign **default values to function parameters** if no argument (or `undefined`) is passed during a function call.

Introduced in **ES6**, they remove the need for **manual checks** inside functions.

Core idea:

> If a function argument is **missing or `undefined`**, the default value is used.

---

### 2. Problem Before ES6 (Why This Exists)

Before default parameters, developers wrote defensive code:

```javascript
function greet(name) {
  if (name === undefined) {
    name = "Guest";
  }
  return "Hello " + name;
}
```

Problems:

* Verbose
* Easy to forget checks
* Less readable

---

### 3. Basic Syntax of Default Parameters

```javascript
function greet(name = "Guest") {
  return `Hello ${name}`;
}

greet();        // Hello Guest
greet("Tanish"); // Hello Tanish
```

Key rule:

* Default applies **only when argument is `undefined`**

---

### 4. Default Parameters vs `null` (Very Important Interview Trap)

```javascript
function test(x = 10) {
  console.log(x);
}

test();        // 10
test(undefined); // 10
test(null);     // null
```

Why?

* `undefined` → triggers default
* `null` → treated as a real value

Interview keyword:

> Defaults apply only to `undefined`, not `null`.

---

### 5. Multiple Default Parameters

```javascript
function createUser(name = "Guest", age = 0) {
  return { name, age };
}

createUser();                 // { name: "Guest", age: 0 }
createUser("Tanish");         // { name: "Tanish", age: 0 }
createUser("Tanish", 21);     // { name: "Tanish", age: 21 }
```

---

### 6. Default Parameters with Expressions

Defaults can be **expressions**, not just values.

```javascript
function getPrice(price, tax = price * 0.1) {
  return price + tax;
}

getPrice(100); // 110
```

Important rule:

* Parameters are evaluated **left to right**
* You can use earlier parameters, not later ones

---

### 7. Default Parameters with Function Calls

```javascript
function getDefault() {
  return 5;
}

function test(x = getDefault()) {
  console.log(x);
}

test(); // 5
```

---

### 8. Default Parameters and Destructuring (Advanced but Common)

```javascript
function printUser({ name = "Guest", age = 0 } = {}) {
  console.log(name, age);
}

printUser(); // Guest 0
```

Why `= {}` is needed:

* Prevents destructuring `undefined`
* Common interview pitfall

---

### 9. Default Parameters vs Logical OR (`||`) Trick

Old pattern:

```javascript
function test(x) {
  x = x || 10;
  console.log(x);
}

test(0); // 10 ❌
```

ES6 default parameter:

```javascript
function test(x = 10) {
  console.log(x);
}

test(0); // 0 ✅
```

Why better:

* `||` fails for falsy values (`0`, `""`, `false`)
* Default parameters do not

---

### 10. Common Interview Traps

1. Defaults don’t apply to `null`
2. Defaults are evaluated at call time
3. Left-to-right parameter evaluation
4. Destructuring requires fallback `{}`

---

### 11. Mental Model (Simple)

* Argument missing → use default
* Argument is `undefined` → use default
* Argument is any other value → use it

---

### 12. Interview-Ready Summary

Default parameters in JavaScript allow functions to assign default values to parameters when arguments are missing or `undefined`. Introduced in ES6, they improve readability, remove manual checks, and behave more predictably than older patterns like logical OR. Default values can be expressions, function calls, or used with destructuring.

---

### 13. Quick Practice Interview Questions

1. When are default parameters used?
2. Do default parameters apply to `null`?
3. Can default values be expressions?
4. Why is default parameter better than `||`?
5. How do default parameters work with destructuring?
6. Are default values evaluated once or every call?
7. What happens if a later parameter is used as default?

---

## 35. Explain the concept of modules in ES6

---

### 1. Concept

**ES6 Modules** provide a **native, standardized way to split JavaScript code into separate files** and reuse it safely.

Core idea:

> A module is a **file with its own scope** that can **export** values and **import** them in other files.

This solved a **huge problem** in JavaScript:
**no proper module system before ES6**.

---

### 2. Problem Before ES6 (Why Modules Were Needed)

Before ES6, JavaScript had **no built-in modules**.

Common old patterns:

* Global variables (❌)
* IIFE (Immediately Invoked Function Expressions)
* Script loading order hacks

Example problem:

```html
<script src="a.js"></script>
<script src="b.js"></script>
```

Issues:

* Global scope pollution
* Order-dependent bugs
* Hard to maintain large codebases

ES6 modules fixed this.

---

### 3. What Is an ES6 Module?

An ES6 module:

* Is **one file**
* Has its **own scope**
* Uses `export` to expose values
* Uses `import` to consume values

Important interview line:

> Variables declared in a module are **not global by default**.

---

### 4. Named Exports

You can export **multiple values** from a module.

#### `math.js`

```javascript
export const PI = 3.14;

export function add(a, b) {
  return a + b;
}
```

#### Importing named exports

```javascript
import { PI, add } from "./math.js";

console.log(PI);       // 3.14
console.log(add(2, 3)); // 5
```

Rules:

* Names must match
* Use `{ }`

---

### 5. Default Exports

Each module can have **only one default export**.

#### `user.js`

```javascript
export default function greet(name) {
  return `Hello ${name}`;
}
```

#### Importing default export

```javascript
import greet from "./user.js";

greet("Tanish");
```

Key point:

* You can rename default imports freely

---

### 6. Mixing Named and Default Exports

```javascript
// utils.js
export const version = "1.0";

export default function log(msg) {
  console.log(msg);
}
```

```javascript
import log, { version } from "./utils.js";
```

---

### 7. Module Scope vs Global Scope (Interview Favorite)

```javascript
// a.js
const x = 10;
```

```javascript
// b.js
console.log(x); // ReferenceError
```

Why?

* Modules have **their own scope**
* Nothing leaks unless exported

---

### 8. `type="module"` in Browser

To use ES6 modules in the browser:

```html
<script type="module" src="main.js"></script>
```

Important behaviors:

* Modules run in **strict mode by default**
* `this` at top-level is `undefined`
* Files are loaded **deferred**

---

### 9. Live Bindings (Advanced Interview Concept)

Imports are **live bindings**, not copies.

```javascript
// counter.js
export let count = 0;

export function increment() {
  count++;
}
```

```javascript
// main.js
import { count, increment } from "./counter.js";

increment();
console.log(count); // 1
```

Key insight:

* Imported values update automatically

---

### 10. Common Interview Traps

1. Modules are always in strict mode
2. You cannot import conditionally at top-level
3. Default export ≠ named export
4. Imports are read-only
5. Circular imports are allowed (but tricky)

---

### 11. ES6 Modules vs CommonJS (Node.js)

| ES6 Modules     | CommonJS                 |
| --------------- | ------------------------ |
| `import/export` | `require/module.exports` |
| Static          | Dynamic                  |
| Browser-native  | Node-first               |
| Hoisted imports | Runtime `require`        |

---

### 12. Mental Model (Simple)

* One file = one module
* Export what you want to share
* Import what you need
* No globals
* Clear dependencies

---

### 13. Interview-Ready Summary

ES6 modules provide a native way to organize JavaScript code into separate, reusable files using `export` and `import`. Each module has its own scope, runs in strict mode, and avoids global namespace pollution. Modules support named and default exports, live bindings, and are the foundation of modern JavaScript applications.

---

### 14. Quick Practice Interview Questions

1. What problem do ES6 modules solve?
2. Difference between named and default exports?
3. Why are modules safer than scripts?
4. What does `type="module"` do?
5. Are imports copied or live bindings?
6. Can a module have multiple default exports?
7. Difference between ES6 modules and CommonJS?

---

