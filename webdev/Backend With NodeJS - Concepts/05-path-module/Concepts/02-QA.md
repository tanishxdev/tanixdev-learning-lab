# Common Mistakes & Interview Traps (Path Module – Node.js)

---

## 1. Treating File Paths as Simple Strings ❌

### Mistake

```js
const filePath = __dirname + "/data/notes.txt";
```

### Why this is wrong

* You are **manually guessing** the path separator
* `/` works on Linux/macOS, but Windows uses `\`
* Leads to:

  * double slashes
  * broken paths
  * OS-specific bugs

### Correct approach

```js
const filePath = path.join(__dirname, "data", "notes.txt");
```

### Interview trap

**Q:** Why should we avoid string concatenation for paths?
**A:** Because different operating systems use different path separators, and `path.join()` handles this safely.

---

## 2. Confusing `./` with `__dirname` ❌

### Mistake

```js
fs.readFile("./data/notes.txt", "utf8", callback);
```

### Why this breaks

* `./` is resolved **from where the command is run**
* Not from where the file exists
* Running Node from a different folder breaks the code

### Correct backend rule

```js
path.join(__dirname, "data", "notes.txt");
```

### Mental model

| Reference   | Depends on        |
| ----------- | ----------------- |
| `./`        | Terminal location |
| `__dirname` | File location     |

### Interview trap

**Q:** Why is `__dirname` preferred in backend code?
**A:** Because it always points to the file’s actual directory, independent of execution location.

---

## 3. Thinking `path.join()` Reads Files ❌

### Mistake

Believing:

```js
path.join("data", "notes.txt");
```

does something with the file.

### Reality

* `path.join()` **only builds a string**
* It does **not**:

  * check file existence
  * read files
  * create files

### Correct mental model

```
path.join() → builds path
fs → uses path
```

### Interview trap

**Q:** Does `path.join()` access the file system?
**A:** No. It only constructs path strings.

---

## 4. Forgetting to Store `path.join()` Result ❌

### Mistake

```js
path.join("data", "notes.txt");
```

and expecting it to be used automatically.

### Why this is wrong

* `path.join()` returns a value
* If you don’t store it, it is lost

### Correct usage

```js
const filePath = path.join("data", "notes.txt");
```

### Interview trap

**Q:** What does `path.join()` return?
**A:** A normalized path string.

---

## 5. Misunderstanding `path.join()` vs `path.resolve()` ❌

### Mistake

Using them interchangeably without understanding.

### Key difference

| Method           | Behavior                  |
| ---------------- | ------------------------- |
| `path.join()`    | Joins path segments       |
| `path.resolve()` | Resolves to absolute path |

Example:

```js
path.join("data", "notes.txt");
```

→ `data/notes.txt`

```js
path.resolve("data", "notes.txt");
```

→ `/full/absolute/path/data/notes.txt`

### Interview trap

**Q:** When would you use `path.resolve()`?
**A:** When I need an absolute path based on the current working directory.

---

## 6. Hardcoding Absolute Paths ❌

### Mistake

```js
const filePath = "C:\\Users\\tanish\\project\\data\\notes.txt";
```

### Why this is bad

* Works only on your machine
* Breaks in:

  * production
  * CI/CD
  * teammate systems

### Correct approach

```js
path.join(__dirname, "data", "notes.txt");
```

### Interview trap

**Q:** Why should absolute paths not be hardcoded?
**A:** They are environment-specific and break portability.

---

## 7. Assuming `/` Works Everywhere ❌

### Mistake

```js
"/data/notes.txt"
```

### Reality

* `/` is not universal
* Windows internally uses `\`

### Correct approach

Always let Node decide separators using `path`.

### Interview trap

**Q:** How does Node handle path separators across OS?
**A:** Using the `path` module, which normalizes paths based on the OS.

---

## 8. Forgetting to Use `path` with `fs` ❌

### Mistake

```js
fs.readFile("./data/notes.txt", "utf8", callback);
```

### Backend rule

```
If fs is involved → path must be involved
```

### Correct pattern

```js
const filePath = path.join(__dirname, "data", "notes.txt");
fs.readFile(filePath, "utf8", callback);
```

### Interview trap

**Q:** Why are `fs` and `path` commonly used together?
**A:** Because `path` safely constructs paths and `fs` performs file operations on them.

---

## 9. Misusing `path.extname()` ❌

### Mistake

Expecting:

```js
path.extname("notes");
```

to return something meaningful.

### Reality

* No extension → empty string
* Extension includes the dot

```js
path.extname("notes.txt"); // ".txt"
```

### Interview trap

**Q:** What does `path.extname()` return?
**A:** The file extension including the dot.

---

## 10. Not Understanding That `path` Is OS-Aware ❌

### Mistake

Thinking `path` behaves the same on all systems.

### Reality

* `path` internally adapts:

  * separators
  * normalization rules
  * root paths

### Interview trap

**Q:** Is `path.join()` output the same on Windows and Linux?
**A:** The logical path is the same, but separators differ based on OS.

---

## Final Interview Summary (Memorize)

* Paths are **not just strings**
* Never manually add `/` or `\`
* Always use `path.join()`
* Always anchor with `__dirname`
* `path` builds paths, `fs` uses them
* `path.join()` ≠ `path.resolve()`

---

## One-Line Interview Answer

> “I use the Node.js `path` module to construct OS-independent file paths safely, especially when working with the file system.”
